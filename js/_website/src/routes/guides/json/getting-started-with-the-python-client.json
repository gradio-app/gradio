{"guide": {"name": "getting-started-with-the-python-client", "category": "client-libraries", "pretty_category": "Client Libraries", "guide_index": 1, "absolute_index": 28, "pretty_name": "Getting Started With The Python Client", "content": "# Getting Started with the Gradio Python client \n\nTags: CLIENT, API, SPACES\n\n\nThe Gradio Python client makes it very easy to use any Gradio app as an API. As an example, consider this [Hugging Face Space that transcribes audio files](https://huggingface.co/spaces/abidlabs/whisper) that are recorded from the microphone.\n\n![](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/gradio-guides/whisper-screenshot.jpg)\n\nUsing the `gradio_client` library, we can easily use the Gradio as an API to transcribe audio files programmatically.\n\nHere's the entire code to do it:\n\n```python\nfrom gradio_client import Client\n\nclient = Client(\"abidlabs/whisper\") \nclient.predict(\"audio_sample.wav\")  \n\n>> \"This is a test of the whisper speech recognition model.\"\n```\n\nThe Gradio client works with any hosted Gradio app, whether it be an image generator, a text summarizer, a stateful chatbot, a tax calculator, or anything else! The Gradio Client is mostly used with apps hosted on [Hugging Face Spaces](https://hf.space), but your app can be hosted anywhere, such as your own server.\n\n**Prerequisites**: To use the Gradio client, you do *not* need to know the `gradio` library in great detail. However, it is helpful to have general familiarity with Gradio's concepts of input and output components.\n\n## Installation\n\nIf you already have a recent version of `gradio`, then the `gradio_client` is included as a dependency. \n\nOtherwise, the lightweight `gradio_client` package can be installed from pip (or pip3) and is tested to work with Python versions 3.9 or higher:\n\n```bash\n$ pip install gradio_client\n```\n\n\n## Connecting to a running Gradio App\n\nStart by connecting instantiating a `Client` object and connecting it to a Gradio app that is running on Hugging Face Spaces or generally anywhere on the web.\n\n## Connecting to a Hugging Face Space\n\n```python\nfrom gradio_client import Client\n\nclient = Client(\"abidlabs/en2fr\")  # a Space that translates from English to French\n```\n\nYou can also connect to private Spaces by passing in your HF token with the `hf_token` parameter. You can get your HF token here: https://huggingface.co/settings/tokens\n\n```python\nfrom gradio_client import Client\n\nclient = Client(\"abidlabs/my-private-space\", hf_token=\"...\") \n```\n\n\n## Duplicating a Space for private use\n\nWhile you can use any public Space as an API, you may get rate limited by Hugging Face if you make too many requests. For unlimited usage of a Space, simply duplicate the Space to create a private Space,\nand then use it to make as many requests as you'd like! \n\nThe `gradio_client` includes a class method: `Client.duplicate()` to make this process simple (you'll need to pass in your [Hugging Face token](https://huggingface.co/settings/tokens) or be logged in using the Hugging Face CLI):\n\n```python\nimport os\nfrom gradio_client import Client\n\nHF_TOKEN = os.environ.get(\"HF_TOKEN\")\n\nclient = Client.duplicate(\"abidlabs/whisper\", hf_token=HF_TOKEN) \nclient.predict(\"audio_sample.wav\")  \n\n>> \"This is a test of the whisper speech recognition model.\"\n```\n\nIf you have previously duplicated a Space, re-running `duplicate()` will *not* create a new Space. Instead, the Client will attach to the previously-created Space. So it is safe to re-run the `Client.duplicate()` method multiple times. \n\n**Note:** if the original Space uses GPUs, your private Space will as well, and your Hugging Face account will get billed based on the price of the GPU. To minimize charges, your Space will automatically go to sleep after 1 hour of inactivity. You can also set the hardware using the `hardware` parameter of `duplicate()`.\n\n\n## Connecting a general Gradio app\n\nIf your app is running somewhere else, just provide the full URL instead, including the \"http://\" or \"https://\". Here's an example of making predictions to a Gradio app that is running on a share URL:\n\n```python\nfrom gradio_client import Client\n\nclient = Client(\"https://bec81a83-5b5c-471e.gradio.live\")\n```\n\n## Inspecting the API endpoints\n\nOnce you have connected to a Gradio app, you can view the APIs that are available to you by calling the `Client.view_api()` method. For the Whisper Space, we see the following:\n\n```bash\nClient.predict() Usage Info\n---------------------------\nNamed API endpoints: 1\n\n - predict(input_audio, api_name=\"/predict\") -> value_0\n    Parameters:\n     - [Audio] input_audio: str (filepath or URL)\n    Returns:\n     - [Textbox] value_0: str (value)\n```\n\nThis shows us that we have 1 API endpoint in this space, and shows us how to use the API endpoint to make a prediction: we should call the `.predict()` method (which we will explore below), providing a parameter `input_audio` of type `str`, which is a `filepath or URL`. \n\nWe should also provide the `api_name='/predict'` argument to the `predict()` method. Although this isn't necessary if a Gradio app has only 1 named endpoint, it does allow us to call different endpoints in a single app if they are available. If an app has unnamed API endpoints, these can also be displayed by running `.view_api(all_endpoints=True)`.\n\n\n## Making a prediction\n\nThe simplest way to make a prediction is simply to call the `.predict()` function with the appropriate arguments:\n\n```python\nfrom gradio_client import Client\n\nclient = Client(\"abidlabs/en2fr\", api_name='/predict')\nclient.predict(\"Hello\")\n\n>> Bonjour\n```\n\nIf there are multiple parameters, then you should pass them as separate arguments to `.predict()`, like this:\n\n\n```python\nfrom gradio_client import Client\n\nclient = Client(\"gradio/calculator\")\nclient.predict(4, \"add\", 5)\n\n>> 9.0\n```\n\nFor certain inputs, such as images, you should pass in the filepath or URL to the file. Likewise, for the corresponding output types, you will get a filepath or URL returned. \n\n```python\nfrom gradio_client import Client\n\nclient = Client(\"abidlabs/whisper\")\nclient.predict(\"https://audio-samples.github.io/samples/mp3/blizzard_unconditional/sample-0.mp3\")\n\n>> \"My thought I have nobody by a beauty and will as you poured. Mr. Rochester is serve in that so don't find simpus, and devoted abode, to at might in a r\u2014\"\n```\n\n\n## Running jobs asynchronously\n\nOe should note that `.predict()` is a *blocking* operation as it waits for the operation to complete before returning the prediction. \n\nIn many cases, you may be better off letting the job run in the background until you need the results of the prediction. You can do this by creating a `Job` instance using the `.submit()` method, and then later calling `.result()` on the job to get the result. For example:\n\n```python\nfrom gradio_client import Client\n\nclient = Client(space=\"abidlabs/en2fr\")\njob = client.submit(\"Hello\", api_name=\"/predict\")  # This is not blocking\n\n# Do something else\n\njob.result()  # This is blocking\n\n>> Bonjour\n```\n\n## Adding callbacks\n\nAlternatively, one can add one or more callbacks to perform actions after the job has completed running, like this:\n\n```python\nfrom gradio_client import Client\n\ndef print_result(x):\n    print(\"The translated result is: {x}\")\n\nclient = Client(space=\"abidlabs/en2fr\")\n\njob = client.submit(\"Hello\", api_name=\"/predict\", result_callbacks=[print_result])\n\n# Do something else\n\n>> The translated result is: Bonjour\n\n```\n\n## Status\n\nThe `Job` object also allows you to get the status of the running job by calling the `.status()` method. This returns a `StatusUpdate` object with the following attributes: `code` (the status code, one of a set of defined strings representing the status. See the `utils.Status` class), `rank` (the current position of this job in the queue), `queue_size` (the total queue size),  `eta` (estimated time this job will complete), `success` (a boolean representing whether the job completed successfully), and `time` (the time that the status was generated). \n\n```py\nfrom gradio_client import Client\n\nclient = Client(src=\"gradio/calculator\")\njob = client.submit(5, \"add\", 4, api_name=\"/predict\")\njob.status()\n\n>> <Status.STARTING: 'STARTING'>\n```\n\n*Note*: The `Job` class also has a `.done()` instance method which returns a boolean indicating whether the job has completed.\n\n## Cancelling Jobs\n\nThe `Job` class also has a `.cancel()` instance method that cancels jobs that have been queued but not started. For example, if you run:\n\n```py\nclient = Client(\"abidlabs/whisper\") \njob1 = client.submit(\"audio_sample1.wav\")  \njob2 = client.submit(\"audio_sample2.wav\")  \njob1.cancel()  # will return False, assuming the job has started\njob2.cancel()  # will return True, indicating that the job has been canceled\n```\n\nIf the first job has started processing, then it will not be canceled. If the second job\nhas not yet started, it will be successfully canceled and removed from the queue. \n\n\n## Generator Endpoints\n\nSome Gradio API endpoints do not return a single value, rather they return a series of values. You can get the series of values that have been returned at any time from such a generator endpoint by running `job.outputs()`:\n\n```py\nfrom gradio_client import Client\n\nclient = Client(src=\"gradio/count_generator\")\njob = client.submit(3, api_name=\"/count\")\nwhile not job.done():\n    time.sleep(0.1)\njob.outputs()\n\n>> ['0', '1', '2']\n```\n\nNote that running `job.result()` on a generator endpoint only gives you the *first* value returned by the endpoint. \n\nThe `Job` object is also iterable, which means you can use it to display the results of a generator function as they are returned from the endpoint. Here's the equivalent example using the `Job` as a generator:\n\n```py\nfrom gradio_client import Client\n\nclient = Client(src=\"gradio/count_generator\")\njob = client.submit(3, api_name=\"/count\")\n\nfor o in job:\n    print(o)\n\n>> 0\n>> 1\n>> 2\n```\n\nYou can also cancel jobs that that have iterative outputs, in which case the job will finish as soon as the current iteration finishes running.\n\n```py\nfrom gradio_client import Client\nimport time\n\nclient = Client(\"abidlabs/test-yield\")\njob = client.submit(\"abcdef\")\ntime.sleep(3)\njob.cancel()  # job cancels after 2 iterations\n```", "html": "<h1 id=\"getting-started-with-the-gradio-python-client\">Getting Started with the Gradio Python client</h1>\n\n<p>The Gradio Python client makes it very easy to use any Gradio app as an API. As an example, consider this <a rel=\"noopener\" target=\"_blank\" href=\"https://huggingface.co/spaces/abidlabs/whisper\">Hugging Face Space that transcribes audio files</a> that are recorded from the microphone.</p>\n\n<p><img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/gradio-guides/whisper-screenshot.jpg\" alt=\"\" /></p>\n\n<p>Using the <code>gradio_client</code> library, we can easily use the Gradio as an API to transcribe audio files programmatically.</p>\n\n<p>Here's the entire code to do it:</p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(\"abidlabs/whisper\") \nclient.predict(\"audio_sample.wav\")  \n\n>> \"This is a test of the whisper speech recognition model.\"\n</code></pre></div>\n\n<p>The Gradio client works with any hosted Gradio app, whether it be an image generator, a text summarizer, a stateful chatbot, a tax calculator, or anything else! The Gradio Client is mostly used with apps hosted on <a rel=\"noopener\" target=\"_blank\" href=\"https://hf.space\">Hugging Face Spaces</a>, but your app can be hosted anywhere, such as your own server.</p>\n\n<p><strong>Prerequisites</strong>: To use the Gradio client, you do <em>not</em> need to know the <code>gradio</code> library in great detail. However, it is helpful to have general familiarity with Gradio's concepts of input and output components.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>If you already have a recent version of <code>gradio</code>, then the <code>gradio_client</code> is included as a dependency. </p>\n\n<p>Otherwise, the lightweight <code>gradio_client</code> package can be installed from pip (or pip3) and is tested to work with Python versions 3.9 or higher:</p>\n\n<div class='codeblock'><pre><code class='lang-bash'>$ pip install gradio_client\n</code></pre></div>\n\n<h2 id=\"connecting-to-a-running-gradio-app\">Connecting to a running Gradio App</h2>\n\n<p>Start by connecting instantiating a <code>Client</code> object and connecting it to a Gradio app that is running on Hugging Face Spaces or generally anywhere on the web.</p>\n\n<h2 id=\"connecting-to-a-hugging-face-space\">Connecting to a Hugging Face Space</h2>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(\"abidlabs/en2fr\")  # a Space that translates from English to French\n</code></pre></div>\n\n<p>You can also connect to private Spaces by passing in your HF token with the <code>hf_token</code> parameter. You can get your HF token here: https://huggingface.co/settings/tokens</p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(\"abidlabs/my-private-space\", hf_token=\"...\") \n</code></pre></div>\n\n<h2 id=\"duplicating-a-space-for-private-use\">Duplicating a Space for private use</h2>\n\n<p>While you can use any public Space as an API, you may get rate limited by Hugging Face if you make too many requests. For unlimited usage of a Space, simply duplicate the Space to create a private Space,\nand then use it to make as many requests as you'd like! </p>\n\n<p>The <code>gradio_client</code> includes a class method: <code>Client.duplicate()</code> to make this process simple (you'll need to pass in your <a rel=\"noopener\" target=\"_blank\" href=\"https://huggingface.co/settings/tokens\">Hugging Face token</a> or be logged in using the Hugging Face CLI):</p>\n\n<div class='codeblock'><pre><code class='lang-python'>import os\nfrom gradio_client import Client\n\nHF_TOKEN = os.environ.get(\"HF_TOKEN\")\n\nclient = Client.duplicate(\"abidlabs/whisper\", hf_token=HF_TOKEN) \nclient.predict(\"audio_sample.wav\")  \n\n>> \"This is a test of the whisper speech recognition model.\"\n</code></pre></div>\n\n<p>If you have previously duplicated a Space, re-running <code>duplicate()</code> will <em>not</em> create a new Space. Instead, the Client will attach to the previously-created Space. So it is safe to re-run the <code>Client.duplicate()</code> method multiple times. </p>\n\n<p><strong>Note:</strong> if the original Space uses GPUs, your private Space will as well, and your Hugging Face account will get billed based on the price of the GPU. To minimize charges, your Space will automatically go to sleep after 1 hour of inactivity. You can also set the hardware using the <code>hardware</code> parameter of <code>duplicate()</code>.</p>\n\n<h2 id=\"connecting-a-general-gradio-app\">Connecting a general Gradio app</h2>\n\n<p>If your app is running somewhere else, just provide the full URL instead, including the \"http://\" or \"https://\". Here's an example of making predictions to a Gradio app that is running on a share URL:</p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(\"https://bec81a83-5b5c-471e.gradio.live\")\n</code></pre></div>\n\n<h2 id=\"inspecting-the-api-endpoints\">Inspecting the API endpoints</h2>\n\n<p>Once you have connected to a Gradio app, you can view the APIs that are available to you by calling the <code>Client.view_api()</code> method. For the Whisper Space, we see the following:</p>\n\n<div class='codeblock'><pre><code class='lang-bash'>Client.predict() Usage Info\n---------------------------\nNamed API endpoints: 1\n\n - predict(input_audio, api_name=\"/predict\") -> value_0\n    Parameters:\n     - [Audio] input_audio: str (filepath or URL)\n    Returns:\n     - [Textbox] value_0: str (value)\n</code></pre></div>\n\n<p>This shows us that we have 1 API endpoint in this space, and shows us how to use the API endpoint to make a prediction: we should call the <code>.predict()</code> method (which we will explore below), providing a parameter <code>input_audio</code> of type <code>str</code>, which is a <code>filepath or URL</code>. </p>\n\n<p>We should also provide the <code>api_name='/predict'</code> argument to the <code>predict()</code> method. Although this isn't necessary if a Gradio app has only 1 named endpoint, it does allow us to call different endpoints in a single app if they are available. If an app has unnamed API endpoints, these can also be displayed by running <code>.view_api(all_endpoints=True)</code>.</p>\n\n<h2 id=\"making-a-prediction\">Making a prediction</h2>\n\n<p>The simplest way to make a prediction is simply to call the <code>.predict()</code> function with the appropriate arguments:</p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(\"abidlabs/en2fr\", api_name='/predict')\nclient.predict(\"Hello\")\n\n>> Bonjour\n</code></pre></div>\n\n<p>If there are multiple parameters, then you should pass them as separate arguments to <code>.predict()</code>, like this:</p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(\"gradio/calculator\")\nclient.predict(4, \"add\", 5)\n\n>> 9.0\n</code></pre></div>\n\n<p>For certain inputs, such as images, you should pass in the filepath or URL to the file. Likewise, for the corresponding output types, you will get a filepath or URL returned. </p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(\"abidlabs/whisper\")\nclient.predict(\"https://audio-samples.github.io/samples/mp3/blizzard_unconditional/sample-0.mp3\")\n\n>> \"My thought I have nobody by a beauty and will as you poured. Mr. Rochester is serve in that so don't find simpus, and devoted abode, to at might in a r\u2014\"\n</code></pre></div>\n\n<h2 id=\"running-jobs-asynchronously\">Running jobs asynchronously</h2>\n\n<p>Oe should note that <code>.predict()</code> is a <em>blocking</em> operation as it waits for the operation to complete before returning the prediction. </p>\n\n<p>In many cases, you may be better off letting the job run in the background until you need the results of the prediction. You can do this by creating a <code>Job</code> instance using the <code>.submit()</code> method, and then later calling <code>.result()</code> on the job to get the result. For example:</p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\nclient = Client(space=\"abidlabs/en2fr\")\njob = client.submit(\"Hello\", api_name=\"/predict\")  # This is not blocking\n\n# Do something else\n\njob.result()  # This is blocking\n\n>> Bonjour\n</code></pre></div>\n\n<h2 id=\"adding-callbacks\">Adding callbacks</h2>\n\n<p>Alternatively, one can add one or more callbacks to perform actions after the job has completed running, like this:</p>\n\n<div class='codeblock'><pre><code class='lang-python'>from gradio_client import Client\n\ndef print_result(x):\n    print(\"The translated result is: {x}\")\n\nclient = Client(space=\"abidlabs/en2fr\")\n\njob = client.submit(\"Hello\", api_name=\"/predict\", result_callbacks=[print_result])\n\n# Do something else\n\n>> The translated result is: Bonjour\n\n</code></pre></div>\n\n<h2 id=\"status\">Status</h2>\n\n<p>The <code>Job</code> object also allows you to get the status of the running job by calling the <code>.status()</code> method. This returns a <code>StatusUpdate</code> object with the following attributes: <code>code</code> (the status code, one of a set of defined strings representing the status. See the <code>utils.Status</code> class), <code>rank</code> (the current position of this job in the queue), <code>queue_size</code> (the total queue size),  <code>eta</code> (estimated time this job will complete), <code>success</code> (a boolean representing whether the job completed successfully), and <code>time</code> (the time that the status was generated). </p>\n\n<div class='codeblock'><pre><code class='lang-py'>from gradio_client import Client\n\nclient = Client(src=\"gradio/calculator\")\njob = client.submit(5, \"add\", 4, api_name=\"/predict\")\njob.status()\n\n>> <Status.STARTING: 'STARTING'>\n</code></pre></div>\n\n<p><em>Note</em>: The <code>Job</code> class also has a <code>.done()</code> instance method which returns a boolean indicating whether the job has completed.</p>\n\n<h2 id=\"cancelling-jobs\">Cancelling Jobs</h2>\n\n<p>The <code>Job</code> class also has a <code>.cancel()</code> instance method that cancels jobs that have been queued but not started. For example, if you run:</p>\n\n<div class='codeblock'><pre><code class='lang-py'>client = Client(\"abidlabs/whisper\") \njob1 = client.submit(\"audio_sample1.wav\")  \njob2 = client.submit(\"audio_sample2.wav\")  \njob1.cancel()  # will return False, assuming the job has started\njob2.cancel()  # will return True, indicating that the job has been canceled\n</code></pre></div>\n\n<p>If the first job has started processing, then it will not be canceled. If the second job\nhas not yet started, it will be successfully canceled and removed from the queue. </p>\n\n<h2 id=\"generator-endpoints\">Generator Endpoints</h2>\n\n<p>Some Gradio API endpoints do not return a single value, rather they return a series of values. You can get the series of values that have been returned at any time from such a generator endpoint by running <code>job.outputs()</code>:</p>\n\n<div class='codeblock'><pre><code class='lang-py'>from gradio_client import Client\n\nclient = Client(src=\"gradio/count_generator\")\njob = client.submit(3, api_name=\"/count\")\nwhile not job.done():\n    time.sleep(0.1)\njob.outputs()\n\n>> ['0', '1', '2']\n</code></pre></div>\n\n<p>Note that running <code>job.result()</code> on a generator endpoint only gives you the <em>first</em> value returned by the endpoint. </p>\n\n<p>The <code>Job</code> object is also iterable, which means you can use it to display the results of a generator function as they are returned from the endpoint. Here's the equivalent example using the <code>Job</code> as a generator:</p>\n\n<div class='codeblock'><pre><code class='lang-py'>from gradio_client import Client\n\nclient = Client(src=\"gradio/count_generator\")\njob = client.submit(3, api_name=\"/count\")\n\nfor o in job:\n    print(o)\n\n>> 0\n>> 1\n>> 2\n</code></pre></div>\n\n<p>You can also cancel jobs that that have iterative outputs, in which case the job will finish as soon as the current iteration finishes running.</p>\n\n<div class='codeblock'><pre><code class='lang-py'>from gradio_client import Client\nimport time\n\nclient = Client(\"abidlabs/test-yield\")\njob = client.submit(\"abcdef\")\ntime.sleep(3)\njob.cancel()  # job cancels after 2 iterations\n</code></pre></div>\n", "tags": ["CLIENT", "API", "SPACES"], "spaces": [], "url": "/guides/getting-started-with-the-python-client/", "contributor": null}}