<script lang="ts">
    import {get_object} from "../../process_json.ts";
    import ParamTable from "$lib/components/ParamTable.svelte";
    import DemosSection from "$lib/components/DemosSection.svelte";
    import FunctionsSection from "$lib/components/FunctionsSection.svelte";
    import GuidesSection from "$lib/components/GuidesSection.svelte";
    import { style_formatted_text } from "$lib/text";

    let obj = get_object("render");
    let guides = [{url: "/guides/dynamic-apps-with-render-decorator/", pretty_name: "Dynamic Apps with the Render Decorator"}]
</script>

<!--- Title -->
# {obj.name}

<!--- Usage -->
```python
@gr.render(inputs=···)
def hello(···):
   ... 
```

<!--- Description -->
### Description

Use `render` when you need your app's interface to change while it's running.

With `render`, you can:
- Show or hide components
- Change text or layout
- Create components based on what users enter

How it works:  
The function you decorate with `render` runs again each time its input values change, which updates the interface.

The full API reference is shown below.

## {@html style_formatted_text(obj.description)}

<!-- Example Usage --> 

{#if obj.example}
### Example
```python
import gradio as gr

with gr.Blocks() as demo:
    textbox = gr.Textbox(label="Enter text")

    @gr.render(inputs=textbox)
    def show_message(text):
        if not text:
            gr.Markdown("Please enter some text.")
        else:
            gr.Markdown(f"You entered: {text}")

demo.launch()
```
{/if}

<!--- Initialization -->
### Initialization
<ParamTable parameters={obj.parameters} anchor_links={obj.name}/>


{#if obj.demos && obj.demos.length > 0}
<!--- Demos -->
### Demos 
<DemosSection demos={obj.demos} />
{/if}

{#if obj.fns && obj.fns.length > 0}
<!--- Methods -->
### Methods 
<FunctionsSection fns={obj.fns} event_listeners={false} />
{/if}

<!--- Guides -->
<!--- the guide section below is still necessary to scrape the guides on the side navigation -->
<GuidesSection guides={guides}/>