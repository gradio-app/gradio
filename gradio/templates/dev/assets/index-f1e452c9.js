import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, ensure_array_like_dev, element, space, attr_dev, toggle_class, add_location, insert_dev, append_dev, noop, detach_dev, listen_dev, is_function, prevent_default, run_all, text, set_data_dev, empty, destroy_each, createEventDispatcher, globals, transition_in, group_outros, transition_out, check_outros, subscribe, binding_callbacks, create_component, mount_component, destroy_component, onDestroy, bubble, bind, src_url_equal, action_destroyer, add_flush_callback, create_slot, update_slot_base, get_all_dirty_from_scope, get_slot_changes, flush, assign, get_spread_update, get_spread_object } from './svelte/svelte-internal.js';
import { a as Button, B as Block, n as normalise_file } from './Button-153ea7e7.js';
import { s as spring, _ as __vitePreload, S as Static } from './index-30423ace.js';
import { U as UploadText } from './UploadText-5bbd5d92.js';
import { U as Upload } from './Upload-3fd97bb0.js';
import { M as ModifyUpload } from './ModifyUpload-aa8b58d9.js';
import { B as BlockLabel } from './BlockLabel-6e86bddb.js';
import { M as Music, l as loaded } from './utils-8600432e.js';
import './IconButton-a7cec4e3.js';
import './Undo-863e44da.js';

const RangePips_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangePips.svelte generated by Svelte v4.0.0 */

const file$2 = "Users/peterallen/Projects/gradio/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangePips.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	child_ctx[29] = i;
	return child_ctx;
}

// (174:2) {#if ( all && first !== false ) || first }
function create_if_block_9(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') && create_if_block_10(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block) if_block.c();
			attr_dev(span, "class", "pip first");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*min*/ ctx[0]));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*min*/ ctx[0]));
			add_location(span, file$2, 174, 4, 4340);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen_dev(
						span,
						"click",
						function () {
							if (is_function(/*labelClick*/ ctx[20](/*min*/ ctx[0]))) /*labelClick*/ ctx[20](/*min*/ ctx[0]).apply(this, arguments);
						},
						false,
						false,
						false,
						false
					),
					listen_dev(
						span,
						"touchend",
						prevent_default(function () {
							if (is_function(/*labelClick*/ ctx[20](/*min*/ ctx[0]))) /*labelClick*/ ctx[20](/*min*/ ctx[0]).apply(this, arguments);
						}),
						false,
						true,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"))) {
				attr_dev(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, min*/ 131073) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*min*/ ctx[0]));
			}

			if (dirty & /*inRange, min*/ 65537) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*min*/ ctx[0]));
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(174:2) {#if ( all && first !== false ) || first }",
		ctx
	});

	return block;
}

// (183:6) {#if all === 'label' || first === 'label'}
function create_if_block_10(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*min*/ ctx[0], 0, 0) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_12(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_11(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "pipVal");
			add_location(span, file$2, 183, 8, 4630);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, min*/ 4097 && t_value !== (t_value = /*formatter*/ ctx[12](/*min*/ ctx[0], 0, 0) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_11(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(183:6) {#if all === 'label' || first === 'label'}",
		ctx
	});

	return block;
}

// (185:10) {#if prefix}
function create_if_block_12(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr_dev(span, "class", "pipVal-prefix");
			add_location(span, file$2, 184, 22, 4674);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(185:10) {#if prefix}",
		ctx
	});

	return block;
}

// (185:90) {#if suffix}
function create_if_block_11(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr_dev(span, "class", "pipVal-suffix");
			add_location(span, file$2, 184, 102, 4754);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(185:90) {#if suffix}",
		ctx
	});

	return block;
}

// (191:2) {#if ( all && rest !== false ) || rest}
function create_if_block_4$2(ctx) {
	let each_1_anchor;
	let each_value = ensure_array_like_dev(Array(/*pipCount*/ ctx[19] + 1));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelClick, suffix, formatter, prefix, all, rest, min, max, pipCount*/ 2088515) {
				each_value = ensure_array_like_dev(Array(/*pipCount*/ ctx[19] + 1));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(191:2) {#if ( all && rest !== false ) || rest}",
		ctx
	});

	return block;
}

// (193:6) {#if pipVal(i) !== min && pipVal(i) !== max}
function create_if_block_5(ctx) {
	let span;
	let t;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') && create_if_block_6(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block) if_block.c();
			t = space();
			attr_dev(span, "class", "pip");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29])) + "%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			add_location(span, file$2, 193, 8, 4993);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block) if_block.m(span, null);
			append_dev(span, t);

			if (!mounted) {
				dispose = [
					listen_dev(
						span,
						"click",
						function () {
							if (is_function(/*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])))) /*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])).apply(this, arguments);
						},
						false,
						false,
						false,
						false
					),
					listen_dev(
						span,
						"touchend",
						prevent_default(function () {
							if (is_function(/*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])))) /*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])).apply(this, arguments);
						}),
						false,
						true,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart, percentOf, pipVal*/ 311296 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29])) + "%;"))) {
				attr_dev(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, pipVal*/ 393216) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			}

			if (dirty & /*inRange, pipVal*/ 327680) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(193:6) {#if pipVal(i) !== min && pipVal(i) !== max}",
		ctx
	});

	return block;
}

// (202:10) {#if all === 'label' || rest === 'label'}
function create_if_block_6(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[29]), /*i*/ ctx[29], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29]))) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_8(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_7(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "pipVal");
			add_location(span, file$2, 202, 12, 5357);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, pipVal, percentOf*/ 299008 && t_value !== (t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[29]), /*i*/ ctx[29], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29]))) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(202:10) {#if all === 'label' || rest === 'label'}",
		ctx
	});

	return block;
}

// (204:14) {#if prefix}
function create_if_block_8(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr_dev(span, "class", "pipVal-prefix");
			add_location(span, file$2, 203, 26, 5405);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(204:14) {#if prefix}",
		ctx
	});

	return block;
}

// (204:119) {#if suffix}
function create_if_block_7(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr_dev(span, "class", "pipVal-suffix");
			add_location(span, file$2, 203, 131, 5510);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(204:119) {#if suffix}",
		ctx
	});

	return block;
}

// (192:4) {#each Array(pipCount + 1) as _, i}
function create_each_block$1(ctx) {
	let show_if = /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*max*/ ctx[1];
	let if_block_anchor;
	let if_block = show_if && create_if_block_5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*pipVal, min, max*/ 262147) show_if = /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*max*/ ctx[1];

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(192:4) {#each Array(pipCount + 1) as _, i}",
		ctx
	});

	return block;
}

// (212:2) {#if ( all && last !== false ) || last}
function create_if_block$2(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block) if_block.c();
			attr_dev(span, "class", "pip last");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*max*/ ctx[1]));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*max*/ ctx[1]));
			add_location(span, file$2, 212, 4, 5690);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen_dev(
						span,
						"click",
						function () {
							if (is_function(/*labelClick*/ ctx[20](/*max*/ ctx[1]))) /*labelClick*/ ctx[20](/*max*/ ctx[1]).apply(this, arguments);
						},
						false,
						false,
						false,
						false
					),
					listen_dev(
						span,
						"touchend",
						prevent_default(function () {
							if (is_function(/*labelClick*/ ctx[20](/*max*/ ctx[1]))) /*labelClick*/ ctx[20](/*max*/ ctx[1]).apply(this, arguments);
						}),
						false,
						true,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"))) {
				attr_dev(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, max*/ 131074) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*max*/ ctx[1]));
			}

			if (dirty & /*inRange, max*/ 65538) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*max*/ ctx[1]));
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(212:2) {#if ( all && last !== false ) || last}",
		ctx
	});

	return block;
}

// (221:6) {#if all === 'label' || last === 'label'}
function create_if_block_1$2(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*max*/ ctx[1], /*pipCount*/ ctx[19], 100) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_3$2(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_2$2(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "pipVal");
			add_location(span, file$2, 221, 8, 5980);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, max, pipCount*/ 528386 && t_value !== (t_value = /*formatter*/ ctx[12](/*max*/ ctx[1], /*pipCount*/ ctx[19], 100) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(221:6) {#if all === 'label' || last === 'label'}",
		ctx
	});

	return block;
}

// (223:10) {#if prefix}
function create_if_block_3$2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr_dev(span, "class", "pipVal-prefix");
			add_location(span, file$2, 222, 22, 6024);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(223:10) {#if prefix}",
		ctx
	});

	return block;
}

// (223:99) {#if suffix}
function create_if_block_2$2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr_dev(span, "class", "pipVal-suffix");
			add_location(span, file$2, 222, 111, 6113);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(223:99) {#if suffix}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let t0;
	let t1;
	let if_block0 = (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) && create_if_block_9(ctx);
	let if_block1 = (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) && create_if_block_4$2(ctx);
	let if_block2 = (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			attr_dev(div, "class", "rangePips");
			toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			toggle_class(div, "focus", /*focus*/ ctx[13]);
			add_location(div, file$2, 165, 0, 4175);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$2(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$2(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*disabled*/ 32) {
				toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty & /*hoverable*/ 16) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			}

			if (dirty & /*vertical*/ 4) {
				toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			}

			if (dirty & /*reversed*/ 8) {
				toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			}

			if (dirty & /*focus*/ 8192) {
				toggle_class(div, "focus", /*focus*/ ctx[13]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let pipStep;
	let pipCount;
	let pipVal;
	let isSelected;
	let inRange;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RangePips', slots, []);
	let { range = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = true } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i) => v } = $$props;
	let { focus = undefined } = $$props;
	let { orientationStart = undefined } = $$props;
	let { percentOf = undefined } = $$props;
	let { moveHandle = undefined } = $$props;

	function labelClick(val) {
		moveHandle(undefined, val);
	}

	const writable_props = [
		'range',
		'min',
		'max',
		'step',
		'values',
		'vertical',
		'reversed',
		'hoverable',
		'disabled',
		'pipstep',
		'all',
		'first',
		'last',
		'rest',
		'prefix',
		'suffix',
		'formatter',
		'focus',
		'orientationStart',
		'percentOf',
		'moveHandle'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RangePips> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('range' in $$props) $$invalidate(21, range = $$props.range);
		if ('min' in $$props) $$invalidate(0, min = $$props.min);
		if ('max' in $$props) $$invalidate(1, max = $$props.max);
		if ('step' in $$props) $$invalidate(22, step = $$props.step);
		if ('values' in $$props) $$invalidate(23, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(2, vertical = $$props.vertical);
		if ('reversed' in $$props) $$invalidate(3, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('pipstep' in $$props) $$invalidate(24, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(6, all = $$props.all);
		if ('first' in $$props) $$invalidate(7, first = $$props.first);
		if ('last' in $$props) $$invalidate(8, last = $$props.last);
		if ('rest' in $$props) $$invalidate(9, rest = $$props.rest);
		if ('prefix' in $$props) $$invalidate(10, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(11, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(12, formatter = $$props.formatter);
		if ('focus' in $$props) $$invalidate(13, focus = $$props.focus);
		if ('orientationStart' in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
		if ('percentOf' in $$props) $$invalidate(15, percentOf = $$props.percentOf);
		if ('moveHandle' in $$props) $$invalidate(25, moveHandle = $$props.moveHandle);
	};

	$$self.$capture_state = () => ({
		range,
		min,
		max,
		step,
		values,
		vertical,
		reversed,
		hoverable,
		disabled,
		pipstep,
		all,
		first,
		last,
		rest,
		prefix,
		suffix,
		formatter,
		focus,
		orientationStart,
		percentOf,
		moveHandle,
		labelClick,
		inRange,
		isSelected,
		pipStep,
		pipVal,
		pipCount
	});

	$$self.$inject_state = $$props => {
		if ('range' in $$props) $$invalidate(21, range = $$props.range);
		if ('min' in $$props) $$invalidate(0, min = $$props.min);
		if ('max' in $$props) $$invalidate(1, max = $$props.max);
		if ('step' in $$props) $$invalidate(22, step = $$props.step);
		if ('values' in $$props) $$invalidate(23, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(2, vertical = $$props.vertical);
		if ('reversed' in $$props) $$invalidate(3, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('pipstep' in $$props) $$invalidate(24, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(6, all = $$props.all);
		if ('first' in $$props) $$invalidate(7, first = $$props.first);
		if ('last' in $$props) $$invalidate(8, last = $$props.last);
		if ('rest' in $$props) $$invalidate(9, rest = $$props.rest);
		if ('prefix' in $$props) $$invalidate(10, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(11, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(12, formatter = $$props.formatter);
		if ('focus' in $$props) $$invalidate(13, focus = $$props.focus);
		if ('orientationStart' in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
		if ('percentOf' in $$props) $$invalidate(15, percentOf = $$props.percentOf);
		if ('moveHandle' in $$props) $$invalidate(25, moveHandle = $$props.moveHandle);
		if ('inRange' in $$props) $$invalidate(16, inRange = $$props.inRange);
		if ('isSelected' in $$props) $$invalidate(17, isSelected = $$props.isSelected);
		if ('pipStep' in $$props) $$invalidate(26, pipStep = $$props.pipStep);
		if ('pipVal' in $$props) $$invalidate(18, pipVal = $$props.pipVal);
		if ('pipCount' in $$props) $$invalidate(19, pipCount = $$props.pipCount);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pipstep, max, min, step, vertical*/ 20971527) {
			$$invalidate(26, pipStep = pipstep || ((max - min) / step >= (vertical ? 50 : 100)
			? (max - min) / (vertical ? 10 : 20)
			: 1));
		}

		if ($$self.$$.dirty & /*max, min, step, pipStep*/ 71303171) {
			$$invalidate(19, pipCount = parseInt((max - min) / (step * pipStep), 10));
		}

		if ($$self.$$.dirty & /*min, step, pipStep*/ 71303169) {
			$$invalidate(18, pipVal = function (val) {
				return min + val * step * pipStep;
			});
		}

		if ($$self.$$.dirty & /*values*/ 8388608) {
			$$invalidate(17, isSelected = function (val) {
				return values.some(v => v === val);
			});
		}

		if ($$self.$$.dirty & /*range, values*/ 10485760) {
			$$invalidate(16, inRange = function (val) {
				if (range === "min") {
					return values[0] > val;
				} else if (range === "max") {
					return values[0] < val;
				} else if (range) {
					return values[0] < val && values[1] > val;
				}
			});
		}
	};

	return [
		min,
		max,
		vertical,
		reversed,
		hoverable,
		disabled,
		all,
		first,
		last,
		rest,
		prefix,
		suffix,
		formatter,
		focus,
		orientationStart,
		percentOf,
		inRange,
		isSelected,
		pipVal,
		pipCount,
		labelClick,
		range,
		step,
		values,
		pipstep,
		moveHandle,
		pipStep
	];
}

class RangePips extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			range: 21,
			min: 0,
			max: 1,
			step: 22,
			values: 23,
			vertical: 2,
			reversed: 3,
			hoverable: 4,
			disabled: 5,
			pipstep: 24,
			all: 6,
			first: 7,
			last: 8,
			rest: 9,
			prefix: 10,
			suffix: 11,
			formatter: 12,
			focus: 13,
			orientationStart: 14,
			percentOf: 15,
			moveHandle: 25
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RangePips",
			options,
			id: create_fragment$3.name
		});
	}

	get range() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set range(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get values() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set values(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get reversed() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set reversed(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoverable() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hoverable(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pipstep() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pipstep(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get all() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set all(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get first() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set first(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get last() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set last(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rest() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rest(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get prefix() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set prefix(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get suffix() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set suffix(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formatter() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatter(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set focus(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orientationStart() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orientationStart(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get percentOf() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set percentOf(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get moveHandle() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set moveHandle(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const RangeSlider_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangeSlider.svelte generated by Svelte v4.0.0 */

const { console: console_1 } = globals;
const file$1 = "Users/peterallen/Projects/gradio/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangeSlider.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[63] = list[i];
	child_ctx[65] = i;
	return child_ctx;
}

// (821:6) {#if float}
function create_if_block_2$1(ctx) {
	let span;
	let t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[18] && create_if_block_4$1(ctx);
	let if_block1 = /*suffix*/ ctx[19] && create_if_block_3$1(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "rangeFloat");
			add_location(span, file$1, 821, 8, 24398);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[18]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*handleFormatter, values, percentOf*/ 10485761 && t_value !== (t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[19]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$1(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(821:6) {#if float}",
		ctx
	});

	return block;
}

// (823:10) {#if prefix}
function create_if_block_4$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[18]);
			attr_dev(span, "class", "rangeFloat-prefix");
			add_location(span, file$1, 822, 22, 24446);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*prefix*/ 262144) set_data_dev(t, /*prefix*/ ctx[18]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(823:10) {#if prefix}",
		ctx
	});

	return block;
}

// (823:121) {#if suffix}
function create_if_block_3$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[19]);
			attr_dev(span, "class", "rangeFloat-suffix");
			add_location(span, file$1, 822, 133, 24557);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*suffix*/ 524288) set_data_dev(t, /*suffix*/ ctx[19]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(823:121) {#if suffix}",
		ctx
	});

	return block;
}

// (800:2) {#each values as value, index}
function create_each_block(ctx) {
	let span1;
	let span0;
	let t;
	let span1_style_value;
	let span1_aria_valuemin_value;
	let span1_aria_valuemax_value;
	let span1_aria_valuenow_value;
	let span1_aria_valuetext_value;
	let span1_aria_orientation_value;
	let span1_tabindex_value;
	let mounted;
	let dispose;
	let if_block = /*float*/ ctx[7] && create_if_block_2$1(ctx);

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = space();
			if (if_block) if_block.c();
			attr_dev(span0, "class", "rangeNub");
			add_location(span0, file$1, 819, 6, 24346);
			attr_dev(span1, "role", "slider");
			attr_dev(span1, "class", "rangeHandle");
			attr_dev(span1, "data-handle", /*index*/ ctx[65]);
			attr_dev(span1, "style", span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[65]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[65] ? 3 : 2) + ";"));

			attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3]);

			attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4]);

			attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value = /*value*/ ctx[63]);
			attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + /*suffix*/ ctx[19]));
			attr_dev(span1, "aria-orientation", span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal');
			attr_dev(span1, "aria-disabled", /*disabled*/ ctx[10]);
			attr_dev(span1, "disabled", /*disabled*/ ctx[10]);
			attr_dev(span1, "tabindex", span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0);
			toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			add_location(span1, file$1, 800, 4, 23533);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t);
			if (if_block) if_block.m(span1, null);

			if (!mounted) {
				dispose = [
					listen_dev(span1, "blur", /*sliderBlurHandle*/ ctx[33], false, false, false, false),
					listen_dev(span1, "focus", /*sliderFocusHandle*/ ctx[34], false, false, false, false),
					listen_dev(span1, "keydown", /*sliderKeydown*/ ctx[35], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*float*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					if_block.m(span1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*orientationStart, $springPositions, activeHandle*/ 872415232 && span1_style_value !== (span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[65]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[65] ? 3 : 2) + ";"))) {
				attr_dev(span1, "style", span1_style_value);
			}

			if (dirty[0] & /*range, values, min*/ 13 && span1_aria_valuemin_value !== (span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3])) {
				attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value);
			}

			if (dirty[0] & /*range, values, max*/ 21 && span1_aria_valuemax_value !== (span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4])) {
				attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value);
			}

			if (dirty[0] & /*values*/ 1 && span1_aria_valuenow_value !== (span1_aria_valuenow_value = /*value*/ ctx[63])) {
				attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value);
			}

			if (dirty[0] & /*prefix, handleFormatter, values, percentOf, suffix*/ 11272193 && span1_aria_valuetext_value !== (span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + /*suffix*/ ctx[19]))) {
				attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value);
			}

			if (dirty[0] & /*vertical*/ 64 && span1_aria_orientation_value !== (span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal')) {
				attr_dev(span1, "aria-orientation", span1_aria_orientation_value);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr_dev(span1, "aria-disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr_dev(span1, "disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024 && span1_tabindex_value !== (span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0)) {
				attr_dev(span1, "tabindex", span1_tabindex_value);
			}

			if (dirty[0] & /*focus, activeHandle*/ 83886080) {
				toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			}

			if (dirty[0] & /*handlePressed, activeHandle*/ 100663296) {
				toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span1);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(800:2) {#each values as value, index}",
		ctx
	});

	return block;
}

// (828:2) {#if range}
function create_if_block_1$1(ctx) {
	let span;
	let span_style_value;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "rangeBar");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[31](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[32](/*$springPositions*/ ctx[29]) + "%;"));
			add_location(span, file$1, 828, 4, 24678);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, orientationEnd*/ 939524096 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[31](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[32](/*$springPositions*/ ctx[29]) + "%;"))) {
				attr_dev(span, "style", span_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(828:2) {#if range}",
		ctx
	});

	return block;
}

// (834:2) {#if pips}
function create_if_block$1(ctx) {
	let rangepips;
	let current;

	rangepips = new RangePips({
			props: {
				values: /*values*/ ctx[0],
				min: /*min*/ ctx[3],
				max: /*max*/ ctx[4],
				step: /*step*/ ctx[5],
				range: /*range*/ ctx[2],
				vertical: /*vertical*/ ctx[6],
				reversed: /*reversed*/ ctx[8],
				orientationStart: /*orientationStart*/ ctx[28],
				hoverable: /*hoverable*/ ctx[9],
				disabled: /*disabled*/ ctx[10],
				all: /*all*/ ctx[13],
				first: /*first*/ ctx[14],
				last: /*last*/ ctx[15],
				rest: /*rest*/ ctx[16],
				pipstep: /*pipstep*/ ctx[12],
				prefix: /*prefix*/ ctx[18],
				suffix: /*suffix*/ ctx[19],
				formatter: /*formatter*/ ctx[20],
				focus: /*focus*/ ctx[24],
				percentOf: /*percentOf*/ ctx[23],
				moveHandle: /*moveHandle*/ ctx[30]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(rangepips.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(rangepips, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const rangepips_changes = {};
			if (dirty[0] & /*values*/ 1) rangepips_changes.values = /*values*/ ctx[0];
			if (dirty[0] & /*min*/ 8) rangepips_changes.min = /*min*/ ctx[3];
			if (dirty[0] & /*max*/ 16) rangepips_changes.max = /*max*/ ctx[4];
			if (dirty[0] & /*step*/ 32) rangepips_changes.step = /*step*/ ctx[5];
			if (dirty[0] & /*range*/ 4) rangepips_changes.range = /*range*/ ctx[2];
			if (dirty[0] & /*vertical*/ 64) rangepips_changes.vertical = /*vertical*/ ctx[6];
			if (dirty[0] & /*reversed*/ 256) rangepips_changes.reversed = /*reversed*/ ctx[8];
			if (dirty[0] & /*orientationStart*/ 268435456) rangepips_changes.orientationStart = /*orientationStart*/ ctx[28];
			if (dirty[0] & /*hoverable*/ 512) rangepips_changes.hoverable = /*hoverable*/ ctx[9];
			if (dirty[0] & /*disabled*/ 1024) rangepips_changes.disabled = /*disabled*/ ctx[10];
			if (dirty[0] & /*all*/ 8192) rangepips_changes.all = /*all*/ ctx[13];
			if (dirty[0] & /*first*/ 16384) rangepips_changes.first = /*first*/ ctx[14];
			if (dirty[0] & /*last*/ 32768) rangepips_changes.last = /*last*/ ctx[15];
			if (dirty[0] & /*rest*/ 65536) rangepips_changes.rest = /*rest*/ ctx[16];
			if (dirty[0] & /*pipstep*/ 4096) rangepips_changes.pipstep = /*pipstep*/ ctx[12];
			if (dirty[0] & /*prefix*/ 262144) rangepips_changes.prefix = /*prefix*/ ctx[18];
			if (dirty[0] & /*suffix*/ 524288) rangepips_changes.suffix = /*suffix*/ ctx[19];
			if (dirty[0] & /*formatter*/ 1048576) rangepips_changes.formatter = /*formatter*/ ctx[20];
			if (dirty[0] & /*focus*/ 16777216) rangepips_changes.focus = /*focus*/ ctx[24];
			if (dirty[0] & /*percentOf*/ 8388608) rangepips_changes.percentOf = /*percentOf*/ ctx[23];
			rangepips.$set(rangepips_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(rangepips.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(rangepips.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(rangepips, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(834:2) {#if pips}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let each_value = ensure_array_like_dev(/*values*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block0 = /*range*/ ctx[2] && create_if_block_1$1(ctx);
	let if_block1 = /*pips*/ ctx[11] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "id", /*id*/ ctx[17]);
			attr_dev(div, "class", "rangeSlider");
			toggle_class(div, "range", /*range*/ ctx[2]);
			toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			toggle_class(div, "focus", /*focus*/ ctx[24]);
			toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			toggle_class(div, "pips", /*pips*/ ctx[11]);
			toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
			add_location(div, file$1, 780, 0, 22999);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[49](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "mousedown", /*bodyInteractStart*/ ctx[38], false, false, false, false),
					listen_dev(window, "touchstart", /*bodyInteractStart*/ ctx[38], false, false, false, false),
					listen_dev(window, "mousemove", /*bodyInteract*/ ctx[39], false, false, false, false),
					listen_dev(window, "touchmove", /*bodyInteract*/ ctx[39], false, false, false, false),
					listen_dev(window, "mouseup", /*bodyMouseUp*/ ctx[40], false, false, false, false),
					listen_dev(window, "touchend", /*bodyTouchEnd*/ ctx[41], false, false, false, false),
					listen_dev(window, "keydown", /*bodyKeyDown*/ ctx[42], false, false, false, false),
					listen_dev(div, "mousedown", /*sliderInteractStart*/ ctx[36], false, false, false, false),
					listen_dev(div, "mouseup", /*sliderInteractEnd*/ ctx[37], false, false, false, false),
					listen_dev(div, "touchstart", prevent_default(/*sliderInteractStart*/ ctx[36]), false, true, false, false),
					listen_dev(div, "touchend", prevent_default(/*sliderInteractEnd*/ ctx[37]), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, activeHandle, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/ 934020317 | dirty[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/ 28) {
				each_value = ensure_array_like_dev(/*values*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*range*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*pips*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*pips*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*id*/ 131072) {
				attr_dev(div, "id", /*id*/ ctx[17]);
			}

			if (!current || dirty[0] & /*range*/ 4) {
				toggle_class(div, "range", /*range*/ ctx[2]);
			}

			if (!current || dirty[0] & /*disabled*/ 1024) {
				toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			}

			if (!current || dirty[0] & /*hoverable*/ 512) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			}

			if (!current || dirty[0] & /*vertical*/ 64) {
				toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			}

			if (!current || dirty[0] & /*reversed*/ 256) {
				toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			}

			if (!current || dirty[0] & /*focus*/ 16777216) {
				toggle_class(div, "focus", /*focus*/ ctx[24]);
			}

			if (!current || dirty[0] & /*range*/ 4) {
				toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			}

			if (!current || dirty[0] & /*range*/ 4) {
				toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			}

			if (!current || dirty[0] & /*pips*/ 2048) {
				toggle_class(div, "pips", /*pips*/ ctx[11]);
			}

			if (!current || dirty[0] & /*all, first, last, rest*/ 122880) {
				toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[49](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function index(el) {
	if (!el) return -1;
	var i = 0;

	while (el = el.previousElementSibling) {
		i++;
	}

	return i;
}

/**
 * normalise a mouse or touch event to return the
 * client (x/y) object for that event
 * @param {event} e a mouse/touch event to normalise
 * @returns {object} normalised event client object (x,y)
 **/
function normalisedClient(e) {
	if (e.type.includes("touch")) {
		return e.touches[0];
	} else {
		return e;
	}
}

function instance$2($$self, $$props, $$invalidate) {
	let percentOf;
	let clampValue;
	let alignValueToStep;
	let orientationStart;
	let orientationEnd;

	let $springPositions,
		$$unsubscribe_springPositions = noop,
		$$subscribe_springPositions = () => ($$unsubscribe_springPositions(), $$unsubscribe_springPositions = subscribe(springPositions, $$value => $$invalidate(29, $springPositions = $$value)), springPositions);

	$$self.$$.on_destroy.push(() => $$unsubscribe_springPositions());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RangeSlider', slots, []);
	let { slider } = $$props;
	let { range = false } = $$props;
	let { pushy = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { float = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pips = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = undefined } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { id = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i, p) => v } = $$props;
	let { handleFormatter = formatter } = $$props;
	let { precision = 2 } = $$props;
	let { springValues = { stiffness: 0.15, damping: 0.4 } } = $$props;

	// prepare dispatched events
	const dispatch = createEventDispatcher();

	// state management
	let valueLength = 0;

	let focus = false;
	let handleActivated = false;
	let handlePressed = false;
	let keyboardActive = false;
	let activeHandle = values.length - 1;
	let startValue;
	let previousValue;

	// copy the initial values in to a spring function which
	// will update every time the values array is modified
	let springPositions;

	/**
 * check if an element is a handle on the slider
 * @param {object} el dom object reference we want to check
 * @returns {boolean}
 **/
	function targetIsHandle(el) {
		const handles = slider.querySelectorAll(".handle");
		const isHandle = Array.prototype.includes.call(handles, el);
		const isChild = Array.prototype.some.call(handles, e => e.contains(el));
		return isHandle || isChild;
	}

	/**
 * trim the values array based on whether the property
 * for 'range' is 'min', 'max', or truthy. This is because we
 * do not want more than one handle for a min/max range, and we do
 * not want more than two handles for a true range.
 * @param {array} values the input values for the rangeSlider
 * @return {array} the range array for creating a rangeSlider
 **/
	function trimRange(values) {
		if (range === "min" || range === "max") {
			return values.slice(0, 1);
		} else if (range) {
			return values.slice(0, 2);
		} else {
			return values;
		}
	}

	/**
 * helper to return the slider dimensions for finding
 * the closest handle to user interaction
 * @return {object} the range slider DOM client rect
 **/
	function getSliderDimensions() {
		return slider.getBoundingClientRect();
	}

	/**
 * helper to return closest handle to user interaction
 * @param {object} clientPos the client{x,y} positions to check against
 * @return {number} the index of the closest handle to clientPos
 **/
	function getClosestHandle(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;
		let closest;

		// if we have a range, and the handles are at the same
		// position, we want a simple check if the interaction
		// value is greater than return the second handle
		if (range === true && values[0] === values[1]) {
			if (handleVal > values[1]) {
				return 1;
			} else {
				return 0;
			}
		} else // we sort the handles values, and return the first one closest
		// to the interaction value
		{
			closest = values.indexOf(
				[...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]
			);
		}

		return closest;
	}

	/**
 * take the interaction position on the slider, convert
 * it to a value on the range, and then send that value
 * through to the moveHandle() method to set the active
 * handle's position
 * @param {object} clientPos the client{x,y} of the interaction
 **/
	function handleInteract(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;

		// move handle to the value
		moveHandle(activeHandle, handleVal);
	}

	/**
 * move a handle to a specific value, respecting the clamp/align rules
 * @param {number} index the index of the handle we want to move
 * @param {number} value the value to move the handle to
 * @return {number} the value that was moved to (after alignment/clamping)
 **/
	function moveHandle(index, value) {
		// align & clamp the value so we're not doing extra
		// calculation on an out-of-range value down below
		value = alignValueToStep(value);

		// use the active handle if handle index is not provided
		if (typeof index === 'undefined') {
			index = activeHandle;
		}

		// if this is a range slider perform special checks
		if (range) {
			// restrict the handles of a range-slider from
			// going past one-another unless "pushy" is true
			if (index === 0 && value > values[1]) {
				if (pushy) {
					$$invalidate(0, values[1] = value, values);
				} else {
					value = values[1];
				}
			} else if (index === 1 && value < values[0]) {
				if (pushy) {
					$$invalidate(0, values[0] = value, values);
				} else {
					value = values[0];
				}
			}
		}

		// if the value has changed, update it
		if (values[index] !== value) {
			$$invalidate(0, values[index] = value, values);
		}

		// fire the change event when the handle moves,
		// and store the previous value for the next time
		if (previousValue !== value) {
			eChange();
			previousValue = value;
		}

		return value;
	}

	/**
 * helper to find the beginning range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the beginning of the range
 **/
	function rangeStart(values) {
		if (range === "min") {
			return 0;
		} else {
			return values[0];
		}
	}

	/**
 * helper to find the ending range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the end of the range
 **/
	function rangeEnd(values) {
		if (range === "max") {
			return 0;
		} else if (range === "min") {
			return 100 - values[0];
		} else {
			return 100 - values[1];
		}
	}

	/**
 * when the user has unfocussed (blurred) from the
 * slider, deactivate all handles
 * @param {event} e the event from browser
 **/
	function sliderBlurHandle(e) {
		if (keyboardActive) {
			$$invalidate(24, focus = false);
			handleActivated = false;
			$$invalidate(25, handlePressed = false);
		}
	}

	/**
 * when the user focusses the handle of a slider
 * set it to be active
 * @param {event} e the event from browser
 **/
	function sliderFocusHandle(e) {
		if (!disabled) {
			$$invalidate(26, activeHandle = index(e.target));
			$$invalidate(24, focus = true);
		}
	}

	/**
 * handle the keyboard accessible features by checking the
 * input type, and modfier key then moving handle by appropriate amount
 * @param {event} e the event from browser
 **/
	function sliderKeydown(e) {
		if (!disabled) {
			const handle = index(e.target);
			let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;
			let prevent = false;

			switch (e.key) {
				case "PageDown":
					jump *= 10;
				case "ArrowRight":
				case "ArrowUp":
					moveHandle(handle, values[handle] + jump);
					prevent = true;
					break;
				case "PageUp":
					jump *= 10;
				case "ArrowLeft":
				case "ArrowDown":
					moveHandle(handle, values[handle] - jump);
					prevent = true;
					break;
				case "Home":
					moveHandle(handle, min);
					prevent = true;
					break;
				case "End":
					moveHandle(handle, max);
					prevent = true;
					break;
			}

			if (prevent) {
				e.preventDefault();
				e.stopPropagation();
			}
		}
	}

	/**
 * function to run when the user touches
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractStart(e) {
		if (!disabled) {
			const el = e.target;
			const clientPos = normalisedClient(e);

			// set the closest handle as active
			$$invalidate(24, focus = true);

			handleActivated = true;
			$$invalidate(25, handlePressed = true);
			$$invalidate(26, activeHandle = getClosestHandle(clientPos));

			// fire the start event
			startValue = previousValue = alignValueToStep(values[activeHandle]);

			eStart();

			// for touch devices we want the handle to instantly
			// move to the position touched for more responsive feeling
			if (e.type === "touchstart" && !el.matches(".pipVal")) {
				handleInteract(clientPos);
			}
		}
	}

	/**
 * function to run when the user stops touching
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractEnd(e) {
		// fire the stop event for touch devices
		if (e.type === "touchend") {
			eStop();
		}

		$$invalidate(25, handlePressed = false);
	}

	/**
 * unfocus the slider if the user clicked off of
 * it, somewhere else on the screen
 * @param {event} e the event from browser
 **/
	function bodyInteractStart(e) {
		keyboardActive = false;

		if (focus && e.target !== slider && !slider.contains(e.target)) {
			$$invalidate(24, focus = false);
		}
	}

	/**
 * send the clientX through to handle the interaction
 * whenever the user moves acros screen while active
 * @param {event} e the event from browser
 **/
	function bodyInteract(e) {
		if (!disabled) {
			if (handleActivated) {
				handleInteract(normalisedClient(e));
			}
		}
	}

	/**
 * if user triggers mouseup on the body while
 * a handle is active (without moving) then we
 * trigger an interact event there
 * @param {event} e the event from browser
 **/
	function bodyMouseUp(e) {
		if (!disabled) {
			const el = e.target;

			// this only works if a handle is active, which can
			// only happen if there was sliderInteractStart triggered
			// on the slider, already
			if (handleActivated) {
				if (el === slider || slider.contains(el)) {
					$$invalidate(24, focus = true);

					// don't trigger interact if the target is a handle (no need) or
					// if the target is a label (we want to move to that value from rangePips)
					if (!targetIsHandle(el) && !el.matches(".pipVal")) {
						handleInteract(normalisedClient(e));
					}
				}

				// fire the stop event for mouse device
				// when the body is triggered with an active handle
				eStop();
			}
		}

		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	/**
 * if user triggers touchend on the body then we
 * defocus the slider completely
 * @param {event} e the event from browser
 **/
	function bodyTouchEnd(e) {
		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	function bodyKeyDown(e) {
		if (!disabled) {
			if (e.target === slider || slider.contains(e.target)) {
				keyboardActive = true;
			}
		}
	}

	function eStart() {
		!disabled && dispatch("start", {
			activeHandle,
			value: startValue,
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eStop() {
		!disabled && dispatch("stop", {
			activeHandle,
			startValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eChange() {
		!disabled && dispatch("change", {
			activeHandle,
			startValue,
			previousValue: typeof previousValue === "undefined"
			? startValue
			: previousValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	$$self.$$.on_mount.push(function () {
		if (slider === undefined && !('slider' in $$props || $$self.$$.bound[$$self.$$.props['slider']])) {
			console_1.warn("<RangeSlider> was created without expected prop 'slider'");
		}
	});

	const writable_props = [
		'slider',
		'range',
		'pushy',
		'min',
		'max',
		'step',
		'values',
		'vertical',
		'float',
		'reversed',
		'hoverable',
		'disabled',
		'pips',
		'pipstep',
		'all',
		'first',
		'last',
		'rest',
		'id',
		'prefix',
		'suffix',
		'formatter',
		'handleFormatter',
		'precision',
		'springValues'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<RangeSlider> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			slider = $$value;
			$$invalidate(1, slider);
		});
	}

	$$self.$$set = $$props => {
		if ('slider' in $$props) $$invalidate(1, slider = $$props.slider);
		if ('range' in $$props) $$invalidate(2, range = $$props.range);
		if ('pushy' in $$props) $$invalidate(43, pushy = $$props.pushy);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('values' in $$props) $$invalidate(0, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(6, vertical = $$props.vertical);
		if ('float' in $$props) $$invalidate(7, float = $$props.float);
		if ('reversed' in $$props) $$invalidate(8, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(9, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('pips' in $$props) $$invalidate(11, pips = $$props.pips);
		if ('pipstep' in $$props) $$invalidate(12, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(13, all = $$props.all);
		if ('first' in $$props) $$invalidate(14, first = $$props.first);
		if ('last' in $$props) $$invalidate(15, last = $$props.last);
		if ('rest' in $$props) $$invalidate(16, rest = $$props.rest);
		if ('id' in $$props) $$invalidate(17, id = $$props.id);
		if ('prefix' in $$props) $$invalidate(18, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(19, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(20, formatter = $$props.formatter);
		if ('handleFormatter' in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
		if ('precision' in $$props) $$invalidate(44, precision = $$props.precision);
		if ('springValues' in $$props) $$invalidate(45, springValues = $$props.springValues);
	};

	$$self.$capture_state = () => ({
		spring,
		createEventDispatcher,
		RangePips,
		slider,
		range,
		pushy,
		min,
		max,
		step,
		values,
		vertical,
		float,
		reversed,
		hoverable,
		disabled,
		pips,
		pipstep,
		all,
		first,
		last,
		rest,
		id,
		prefix,
		suffix,
		formatter,
		handleFormatter,
		precision,
		springValues,
		dispatch,
		valueLength,
		focus,
		handleActivated,
		handlePressed,
		keyboardActive,
		activeHandle,
		startValue,
		previousValue,
		springPositions,
		index,
		normalisedClient,
		targetIsHandle,
		trimRange,
		getSliderDimensions,
		getClosestHandle,
		handleInteract,
		moveHandle,
		rangeStart,
		rangeEnd,
		sliderBlurHandle,
		sliderFocusHandle,
		sliderKeydown,
		sliderInteractStart,
		sliderInteractEnd,
		bodyInteractStart,
		bodyInteract,
		bodyMouseUp,
		bodyTouchEnd,
		bodyKeyDown,
		eStart,
		eStop,
		eChange,
		alignValueToStep,
		orientationEnd,
		orientationStart,
		clampValue,
		percentOf,
		$springPositions
	});

	$$self.$inject_state = $$props => {
		if ('slider' in $$props) $$invalidate(1, slider = $$props.slider);
		if ('range' in $$props) $$invalidate(2, range = $$props.range);
		if ('pushy' in $$props) $$invalidate(43, pushy = $$props.pushy);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('values' in $$props) $$invalidate(0, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(6, vertical = $$props.vertical);
		if ('float' in $$props) $$invalidate(7, float = $$props.float);
		if ('reversed' in $$props) $$invalidate(8, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(9, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('pips' in $$props) $$invalidate(11, pips = $$props.pips);
		if ('pipstep' in $$props) $$invalidate(12, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(13, all = $$props.all);
		if ('first' in $$props) $$invalidate(14, first = $$props.first);
		if ('last' in $$props) $$invalidate(15, last = $$props.last);
		if ('rest' in $$props) $$invalidate(16, rest = $$props.rest);
		if ('id' in $$props) $$invalidate(17, id = $$props.id);
		if ('prefix' in $$props) $$invalidate(18, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(19, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(20, formatter = $$props.formatter);
		if ('handleFormatter' in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
		if ('precision' in $$props) $$invalidate(44, precision = $$props.precision);
		if ('springValues' in $$props) $$invalidate(45, springValues = $$props.springValues);
		if ('valueLength' in $$props) $$invalidate(46, valueLength = $$props.valueLength);
		if ('focus' in $$props) $$invalidate(24, focus = $$props.focus);
		if ('handleActivated' in $$props) handleActivated = $$props.handleActivated;
		if ('handlePressed' in $$props) $$invalidate(25, handlePressed = $$props.handlePressed);
		if ('keyboardActive' in $$props) keyboardActive = $$props.keyboardActive;
		if ('activeHandle' in $$props) $$invalidate(26, activeHandle = $$props.activeHandle);
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('previousValue' in $$props) previousValue = $$props.previousValue;
		if ('springPositions' in $$props) $$subscribe_springPositions($$invalidate(22, springPositions = $$props.springPositions));
		if ('alignValueToStep' in $$props) $$invalidate(47, alignValueToStep = $$props.alignValueToStep);
		if ('orientationEnd' in $$props) $$invalidate(27, orientationEnd = $$props.orientationEnd);
		if ('orientationStart' in $$props) $$invalidate(28, orientationStart = $$props.orientationStart);
		if ('clampValue' in $$props) $$invalidate(48, clampValue = $$props.clampValue);
		if ('percentOf' in $$props) $$invalidate(23, percentOf = $$props.percentOf);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*min, max*/ 24) {
			/**
 * clamp a value from the range so that it always
 * falls within the min/max values
 * @param {number} val the value to clamp
 * @return {number} the value after it's been clamped
 **/
			$$invalidate(48, clampValue = function (val) {
				// return the min/max if outside of that range
				return val <= min ? min : val >= max ? max : val;
			});
		}

		if ($$self.$$.dirty[0] & /*min, max, step*/ 56 | $$self.$$.dirty[1] & /*clampValue, precision*/ 139264) {
			/**
 * align the value with the steps so that it
 * always sits on the closest (above/below) step
 * @param {number} val the value to align
 * @return {number} the value after it's been aligned
 **/
			$$invalidate(47, alignValueToStep = function (val) {
				// sanity check for performance
				if (val <= min) {
					return min;
				} else if (val >= max) {
					return max;
				}

				// find the middle-point between steps
				// and see if the value is closer to the
				// next step, or previous step
				let remainder = (val - min) % step;

				let aligned = val - remainder;

				if (Math.abs(remainder) * 2 >= step) {
					aligned += remainder > 0 ? step : -step;
				}

				// make sure the value is within acceptable limits
				aligned = clampValue(aligned);

				// make sure the returned value is set to the precision desired
				// this is also because javascript often returns weird floats
				// when dealing with odd numbers and percentages
				return parseFloat(aligned.toFixed(precision));
			});
		}

		if ($$self.$$.dirty[0] & /*min, max*/ 24 | $$self.$$.dirty[1] & /*precision*/ 8192) {
			/**
 * take in a value, and then calculate that value's percentage
 * of the overall range (min-max);
 * @param {number} val the value we're getting percent for
 * @return {number} the percentage value
 **/
			$$invalidate(23, percentOf = function (val) {
				let perc = (val - min) / (max - min) * 100;

				if (isNaN(perc) || perc <= 0) {
					return 0;
				} else if (perc >= 100) {
					return 100;
				} else {
					return parseFloat(perc.toFixed(precision));
				}
			});
		}

		if ($$self.$$.dirty[0] & /*values, max, min, percentOf, springPositions*/ 12582937 | $$self.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/ 114688) {
			{
				// check that "values" is an array, or set it as array
				// to prevent any errors in springs, or range trimming
				if (!Array.isArray(values)) {
					$$invalidate(0, values = [(max + min) / 2]);
					console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
				}

				// trim the range so it remains as a min/max (only 2 handles)
				// and also align the handles to the steps
				$$invalidate(0, values = trimRange(values.map(v => alignValueToStep(v))));

				// check if the valueLength (length of values[]) has changed,
				// because if so we need to re-seed the spring function with the
				// new values array.
				if (valueLength !== values.length) {
					// set the initial spring values when the slider initialises,
					// or when values array length has changed
					$$subscribe_springPositions($$invalidate(22, springPositions = spring(values.map(v => percentOf(v)), springValues)));
				} else {
					// update the value of the spring function for animated handles
					// whenever the values has updated
					springPositions.set(values.map(v => percentOf(v)));
				}

				// set the valueLength for the next check
				$$invalidate(46, valueLength = values.length);
			}
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			/**
 * the orientation of the handles/pips based on the
 * input values of vertical and reversed
 **/
			$$invalidate(28, orientationStart = vertical
			? reversed ? 'top' : 'bottom'
			: reversed ? 'right' : 'left');
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			$$invalidate(27, orientationEnd = vertical
			? reversed ? 'bottom' : 'top'
			: reversed ? 'left' : 'right');
		}
	};

	return [
		values,
		slider,
		range,
		min,
		max,
		step,
		vertical,
		float,
		reversed,
		hoverable,
		disabled,
		pips,
		pipstep,
		all,
		first,
		last,
		rest,
		id,
		prefix,
		suffix,
		formatter,
		handleFormatter,
		springPositions,
		percentOf,
		focus,
		handlePressed,
		activeHandle,
		orientationEnd,
		orientationStart,
		$springPositions,
		moveHandle,
		rangeStart,
		rangeEnd,
		sliderBlurHandle,
		sliderFocusHandle,
		sliderKeydown,
		sliderInteractStart,
		sliderInteractEnd,
		bodyInteractStart,
		bodyInteract,
		bodyMouseUp,
		bodyTouchEnd,
		bodyKeyDown,
		pushy,
		precision,
		springValues,
		valueLength,
		alignValueToStep,
		clampValue,
		div_binding
	];
}

class RangeSlider extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				slider: 1,
				range: 2,
				pushy: 43,
				min: 3,
				max: 4,
				step: 5,
				values: 0,
				vertical: 6,
				float: 7,
				reversed: 8,
				hoverable: 9,
				disabled: 10,
				pips: 11,
				pipstep: 12,
				all: 13,
				first: 14,
				last: 15,
				rest: 16,
				id: 17,
				prefix: 18,
				suffix: 19,
				formatter: 20,
				handleFormatter: 21,
				precision: 44,
				springValues: 45
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RangeSlider",
			options,
			id: create_fragment$2.name
		});
	}

	get slider() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slider(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get range() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set range(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pushy() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pushy(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get values() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set values(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get float() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set float(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get reversed() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set reversed(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoverable() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hoverable(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pips() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pips(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pipstep() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pipstep(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get all() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set all(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get first() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set first(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get last() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set last(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rest() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rest(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get prefix() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set prefix(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get suffix() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set suffix(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formatter() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatter(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleFormatter() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handleFormatter(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get precision() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set precision(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get springValues() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set springValues(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const Audio_svelte_svelte_type_style_lang = '';

const file = "Users/peterallen/Projects/gradio/js/audio/interactive/Audio.svelte";

// (217:0) {:else}
function create_else_block_1(ctx) {
	let modifyupload;
	let t0;
	let audio;
	let audio_src_value;
	let audio_data_testid_value;
	let loaded_action;
	let t1;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	modifyupload = new ModifyUpload({
			props: {
				i18n: /*i18n*/ ctx[9],
				editable: /*show_edit_button*/ ctx[8],
				absolute: true
			},
			$$inline: true
		});

	modifyupload.$on("clear", /*clear*/ ctx[16]);
	modifyupload.$on("edit", /*edit_handler*/ ctx[29]);
	let if_block = /*mode*/ ctx[11] === "edit" && /*player*/ ctx[12]?.duration && create_if_block_4(ctx);

	const block = {
		c: function create() {
			create_component(modifyupload.$$.fragment);
			t0 = space();
			audio = element("audio");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			audio.controls = true;
			attr_dev(audio, "preload", "metadata");
			if (!src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1]?.data)) attr_dev(audio, "src", audio_src_value);
			attr_dev(audio, "data-testid", audio_data_testid_value = `${/*label*/ ctx[2]}-audio`);
			attr_dev(audio, "class", "s-irYT52enqEIQ");
			add_location(audio, file, 294, 1, 6200);
		},
		m: function mount(target, anchor) {
			mount_component(modifyupload, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, audio, anchor);
			/*audio_binding*/ ctx[30](audio);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(loaded_action = loaded.call(null, audio, {
						autoplay: /*autoplay*/ ctx[7],
						crop_values: /*crop_values*/ ctx[13]
					})),
					listen_dev(audio, "play", /*play_handler*/ ctx[26], false, false, false, false),
					listen_dev(audio, "pause", /*pause_handler*/ ctx[27], false, false, false, false),
					listen_dev(audio, "ended", /*handle_ended*/ ctx[19], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 512) modifyupload_changes.i18n = /*i18n*/ ctx[9];
			if (dirty[0] & /*show_edit_button*/ 256) modifyupload_changes.editable = /*show_edit_button*/ ctx[8];
			modifyupload.$set(modifyupload_changes);

			if (!current || dirty[0] & /*value*/ 2 && !src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1]?.data)) {
				attr_dev(audio, "src", audio_src_value);
			}

			if (!current || dirty[0] & /*label*/ 4 && audio_data_testid_value !== (audio_data_testid_value = `${/*label*/ ctx[2]}-audio`)) {
				attr_dev(audio, "data-testid", audio_data_testid_value);
			}

			if (loaded_action && is_function(loaded_action.update) && dirty[0] & /*autoplay, crop_values*/ 8320) loaded_action.update.call(null, {
				autoplay: /*autoplay*/ ctx[7],
				crop_values: /*crop_values*/ ctx[13]
			});

			if (/*mode*/ ctx[11] === "edit" && /*player*/ ctx[12]?.duration) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*mode, player*/ 6144) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modifyupload.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(modifyupload.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(audio);
				detach_dev(t1);
				detach_dev(if_block_anchor);
			}

			destroy_component(modifyupload, detaching);
			/*audio_binding*/ ctx[30](null);
			if (if_block) if_block.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(217:0) {:else}",
		ctx
	});

	return block;
}

// (186:0) {#if value === null || streaming}
function create_if_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*source*/ ctx[5] === "microphone") return 0;
		if (/*source*/ ctx[5] === "upload") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(186:0) {#if value === null || streaming}",
		ctx
	});

	return block;
}

// (238:1) {#if mode === "edit" && player?.duration}
function create_if_block_4(ctx) {
	let range;
	let updating_values;
	let current;

	function range_values_binding(value) {
		/*range_values_binding*/ ctx[31](value);
	}

	let range_props = { range: true, min: 0, max: 100, step: 1 };

	if (/*crop_values*/ ctx[13] !== void 0) {
		range_props.values = /*crop_values*/ ctx[13];
	}

	range = new RangeSlider({ props: range_props, $$inline: true });
	binding_callbacks.push(() => bind(range, 'values', range_values_binding));
	range.$on("change", /*handle_change*/ ctx[17]);

	const block = {
		c: function create() {
			create_component(range.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const range_changes = {};

			if (!updating_values && dirty[0] & /*crop_values*/ 8192) {
				updating_values = true;
				range_changes.values = /*crop_values*/ ctx[13];
				add_flush_callback(() => updating_values = false);
			}

			range.$set(range_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(range, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(238:1) {#if mode === \\\"edit\\\" && player?.duration}",
		ctx
	});

	return block;
}

// (206:31) 
function create_if_block_3(ctx) {
	let upload;
	let updating_dragging;
	let current;

	function upload_dragging_binding(value) {
		/*upload_dragging_binding*/ ctx[28](value);
	}

	let upload_props = {
		filetype: "audio/aac,audio/midi,audio/mpeg,audio/ogg,audio/wav,audio/x-wav,audio/opus,audio/webm,audio/flac,audio/vnd.rn-realaudio,audio/x-ms-wma,audio/x-aiff,audio/amr,audio/*",
		root: /*root*/ ctx[3],
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	if (/*dragging*/ ctx[0] !== void 0) {
		upload_props.dragging = /*dragging*/ ctx[0];
	}

	upload = new Upload({ props: upload_props, $$inline: true });
	binding_callbacks.push(() => bind(upload, 'dragging', upload_dragging_binding));
	upload.$on("load", /*handle_load*/ ctx[18]);

	const block = {
		c: function create() {
			create_component(upload.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(upload, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const upload_changes = {};
			if (dirty[0] & /*root*/ 8) upload_changes.root = /*root*/ ctx[3];

			if (dirty[1] & /*$$scope*/ 2) {
				upload_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 1) {
				updating_dragging = true;
				upload_changes.dragging = /*dragging*/ ctx[0];
				add_flush_callback(() => updating_dragging = false);
			}

			upload.$set(upload_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(upload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(upload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(upload, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(206:31) ",
		ctx
	});

	return block;
}

// (187:1) {#if source === "microphone"}
function create_if_block_1(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*recording*/ ctx[10]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "class", "mic-wrap s-irYT52enqEIQ");
			add_location(div, file, 256, 2, 5215);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(187:1) {#if source === \\\"microphone\\\"}",
		ctx
	});

	return block;
}

// (208:2) <Upload    filetype="audio/aac,audio/midi,audio/mpeg,audio/ogg,audio/wav,audio/x-wav,audio/opus,audio/webm,audio/flac,audio/vnd.rn-realaudio,audio/x-ms-wma,audio/x-aiff,audio/amr,audio/*"    on:load={handle_load}    bind:dragging    {root}   >
function create_default_slot_2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[25].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[32], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(208:2) <Upload    filetype=\\\"audio/aac,audio/midi,audio/mpeg,audio/ogg,audio/wav,audio/x-wav,audio/opus,audio/webm,audio/flac,audio/vnd.rn-realaudio,audio/x-ms-wma,audio/x-aiff,audio/amr,audio/*\\\"    on:load={handle_load}    bind:dragging    {root}   >",
		ctx
	});

	return block;
}

// (197:3) {:else}
function create_else_block(ctx) {
	let basebutton;
	let current;

	basebutton = new Button({
			props: {
				size: "sm",
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	basebutton.$on("click", /*record*/ ctx[14]);

	const block = {
		c: function create() {
			create_component(basebutton.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(basebutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const basebutton_changes = {};

			if (dirty[0] & /*i18n*/ 512 | dirty[1] & /*$$scope*/ 2) {
				basebutton_changes.$$scope = { dirty, ctx };
			}

			basebutton.$set(basebutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(basebutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(basebutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(basebutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(197:3) {:else}",
		ctx
	});

	return block;
}

// (189:3) {#if recording}
function create_if_block_2(ctx) {
	let basebutton;
	let current;

	basebutton = new Button({
			props: {
				size: "sm",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	basebutton.$on("click", /*stop*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(basebutton.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(basebutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const basebutton_changes = {};

			if (dirty[0] & /*i18n*/ 512 | dirty[1] & /*$$scope*/ 2) {
				basebutton_changes.$$scope = { dirty, ctx };
			}

			basebutton.$set(basebutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(basebutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(basebutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(basebutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(189:3) {#if recording}",
		ctx
	});

	return block;
}

// (198:4) <BaseButton size="sm" on:click={record}>
function create_default_slot_1$1(ctx) {
	let span1;
	let span0;
	let t0;
	let t1_value = /*i18n*/ ctx[9]("audio.record_from_microphone") + "";
	let t1;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = space();
			t1 = text(t1_value);
			attr_dev(span0, "class", "dot s-irYT52enqEIQ");
			add_location(span0, file, 268, 6, 5550);
			attr_dev(span1, "class", "record-icon s-irYT52enqEIQ");
			add_location(span1, file, 267, 5, 5517);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*i18n*/ 512 && t1_value !== (t1_value = /*i18n*/ ctx[9]("audio.record_from_microphone") + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span1);
				detach_dev(t0);
				detach_dev(t1);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(198:4) <BaseButton size=\\\"sm\\\" on:click={record}>",
		ctx
	});

	return block;
}

// (190:4) <BaseButton size="sm" on:click={stop}>
function create_default_slot$1(ctx) {
	let span2;
	let span0;
	let t0;
	let span1;
	let t1;
	let t2_value = /*i18n*/ ctx[9]("audio.stop_recording") + "";
	let t2;

	const block = {
		c: function create() {
			span2 = element("span");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			t2 = text(t2_value);
			attr_dev(span0, "class", "pinger s-irYT52enqEIQ");
			add_location(span0, file, 260, 6, 5338);
			attr_dev(span1, "class", "dot s-irYT52enqEIQ");
			add_location(span1, file, 261, 6, 5368);
			attr_dev(span2, "class", "record-icon s-irYT52enqEIQ");
			add_location(span2, file, 259, 5, 5305);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span2, anchor);
			append_dev(span2, span0);
			append_dev(span2, t0);
			append_dev(span2, span1);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*i18n*/ 512 && t2_value !== (t2_value = /*i18n*/ ctx[9]("audio.stop_recording") + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span2);
				detach_dev(t1);
				detach_dev(t2);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(190:4) <BaseButton size=\\\"sm\\\" on:click={stop}>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let blocklabel;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[4],
				Icon: Music,
				float: /*source*/ ctx[5] === "upload" && /*value*/ ctx[1] === null,
				label: /*label*/ ctx[2] || /*i18n*/ ctx[9]("audio.audio")
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[1] === null || /*streaming*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(blocklabel.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(blocklabel, target, anchor);
			insert_dev(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 16) blocklabel_changes.show_label = /*show_label*/ ctx[4];
			if (dirty[0] & /*source, value*/ 34) blocklabel_changes.float = /*source*/ ctx[5] === "upload" && /*value*/ ctx[1] === null;
			if (dirty[0] & /*label, i18n*/ 516) blocklabel_changes.label = /*label*/ ctx[2] || /*i18n*/ ctx[9]("audio.audio");
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocklabel.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(if_block_anchor);
			}

			destroy_component(blocklabel, detaching);
			if_blocks[current_block_type_index].d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const STREAM_TIMESLICE = 500;
const NUM_HEADER_BYTES = 44;

function blob_to_data_url(blob) {
	return new Promise((fulfill, reject) => {
			let reader = new FileReader();
			reader.onerror = reject;
			reader.onload = () => fulfill(reader.result);
			reader.readAsDataURL(blob);
		});
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Audio', slots, ['default']);
	let { value = null } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { show_label = true } = $$props;
	let { name = "" } = $$props;
	let { source } = $$props;
	let { pending = false } = $$props;
	let { streaming = false } = $$props;
	let { autoplay = false } = $$props;
	let { show_edit_button = true } = $$props;
	let { i18n } = $$props;

	// TODO: make use of this
	// export let type: "normal" | "numpy" = "normal";
	let recording = false;

	let recorder;
	let mode = "";
	let header = undefined;
	let pending_stream = [];
	let submit_pending_stream_on_pending_end = false;
	let player;
	let inited = false;
	let crop_values = [0, 100];
	let audio_chunks = [];
	let module_promises;

	function get_modules() {
		module_promises = [
			__vitePreload(() => import('./module-a40c6965.js'),true?["./module-a40c6965.js","./index-30423ace.js","./index-7d858894.css"]:void 0,import.meta.url),
			__vitePreload(() => import('./module-3a2ae03f.js'),true?[]:void 0,import.meta.url)
		];
	}

	if (streaming) {
		get_modules();
	}

	const dispatch = createEventDispatcher();

	const dispatch_blob = async (blobs, event) => {
		let _audio_blob = new Blob(blobs, { type: "audio/wav" });

		$$invalidate(1, value = {
			data: await blob_to_data_url(_audio_blob),
			name: "audio.wav"
		});

		const detail = { ...value, is_file: false };
		dispatch(event, detail);
	};

	async function prepare_audio() {
		let stream;

		try {
			stream = await navigator.mediaDevices.getUserMedia({ audio: true });
		} catch(err) {
			if (err instanceof DOMException && err.name == "NotAllowedError") {
				dispatch("error", i18n("audio.allow_recording_access"));
				return;
			}

			throw err;
		}

		if (stream == null) return;

		if (streaming) {
			const [{ MediaRecorder, register }, { connect }] = await Promise.all(module_promises);
			await register(await connect());
			recorder = new MediaRecorder(stream, { mimeType: "audio/wav" });
			recorder.addEventListener("dataavailable", handle_chunk);
		} else {
			recorder = new MediaRecorder(stream);

			recorder.addEventListener("dataavailable", event => {
				audio_chunks.push(event.data);
			});

			recorder.addEventListener("stop", async () => {
				$$invalidate(10, recording = false);
				await dispatch_blob(audio_chunks, "change");
				await dispatch_blob(audio_chunks, "stop_recording");
				audio_chunks = [];
			});
		}

		inited = true;
	}

	async function handle_chunk(event) {
		let buffer = await event.data.arrayBuffer();
		let payload = new Uint8Array(buffer);

		if (!header) {
			$$invalidate(22, header = new Uint8Array(buffer.slice(0, NUM_HEADER_BYTES)));
			payload = new Uint8Array(buffer.slice(NUM_HEADER_BYTES));
		}

		if (pending) {
			pending_stream.push(payload);
		} else {
			let blobParts = [header].concat(pending_stream, [payload]);
			dispatch_blob(blobParts, "stream");
			$$invalidate(23, pending_stream = []);
		}
	}

	async function record() {
		$$invalidate(10, recording = true);
		dispatch("start_recording");
		if (!inited) await prepare_audio();
		$$invalidate(22, header = undefined);

		if (streaming) {
			recorder.start(STREAM_TIMESLICE);
		} else {
			recorder.start();
		}
	}

	onDestroy(() => {
		if (recorder && recorder.state !== "inactive") {
			recorder.stop();
		}
	});

	function stop() {
		recorder.stop();

		if (streaming) {
			$$invalidate(10, recording = false);
			dispatch("stop_recording");

			if (pending) {
				$$invalidate(24, submit_pending_stream_on_pending_end = true);
			}
		}
	}

	function clear() {
		dispatch("change", null);
		dispatch("clear");
		$$invalidate(11, mode = "");
		$$invalidate(1, value = null);
	}

	function handle_change({ detail: { values } }) {
		if (!value) return;

		dispatch("change", {
			data: value.data,
			name,
			crop_min: values[0],
			crop_max: values[1]
		});

		dispatch("edit");
	}

	function handle_load({ detail }) {
		$$invalidate(1, value = detail);
		dispatch("change", detail);
		dispatch("upload", detail);
	}

	function handle_ended() {
		dispatch("stop");
		dispatch("end");
	}

	let { dragging = false } = $$props;

	$$self.$$.on_mount.push(function () {
		if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
			console.warn("<Audio> was created without expected prop 'label'");
		}

		if (root === undefined && !('root' in $$props || $$self.$$.bound[$$self.$$.props['root']])) {
			console.warn("<Audio> was created without expected prop 'root'");
		}

		if (source === undefined && !('source' in $$props || $$self.$$.bound[$$self.$$.props['source']])) {
			console.warn("<Audio> was created without expected prop 'source'");
		}

		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console.warn("<Audio> was created without expected prop 'i18n'");
		}
	});

	const writable_props = [
		'value',
		'label',
		'root',
		'show_label',
		'name',
		'source',
		'pending',
		'streaming',
		'autoplay',
		'show_edit_button',
		'i18n',
		'dragging'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Audio> was created with unknown prop '${key}'`);
	});

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function upload_dragging_binding(value) {
		dragging = value;
		$$invalidate(0, dragging);
	}

	const edit_handler = () => $$invalidate(11, mode = "edit");

	function audio_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			player = $$value;
			$$invalidate(12, player);
		});
	}

	function range_values_binding(value) {
		crop_values = value;
		$$invalidate(13, crop_values);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('root' in $$props) $$invalidate(3, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(4, show_label = $$props.show_label);
		if ('name' in $$props) $$invalidate(20, name = $$props.name);
		if ('source' in $$props) $$invalidate(5, source = $$props.source);
		if ('pending' in $$props) $$invalidate(21, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(6, streaming = $$props.streaming);
		if ('autoplay' in $$props) $$invalidate(7, autoplay = $$props.autoplay);
		if ('show_edit_button' in $$props) $$invalidate(8, show_edit_button = $$props.show_edit_button);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('$$scope' in $$props) $$invalidate(32, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		BaseButton: Button,
		onDestroy,
		createEventDispatcher,
		Upload,
		ModifyUpload,
		BlockLabel,
		Music,
		Range: RangeSlider,
		loaded,
		value,
		label,
		root,
		show_label,
		name,
		source,
		pending,
		streaming,
		autoplay,
		show_edit_button,
		i18n,
		recording,
		recorder,
		mode,
		header,
		pending_stream,
		submit_pending_stream_on_pending_end,
		player,
		inited,
		crop_values,
		STREAM_TIMESLICE,
		NUM_HEADER_BYTES,
		audio_chunks,
		module_promises,
		get_modules,
		dispatch,
		blob_to_data_url,
		dispatch_blob,
		prepare_audio,
		handle_chunk,
		record,
		stop,
		clear,
		handle_change,
		handle_load,
		handle_ended,
		dragging
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('root' in $$props) $$invalidate(3, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(4, show_label = $$props.show_label);
		if ('name' in $$props) $$invalidate(20, name = $$props.name);
		if ('source' in $$props) $$invalidate(5, source = $$props.source);
		if ('pending' in $$props) $$invalidate(21, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(6, streaming = $$props.streaming);
		if ('autoplay' in $$props) $$invalidate(7, autoplay = $$props.autoplay);
		if ('show_edit_button' in $$props) $$invalidate(8, show_edit_button = $$props.show_edit_button);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
		if ('recording' in $$props) $$invalidate(10, recording = $$props.recording);
		if ('recorder' in $$props) recorder = $$props.recorder;
		if ('mode' in $$props) $$invalidate(11, mode = $$props.mode);
		if ('header' in $$props) $$invalidate(22, header = $$props.header);
		if ('pending_stream' in $$props) $$invalidate(23, pending_stream = $$props.pending_stream);
		if ('submit_pending_stream_on_pending_end' in $$props) $$invalidate(24, submit_pending_stream_on_pending_end = $$props.submit_pending_stream_on_pending_end);
		if ('player' in $$props) $$invalidate(12, player = $$props.player);
		if ('inited' in $$props) inited = $$props.inited;
		if ('crop_values' in $$props) $$invalidate(13, crop_values = $$props.crop_values);
		if ('audio_chunks' in $$props) audio_chunks = $$props.audio_chunks;
		if ('module_promises' in $$props) module_promises = $$props.module_promises;
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*submit_pending_stream_on_pending_end, pending, header, pending_stream*/ 31457280) {
			if (submit_pending_stream_on_pending_end && pending === false) {
				$$invalidate(24, submit_pending_stream_on_pending_end = false);

				if (header && pending_stream) {
					let blobParts = [header].concat(pending_stream);
					$$invalidate(23, pending_stream = []);
					dispatch_blob(blobParts, "stream");
				}
			}
		}

		if ($$self.$$.dirty[0] & /*dragging*/ 1) {
			dispatch("drag", dragging);
		}
	};

	return [
		dragging,
		value,
		label,
		root,
		show_label,
		source,
		streaming,
		autoplay,
		show_edit_button,
		i18n,
		recording,
		mode,
		player,
		crop_values,
		record,
		stop,
		clear,
		handle_change,
		handle_load,
		handle_ended,
		name,
		pending,
		header,
		pending_stream,
		submit_pending_stream_on_pending_end,
		slots,
		play_handler,
		pause_handler,
		upload_dragging_binding,
		edit_handler,
		audio_binding,
		range_values_binding,
		$$scope
	];
}

class Audio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				value: 1,
				label: 2,
				root: 3,
				show_label: 4,
				name: 20,
				source: 5,
				pending: 21,
				streaming: 6,
				autoplay: 7,
				show_edit_button: 8,
				i18n: 9,
				dragging: 0
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Audio",
			options,
			id: create_fragment$1.name
		});
	}

	get value() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get root() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set root(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get source() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set source(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pending() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pending(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get streaming() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streaming(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoplay() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoplay(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_edit_button() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_edit_button(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dragging() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dragging(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/peterallen/Projects/gradio/js/audio/interactive/InteractiveAudio.svelte generated by Svelte v4.0.0 */

// (55:1) <Audio   {label}   {show_label}   value={_value}   on:change={({ detail }) => (value = detail)}   on:stream={({ detail }) => {    value = detail;    gradio.dispatch("stream", value);   }}   on:drag={({ detail }) => (dragging = detail)}   {name}   {root}   {source}   {pending}   {streaming}   {autoplay}   {show_edit_button}   on:edit={() => gradio.dispatch("edit")}   on:play={() => gradio.dispatch("play")}   on:pause={() => gradio.dispatch("pause")}   on:stop={() => gradio.dispatch("stop")}   on:end={() => gradio.dispatch("end")}   on:start_recording={() => gradio.dispatch("start_recording")}   on:stop_recording={() => gradio.dispatch("stop_recording")}   on:upload={() => gradio.dispatch("upload")}   on:clear={() => gradio.dispatch("clear")}   on:error={({ detail }) => {    loading_status = loading_status || {};    loading_status.status = "error";    gradio.dispatch("error", detail);   }}   i18n={gradio.i18n}  >
function create_default_slot_1(ctx) {
	let uploadtext;
	let current;

	uploadtext = new UploadText({
			props: {
				i18n: /*gradio*/ ctx[17].i18n,
				type: "audio"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(uploadtext.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(uploadtext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const uploadtext_changes = {};
			if (dirty[0] & /*gradio*/ 131072) uploadtext_changes.i18n = /*gradio*/ ctx[17].i18n;
			uploadtext.$set(uploadtext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(uploadtext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(uploadtext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(uploadtext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(55:1) <Audio   {label}   {show_label}   value={_value}   on:change={({ detail }) => (value = detail)}   on:stream={({ detail }) => {    value = detail;    gradio.dispatch(\\\"stream\\\", value);   }}   on:drag={({ detail }) => (dragging = detail)}   {name}   {root}   {source}   {pending}   {streaming}   {autoplay}   {show_edit_button}   on:edit={() => gradio.dispatch(\\\"edit\\\")}   on:play={() => gradio.dispatch(\\\"play\\\")}   on:pause={() => gradio.dispatch(\\\"pause\\\")}   on:stop={() => gradio.dispatch(\\\"stop\\\")}   on:end={() => gradio.dispatch(\\\"end\\\")}   on:start_recording={() => gradio.dispatch(\\\"start_recording\\\")}   on:stop_recording={() => gradio.dispatch(\\\"stop_recording\\\")}   on:upload={() => gradio.dispatch(\\\"upload\\\")}   on:clear={() => gradio.dispatch(\\\"clear\\\")}   on:error={({ detail }) => {    loading_status = loading_status || {};    loading_status.status = \\\"error\\\";    gradio.dispatch(\\\"error\\\", detail);   }}   i18n={gradio.i18n}  >",
		ctx
	});

	return block;
}

// (39:0) <Block  variant={value === null && source === "upload" ? "dashed" : "solid"}  border_mode={dragging ? "focus" : "base"}  padding={false}  {elem_id}  {elem_classes}  {visible}  {container}  {scale}  {min_width} >
function create_default_slot(ctx) {
	let statustracker;
	let t;
	let audio;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[17].autoscroll
		},
		{ i18n: /*gradio*/ ctx[17].i18n },
		/*loading_status*/ ctx[1]
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({
			props: statustracker_props,
			$$inline: true
		});

	audio = new Audio({
			props: {
				label: /*label*/ ctx[7],
				show_label: /*show_label*/ ctx[9],
				value: /*_value*/ ctx[18],
				name: /*name*/ ctx[5],
				root: /*root*/ ctx[8],
				source: /*source*/ ctx[6],
				pending: /*pending*/ ctx[10],
				streaming: /*streaming*/ ctx[11],
				autoplay: /*autoplay*/ ctx[15],
				show_edit_button: /*show_edit_button*/ ctx[16],
				i18n: /*gradio*/ ctx[17].i18n,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	audio.$on("change", /*change_handler*/ ctx[22]);
	audio.$on("stream", /*stream_handler*/ ctx[23]);
	audio.$on("drag", /*drag_handler*/ ctx[24]);
	audio.$on("edit", /*edit_handler*/ ctx[25]);
	audio.$on("play", /*play_handler*/ ctx[26]);
	audio.$on("pause", /*pause_handler*/ ctx[27]);
	audio.$on("stop", /*stop_handler*/ ctx[28]);
	audio.$on("end", /*end_handler*/ ctx[29]);
	audio.$on("start_recording", /*start_recording_handler*/ ctx[30]);
	audio.$on("stop_recording", /*stop_recording_handler*/ ctx[31]);
	audio.$on("upload", /*upload_handler*/ ctx[32]);
	audio.$on("clear", /*clear_handler*/ ctx[33]);
	audio.$on("error", /*error_handler*/ ctx[34]);

	const block = {
		c: function create() {
			create_component(statustracker.$$.fragment);
			t = space();
			create_component(audio.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(audio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const statustracker_changes = (dirty[0] & /*gradio, loading_status*/ 131074)
			? get_spread_update(statustracker_spread_levels, [
					dirty[0] & /*gradio*/ 131072 && {
						autoscroll: /*gradio*/ ctx[17].autoscroll
					},
					dirty[0] & /*gradio*/ 131072 && { i18n: /*gradio*/ ctx[17].i18n },
					dirty[0] & /*loading_status*/ 2 && get_spread_object(/*loading_status*/ ctx[1])
				])
			: {};

			statustracker.$set(statustracker_changes);
			const audio_changes = {};
			if (dirty[0] & /*label*/ 128) audio_changes.label = /*label*/ ctx[7];
			if (dirty[0] & /*show_label*/ 512) audio_changes.show_label = /*show_label*/ ctx[9];
			if (dirty[0] & /*_value*/ 262144) audio_changes.value = /*_value*/ ctx[18];
			if (dirty[0] & /*name*/ 32) audio_changes.name = /*name*/ ctx[5];
			if (dirty[0] & /*root*/ 256) audio_changes.root = /*root*/ ctx[8];
			if (dirty[0] & /*source*/ 64) audio_changes.source = /*source*/ ctx[6];
			if (dirty[0] & /*pending*/ 1024) audio_changes.pending = /*pending*/ ctx[10];
			if (dirty[0] & /*streaming*/ 2048) audio_changes.streaming = /*streaming*/ ctx[11];
			if (dirty[0] & /*autoplay*/ 32768) audio_changes.autoplay = /*autoplay*/ ctx[15];
			if (dirty[0] & /*show_edit_button*/ 65536) audio_changes.show_edit_button = /*show_edit_button*/ ctx[16];
			if (dirty[0] & /*gradio*/ 131072) audio_changes.i18n = /*gradio*/ ctx[17].i18n;

			if (dirty[0] & /*gradio*/ 131072 | dirty[1] & /*$$scope*/ 16) {
				audio_changes.$$scope = { dirty, ctx };
			}

			audio.$set(audio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(audio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(audio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}

			destroy_component(statustracker, detaching);
			destroy_component(audio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(39:0) <Block  variant={value === null && source === \\\"upload\\\" ? \\\"dashed\\\" : \\\"solid\\\"}  border_mode={dragging ? \\\"focus\\\" : \\\"base\\\"}  padding={false}  {elem_id}  {elem_classes}  {visible}  {container}  {scale}  {min_width} >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				variant: /*value*/ ctx[0] === null && /*source*/ ctx[6] === "upload"
				? "dashed"
				: "solid",
				border_mode: /*dragging*/ ctx[19] ? "focus" : "base",
				padding: false,
				elem_id: /*elem_id*/ ctx[2],
				elem_classes: /*elem_classes*/ ctx[3],
				visible: /*visible*/ ctx[4],
				container: /*container*/ ctx[12],
				scale: /*scale*/ ctx[13],
				min_width: /*min_width*/ ctx[14],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block_1 = {
		c: function create() {
			create_component(block.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const block_changes = {};

			if (dirty[0] & /*value, source*/ 65) block_changes.variant = /*value*/ ctx[0] === null && /*source*/ ctx[6] === "upload"
			? "dashed"
			: "solid";

			if (dirty[0] & /*dragging*/ 524288) block_changes.border_mode = /*dragging*/ ctx[19] ? "focus" : "base";
			if (dirty[0] & /*elem_id*/ 4) block_changes.elem_id = /*elem_id*/ ctx[2];
			if (dirty[0] & /*elem_classes*/ 8) block_changes.elem_classes = /*elem_classes*/ ctx[3];
			if (dirty[0] & /*visible*/ 16) block_changes.visible = /*visible*/ ctx[4];
			if (dirty[0] & /*container*/ 4096) block_changes.container = /*container*/ ctx[12];
			if (dirty[0] & /*scale*/ 8192) block_changes.scale = /*scale*/ ctx[13];
			if (dirty[0] & /*min_width*/ 16384) block_changes.min_width = /*min_width*/ ctx[14];

			if (dirty[0] & /*label, show_label, _value, name, root, source, pending, streaming, autoplay, show_edit_button, gradio, value, dragging, loading_status*/ 1019875 | dirty[1] & /*$$scope*/ 16) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(block, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block_1;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('InteractiveAudio', slots, []);
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { value = null } = $$props;
	let { name } = $$props;
	let { source } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { show_label } = $$props;
	let { pending } = $$props;
	let { streaming } = $$props;
	let { root_url } = $$props;
	let { container = true } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { loading_status } = $$props;
	let { autoplay = false } = $$props;
	let { show_edit_button = true } = $$props;
	let { gradio } = $$props;
	let old_value = null;
	let _value;
	let dragging;

	$$self.$$.on_mount.push(function () {
		if (name === undefined && !('name' in $$props || $$self.$$.bound[$$self.$$.props['name']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'name'");
		}

		if (source === undefined && !('source' in $$props || $$self.$$.bound[$$self.$$.props['source']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'source'");
		}

		if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'label'");
		}

		if (root === undefined && !('root' in $$props || $$self.$$.bound[$$self.$$.props['root']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'root'");
		}

		if (show_label === undefined && !('show_label' in $$props || $$self.$$.bound[$$self.$$.props['show_label']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'show_label'");
		}

		if (pending === undefined && !('pending' in $$props || $$self.$$.bound[$$self.$$.props['pending']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'pending'");
		}

		if (streaming === undefined && !('streaming' in $$props || $$self.$$.bound[$$self.$$.props['streaming']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'streaming'");
		}

		if (root_url === undefined && !('root_url' in $$props || $$self.$$.bound[$$self.$$.props['root_url']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'root_url'");
		}

		if (loading_status === undefined && !('loading_status' in $$props || $$self.$$.bound[$$self.$$.props['loading_status']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'loading_status'");
		}

		if (gradio === undefined && !('gradio' in $$props || $$self.$$.bound[$$self.$$.props['gradio']])) {
			console.warn("<InteractiveAudio> was created without expected prop 'gradio'");
		}
	});

	const writable_props = [
		'elem_id',
		'elem_classes',
		'visible',
		'value',
		'name',
		'source',
		'label',
		'root',
		'show_label',
		'pending',
		'streaming',
		'root_url',
		'container',
		'scale',
		'min_width',
		'loading_status',
		'autoplay',
		'show_edit_button',
		'gradio'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InteractiveAudio> was created with unknown prop '${key}'`);
	});

	const change_handler = ({ detail }) => $$invalidate(0, value = detail);

	const stream_handler = ({ detail }) => {
		$$invalidate(0, value = detail);
		gradio.dispatch("stream", value);
	};

	const drag_handler = ({ detail }) => $$invalidate(19, dragging = detail);
	const edit_handler = () => gradio.dispatch("edit");
	const play_handler = () => gradio.dispatch("play");
	const pause_handler = () => gradio.dispatch("pause");
	const stop_handler = () => gradio.dispatch("stop");
	const end_handler = () => gradio.dispatch("end");
	const start_recording_handler = () => gradio.dispatch("start_recording");
	const stop_recording_handler = () => gradio.dispatch("stop_recording");
	const upload_handler = () => gradio.dispatch("upload");
	const clear_handler = () => gradio.dispatch("clear");

	const error_handler = ({ detail }) => {
		$$invalidate(1, loading_status = loading_status || {});
		$$invalidate(1, loading_status.status = "error", loading_status);
		gradio.dispatch("error", detail);
	};

	$$self.$$set = $$props => {
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(3, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('name' in $$props) $$invalidate(5, name = $$props.name);
		if ('source' in $$props) $$invalidate(6, source = $$props.source);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('root' in $$props) $$invalidate(8, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(9, show_label = $$props.show_label);
		if ('pending' in $$props) $$invalidate(10, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(11, streaming = $$props.streaming);
		if ('root_url' in $$props) $$invalidate(20, root_url = $$props.root_url);
		if ('container' in $$props) $$invalidate(12, container = $$props.container);
		if ('scale' in $$props) $$invalidate(13, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(14, min_width = $$props.min_width);
		if ('loading_status' in $$props) $$invalidate(1, loading_status = $$props.loading_status);
		if ('autoplay' in $$props) $$invalidate(15, autoplay = $$props.autoplay);
		if ('show_edit_button' in $$props) $$invalidate(16, show_edit_button = $$props.show_edit_button);
		if ('gradio' in $$props) $$invalidate(17, gradio = $$props.gradio);
	};

	$$self.$capture_state = () => ({
		UploadText,
		Audio,
		StatusTracker: Static,
		Block,
		normalise_file,
		elem_id,
		elem_classes,
		visible,
		value,
		name,
		source,
		label,
		root,
		show_label,
		pending,
		streaming,
		root_url,
		container,
		scale,
		min_width,
		loading_status,
		autoplay,
		show_edit_button,
		gradio,
		old_value,
		_value,
		dragging
	});

	$$self.$inject_state = $$props => {
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(3, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('name' in $$props) $$invalidate(5, name = $$props.name);
		if ('source' in $$props) $$invalidate(6, source = $$props.source);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('root' in $$props) $$invalidate(8, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(9, show_label = $$props.show_label);
		if ('pending' in $$props) $$invalidate(10, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(11, streaming = $$props.streaming);
		if ('root_url' in $$props) $$invalidate(20, root_url = $$props.root_url);
		if ('container' in $$props) $$invalidate(12, container = $$props.container);
		if ('scale' in $$props) $$invalidate(13, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(14, min_width = $$props.min_width);
		if ('loading_status' in $$props) $$invalidate(1, loading_status = $$props.loading_status);
		if ('autoplay' in $$props) $$invalidate(15, autoplay = $$props.autoplay);
		if ('show_edit_button' in $$props) $$invalidate(16, show_edit_button = $$props.show_edit_button);
		if ('gradio' in $$props) $$invalidate(17, gradio = $$props.gradio);
		if ('old_value' in $$props) $$invalidate(21, old_value = $$props.old_value);
		if ('_value' in $$props) $$invalidate(18, _value = $$props._value);
		if ('dragging' in $$props) $$invalidate(19, dragging = $$props.dragging);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, root, root_url*/ 1048833) {
			$$invalidate(18, _value = normalise_file(value, root, root_url));
		}

		if ($$self.$$.dirty[0] & /*value, old_value, gradio*/ 2228225) {
			{
				if (JSON.stringify(value) !== JSON.stringify(old_value)) {
					$$invalidate(21, old_value = value);
					gradio.dispatch("change");
				}
			}
		}
	};

	return [
		value,
		loading_status,
		elem_id,
		elem_classes,
		visible,
		name,
		source,
		label,
		root,
		show_label,
		pending,
		streaming,
		container,
		scale,
		min_width,
		autoplay,
		show_edit_button,
		gradio,
		_value,
		dragging,
		root_url,
		old_value,
		change_handler,
		stream_handler,
		drag_handler,
		edit_handler,
		play_handler,
		pause_handler,
		stop_handler,
		end_handler,
		start_recording_handler,
		stop_recording_handler,
		upload_handler,
		clear_handler,
		error_handler
	];
}

class InteractiveAudio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				elem_id: 2,
				elem_classes: 3,
				visible: 4,
				value: 0,
				name: 5,
				source: 6,
				label: 7,
				root: 8,
				show_label: 9,
				pending: 10,
				streaming: 11,
				root_url: 20,
				container: 12,
				scale: 13,
				min_width: 14,
				loading_status: 1,
				autoplay: 15,
				show_edit_button: 16,
				gradio: 17
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InteractiveAudio",
			options,
			id: create_fragment.name
		});
	}

	get elem_id() {
		return this.$$.ctx[2];
	}

	set elem_id(elem_id) {
		this.$$set({ elem_id });
		flush();
	}

	get elem_classes() {
		return this.$$.ctx[3];
	}

	set elem_classes(elem_classes) {
		this.$$set({ elem_classes });
		flush();
	}

	get visible() {
		return this.$$.ctx[4];
	}

	set visible(visible) {
		this.$$set({ visible });
		flush();
	}

	get value() {
		return this.$$.ctx[0];
	}

	set value(value) {
		this.$$set({ value });
		flush();
	}

	get name() {
		return this.$$.ctx[5];
	}

	set name(name) {
		this.$$set({ name });
		flush();
	}

	get source() {
		return this.$$.ctx[6];
	}

	set source(source) {
		this.$$set({ source });
		flush();
	}

	get label() {
		return this.$$.ctx[7];
	}

	set label(label) {
		this.$$set({ label });
		flush();
	}

	get root() {
		return this.$$.ctx[8];
	}

	set root(root) {
		this.$$set({ root });
		flush();
	}

	get show_label() {
		return this.$$.ctx[9];
	}

	set show_label(show_label) {
		this.$$set({ show_label });
		flush();
	}

	get pending() {
		return this.$$.ctx[10];
	}

	set pending(pending) {
		this.$$set({ pending });
		flush();
	}

	get streaming() {
		return this.$$.ctx[11];
	}

	set streaming(streaming) {
		this.$$set({ streaming });
		flush();
	}

	get root_url() {
		return this.$$.ctx[20];
	}

	set root_url(root_url) {
		this.$$set({ root_url });
		flush();
	}

	get container() {
		return this.$$.ctx[12];
	}

	set container(container) {
		this.$$set({ container });
		flush();
	}

	get scale() {
		return this.$$.ctx[13];
	}

	set scale(scale) {
		this.$$set({ scale });
		flush();
	}

	get min_width() {
		return this.$$.ctx[14];
	}

	set min_width(min_width) {
		this.$$set({ min_width });
		flush();
	}

	get loading_status() {
		return this.$$.ctx[1];
	}

	set loading_status(loading_status) {
		this.$$set({ loading_status });
		flush();
	}

	get autoplay() {
		return this.$$.ctx[15];
	}

	set autoplay(autoplay) {
		this.$$set({ autoplay });
		flush();
	}

	get show_edit_button() {
		return this.$$.ctx[16];
	}

	set show_edit_button(show_edit_button) {
		this.$$set({ show_edit_button });
		flush();
	}

	get gradio() {
		return this.$$.ctx[17];
	}

	set gradio(gradio) {
		this.$$set({ gradio });
		flush();
	}
}

const InteractiveAudio$1 = InteractiveAudio;

export { InteractiveAudio$1 as default };
//# sourceMappingURL=index-f1e452c9.js.map
