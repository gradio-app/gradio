import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, svg_element, attr_dev, add_location, insert_dev, append_dev, noop, detach_dev, add_render_callback, createEventDispatcher, ensure_array_like_dev, element, space, empty, listen_dev, transition_in, group_outros, transition_out, check_outros, run_all, binding_callbacks, set_style, prevent_default, create_bidirectional_transition, destroy_each, text, toggle_class, set_data_dev, afterUpdate, create_component, mount_component, set_input_value, prop_dev, destroy_component } from './svelte/svelte-internal.js';
import { e as fly } from './Button-153ea7e7.js';
import { B as BlockTitle } from './BlockTitle-10d6508b.js';
import { X, n as ne } from './index-30423ace.js';

/* Users/peterallen/Projects/gradio/js/icons/src/DropdownArrow.svelte generated by Svelte v4.0.0 */

const file$4 = "Users/peterallen/Projects/gradio/js/icons/src/DropdownArrow.svelte";

function create_fragment$4(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M5 8l4 4 4-4z");
			add_location(path, file$4, 7, 1, 114);
			attr_dev(svg, "class", "dropdown-arrow s-11fth0n8rAzA");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "18");
			attr_dev(svg, "height", "18");
			attr_dev(svg, "viewBox", "0 0 18 18");
			add_location(svg, file$4, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DropdownArrow', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DropdownArrow> was created with unknown prop '${key}'`);
	});

	return [];
}

class DropdownArrow extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DropdownArrow",
			options,
			id: create_fragment$4.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Remove.svelte generated by Svelte v4.0.0 */

const file$3 = "Users/peterallen/Projects/gradio/js/icons/src/Remove.svelte";

function create_fragment$3(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z");
			add_location(path, file$3, 6, 1, 90);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "16");
			attr_dev(svg, "height", "16");
			attr_dev(svg, "viewBox", "0 0 24 24");
			add_location(svg, file$3, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Remove', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Remove> was created with unknown prop '${key}'`);
	});

	return [];
}

class Remove extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Remove",
			options,
			id: create_fragment$3.name
		});
	}
}

const DropdownOptions_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/dropdown/shared/DropdownOptions.svelte generated by Svelte v4.0.0 */
const file$2 = "Users/peterallen/Projects/gradio/js/dropdown/shared/DropdownOptions.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i];
	return child_ctx;
}

// (68:0) {#if show_options && !disabled}
function create_if_block$2(ctx) {
	let ul;
	let ul_transition;
	let current;
	let mounted;
	let dispose;
	let each_value = ensure_array_like_dev(/*filtered_indices*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(ul, "class", "options s-Sz9fxSsJZ5JJ");
			set_style(ul, "top", /*top*/ ctx[9]);
			set_style(ul, "bottom", /*bottom*/ ctx[10]);
			set_style(ul, "max-height", `calc(${/*max_height*/ ctx[11]}px - var(--window-padding))`);
			set_style(ul, "width", /*input_width*/ ctx[8] + "px");
			add_location(ul, file$2, 78, 1, 2228);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			/*ul_binding*/ ctx[21](ul);
			current = true;

			if (!mounted) {
				dispose = listen_dev(ul, "mousedown", prevent_default(/*mousedown_handler*/ ctx[20]), false, true, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*filtered_indices, choices, selected_indices, active_index*/ 51) {
				each_value = ensure_array_like_dev(/*filtered_indices*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*top*/ 512) {
				set_style(ul, "top", /*top*/ ctx[9]);
			}

			if (dirty & /*bottom*/ 1024) {
				set_style(ul, "bottom", /*bottom*/ ctx[10]);
			}

			if (dirty & /*max_height*/ 2048) {
				set_style(ul, "max-height", `calc(${/*max_height*/ ctx[11]}px - var(--window-padding))`);
			}

			if (dirty & /*input_width*/ 256) {
				set_style(ul, "width", /*input_width*/ ctx[8] + "px");
			}
		},
		i: function intro(local) {
			if (current) return;

			if (local) {
				add_render_callback(() => {
					if (!current) return;
					if (!ul_transition) ul_transition = create_bidirectional_transition(ul, fly, { duration: 200, y: 5 }, true);
					ul_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			if (local) {
				if (!ul_transition) ul_transition = create_bidirectional_transition(ul, fly, { duration: 200, y: 5 }, false);
				ul_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(ul);
			}

			destroy_each(each_blocks, detaching);
			/*ul_binding*/ ctx[21](null);
			if (detaching && ul_transition) ul_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(68:0) {#if show_options && !disabled}",
		ctx
	});

	return block;
}

// (81:2) {#each filtered_indices as index}
function create_each_block$1(ctx) {
	let li;
	let span;
	let t1;
	let t2_value = /*choices*/ ctx[0][/*index*/ ctx[24]][0] + "";
	let t2;
	let t3;
	let li_data_index_value;
	let li_aria_label_value;

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			span.textContent = "âœ“";
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			attr_dev(span, "class", "inner-item s-Sz9fxSsJZ5JJ");
			toggle_class(span, "hide", !/*selected_indices*/ ctx[4].includes(/*index*/ ctx[24]));
			add_location(span, file$2, 102, 4, 2986);
			attr_dev(li, "class", "item s-Sz9fxSsJZ5JJ");
			attr_dev(li, "role", "button");
			attr_dev(li, "data-index", li_data_index_value = /*index*/ ctx[24]);
			attr_dev(li, "aria-label", li_aria_label_value = /*choices*/ ctx[0][/*index*/ ctx[24]][0]);
			attr_dev(li, "data-testid", "dropdown-option");
			toggle_class(li, "selected", /*selected_indices*/ ctx[4].includes(/*index*/ ctx[24]));
			toggle_class(li, "active", /*index*/ ctx[24] === /*active_index*/ ctx[5]);
			toggle_class(li, "bg-gray-100", /*index*/ ctx[24] === /*active_index*/ ctx[5]);
			toggle_class(li, "dark:bg-gray-600", /*index*/ ctx[24] === /*active_index*/ ctx[5]);
			add_location(li, file$2, 91, 3, 2651);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);
			append_dev(li, t1);
			append_dev(li, t2);
			append_dev(li, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selected_indices, filtered_indices*/ 18) {
				toggle_class(span, "hide", !/*selected_indices*/ ctx[4].includes(/*index*/ ctx[24]));
			}

			if (dirty & /*choices, filtered_indices*/ 3 && t2_value !== (t2_value = /*choices*/ ctx[0][/*index*/ ctx[24]][0] + "")) set_data_dev(t2, t2_value);

			if (dirty & /*filtered_indices*/ 2 && li_data_index_value !== (li_data_index_value = /*index*/ ctx[24])) {
				attr_dev(li, "data-index", li_data_index_value);
			}

			if (dirty & /*choices, filtered_indices*/ 3 && li_aria_label_value !== (li_aria_label_value = /*choices*/ ctx[0][/*index*/ ctx[24]][0])) {
				attr_dev(li, "aria-label", li_aria_label_value);
			}

			if (dirty & /*selected_indices, filtered_indices*/ 18) {
				toggle_class(li, "selected", /*selected_indices*/ ctx[4].includes(/*index*/ ctx[24]));
			}

			if (dirty & /*filtered_indices, active_index*/ 34) {
				toggle_class(li, "active", /*index*/ ctx[24] === /*active_index*/ ctx[5]);
			}

			if (dirty & /*filtered_indices, active_index*/ 34) {
				toggle_class(li, "bg-gray-100", /*index*/ ctx[24] === /*active_index*/ ctx[5]);
			}

			if (dirty & /*filtered_indices, active_index*/ 34) {
				toggle_class(li, "dark:bg-gray-600", /*index*/ ctx[24] === /*active_index*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(81:2) {#each filtered_indices as index}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let t;
	let if_block_anchor;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[18]);
	let if_block = /*show_options*/ ctx[2] && !/*disabled*/ ctx[3] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(div, "class", "reference");
			add_location(div, file$2, 74, 0, 2059);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[19](div);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(window, "scroll", /*scroll_listener*/ ctx[13], false, false, false, false),
					listen_dev(window, "resize", /*onwindowresize*/ ctx[18])
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*show_options*/ ctx[2] && !/*disabled*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*show_options, disabled*/ 12) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			transition_in(if_block);
		},
		o: function outro(local) {
			transition_out(if_block);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
				detach_dev(t);
				detach_dev(if_block_anchor);
			}

			/*div_binding*/ ctx[19](null);
			if (if_block) if_block.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DropdownOptions', slots, []);
	let { choices } = $$props;
	let { filtered_indices } = $$props;
	let { show_options = false } = $$props;
	let { disabled = false } = $$props;
	let { selected_indices = [] } = $$props;
	let { active_index = null } = $$props;
	let distance_from_top;
	let distance_from_bottom;
	let input_height;
	let input_width;
	let refElement;
	let listElement;
	let top, bottom, max_height;
	let innerHeight;

	function calculate_window_distance() {
		const { top: ref_top, bottom: ref_bottom } = refElement.getBoundingClientRect();
		$$invalidate(15, distance_from_top = ref_top);
		$$invalidate(16, distance_from_bottom = innerHeight - ref_bottom);
	}

	let scroll_timeout = null;

	function scroll_listener() {
		if (!show_options) return;

		if (scroll_timeout !== null) {
			clearTimeout(scroll_timeout);
		}

		scroll_timeout = setTimeout(
			() => {
				calculate_window_distance();
				scroll_timeout = null;
			},
			10
		);
	}

	const dispatch = createEventDispatcher();

	$$self.$$.on_mount.push(function () {
		if (choices === undefined && !('choices' in $$props || $$self.$$.bound[$$self.$$.props['choices']])) {
			console.warn("<DropdownOptions> was created without expected prop 'choices'");
		}

		if (filtered_indices === undefined && !('filtered_indices' in $$props || $$self.$$.bound[$$self.$$.props['filtered_indices']])) {
			console.warn("<DropdownOptions> was created without expected prop 'filtered_indices'");
		}
	});

	const writable_props = [
		'choices',
		'filtered_indices',
		'show_options',
		'disabled',
		'selected_indices',
		'active_index'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DropdownOptions> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		$$invalidate(12, innerHeight = window.innerHeight);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refElement = $$value;
			$$invalidate(6, refElement);
		});
	}

	const mousedown_handler = e => dispatch("change", e);

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			listElement = $$value;
			$$invalidate(7, listElement);
		});
	}

	$$self.$$set = $$props => {
		if ('choices' in $$props) $$invalidate(0, choices = $$props.choices);
		if ('filtered_indices' in $$props) $$invalidate(1, filtered_indices = $$props.filtered_indices);
		if ('show_options' in $$props) $$invalidate(2, show_options = $$props.show_options);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('selected_indices' in $$props) $$invalidate(4, selected_indices = $$props.selected_indices);
		if ('active_index' in $$props) $$invalidate(5, active_index = $$props.active_index);
	};

	$$self.$capture_state = () => ({
		fly,
		createEventDispatcher,
		choices,
		filtered_indices,
		show_options,
		disabled,
		selected_indices,
		active_index,
		distance_from_top,
		distance_from_bottom,
		input_height,
		input_width,
		refElement,
		listElement,
		top,
		bottom,
		max_height,
		innerHeight,
		calculate_window_distance,
		scroll_timeout,
		scroll_listener,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ('choices' in $$props) $$invalidate(0, choices = $$props.choices);
		if ('filtered_indices' in $$props) $$invalidate(1, filtered_indices = $$props.filtered_indices);
		if ('show_options' in $$props) $$invalidate(2, show_options = $$props.show_options);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('selected_indices' in $$props) $$invalidate(4, selected_indices = $$props.selected_indices);
		if ('active_index' in $$props) $$invalidate(5, active_index = $$props.active_index);
		if ('distance_from_top' in $$props) $$invalidate(15, distance_from_top = $$props.distance_from_top);
		if ('distance_from_bottom' in $$props) $$invalidate(16, distance_from_bottom = $$props.distance_from_bottom);
		if ('input_height' in $$props) $$invalidate(17, input_height = $$props.input_height);
		if ('input_width' in $$props) $$invalidate(8, input_width = $$props.input_width);
		if ('refElement' in $$props) $$invalidate(6, refElement = $$props.refElement);
		if ('listElement' in $$props) $$invalidate(7, listElement = $$props.listElement);
		if ('top' in $$props) $$invalidate(9, top = $$props.top);
		if ('bottom' in $$props) $$invalidate(10, bottom = $$props.bottom);
		if ('max_height' in $$props) $$invalidate(11, max_height = $$props.max_height);
		if ('innerHeight' in $$props) $$invalidate(12, innerHeight = $$props.innerHeight);
		if ('scroll_timeout' in $$props) scroll_timeout = $$props.scroll_timeout;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*show_options, refElement, listElement, selected_indices, distance_from_bottom, distance_from_top, input_height*/ 229588) {
			{
				if (show_options && refElement) {
					if (listElement && selected_indices.length > 0) {
						let elements = listElement.querySelectorAll("li");

						for (const element of Array.from(elements)) {
							if (element.getAttribute("data-index") === selected_indices[0].toString()) {
								listElement?.scrollTo?.(0, element.offsetTop);
								break;
							}
						}
					}

					calculate_window_distance();
					const rect = refElement.parentElement?.getBoundingClientRect();
					$$invalidate(17, input_height = rect?.height || 0);
					$$invalidate(8, input_width = rect?.width || 0);
				}

				if (distance_from_bottom > distance_from_top) {
					$$invalidate(9, top = `${distance_from_top}px`);
					$$invalidate(11, max_height = distance_from_bottom);
					$$invalidate(10, bottom = null);
				} else {
					$$invalidate(10, bottom = `${distance_from_bottom + input_height}px`);
					$$invalidate(11, max_height = distance_from_top - input_height);
					$$invalidate(9, top = null);
				}
			}
		}
	};

	return [
		choices,
		filtered_indices,
		show_options,
		disabled,
		selected_indices,
		active_index,
		refElement,
		listElement,
		input_width,
		top,
		bottom,
		max_height,
		innerHeight,
		scroll_listener,
		dispatch,
		distance_from_top,
		distance_from_bottom,
		input_height,
		onwindowresize,
		div_binding,
		mousedown_handler,
		ul_binding
	];
}

class DropdownOptions extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			choices: 0,
			filtered_indices: 1,
			show_options: 2,
			disabled: 3,
			selected_indices: 4,
			active_index: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DropdownOptions",
			options,
			id: create_fragment$2.name
		});
	}

	get choices() {
		throw new Error("<DropdownOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set choices(value) {
		throw new Error("<DropdownOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filtered_indices() {
		throw new Error("<DropdownOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filtered_indices(value) {
		throw new Error("<DropdownOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_options() {
		throw new Error("<DropdownOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_options(value) {
		throw new Error("<DropdownOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<DropdownOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<DropdownOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected_indices() {
		throw new Error("<DropdownOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected_indices(value) {
		throw new Error("<DropdownOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active_index() {
		throw new Error("<DropdownOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active_index(value) {
		throw new Error("<DropdownOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function positive_mod(n, m) {
  return (n % m + m) % m;
}
function handle_filter(choices, input_text) {
  return choices.reduce((filtered_indices, o, index) => {
    if (input_text ? o[0].toLowerCase().includes(input_text.toLowerCase()) : true) {
      filtered_indices.push(index);
    }
    return filtered_indices;
  }, []);
}
function handle_change(dispatch, value, value_is_output) {
  dispatch("change", value);
  if (!value_is_output) {
    dispatch("input");
  }
}
function handle_shared_keys(e, active_index, filtered_indices) {
  if (e.key === "Escape") {
    return [false, active_index];
  }
  if (e.key === "ArrowDown" || e.key === "ArrowUp") {
    if (filtered_indices.length >= 0) {
      if (active_index === null) {
        active_index = e.key === "ArrowDown" ? filtered_indices[0] : filtered_indices[filtered_indices.length - 1];
      } else {
        const index_in_filtered = filtered_indices.indexOf(active_index);
        const increment = e.key === "ArrowUp" ? -1 : 1;
        active_index = filtered_indices[positive_mod(index_in_filtered + increment, filtered_indices.length)];
      }
    }
  }
  return [true, active_index];
}

const Dropdown_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/dropdown/shared/Dropdown.svelte generated by Svelte v4.0.0 */
const file$1 = "Users/peterallen/Projects/gradio/js/dropdown/shared/Dropdown.svelte";

// (152:1) <BlockTitle {show_label} {info}>
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(152:1) <BlockTitle {show_label} {info}>",
		ctx
	});

	return block;
}

// (170:4) {#if !disabled}
function create_if_block$1(ctx) {
	let dropdownarrow;
	let current;
	dropdownarrow = new DropdownArrow({ $$inline: true });

	const block = {
		c: function create() {
			create_component(dropdownarrow.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(dropdownarrow, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dropdownarrow.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dropdownarrow.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dropdownarrow, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(170:4) {#if !disabled}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let label_1;
	let blocktitle;
	let t0;
	let div2;
	let div1;
	let div0;
	let input;
	let input_readonly_value;
	let t1;
	let t2;
	let dropdownoptions;
	let current;
	let mounted;
	let dispose;

	blocktitle = new BlockTitle({
			props: {
				show_label: /*show_label*/ ctx[4],
				info: /*info*/ ctx[1],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block = !/*disabled*/ ctx[3] && create_if_block$1(ctx);

	dropdownoptions = new DropdownOptions({
			props: {
				show_options: /*show_options*/ ctx[12],
				choices: /*choices*/ ctx[2],
				filtered_indices: /*filtered_indices*/ ctx[9],
				disabled: /*disabled*/ ctx[3],
				selected_indices: /*selected_index*/ ctx[10] === null
				? []
				: [/*selected_index*/ ctx[10]],
				active_index: /*active_index*/ ctx[14]
			},
			$$inline: true
		});

	dropdownoptions.$on("change", /*handle_option_selected*/ ctx[15]);

	const block = {
		c: function create() {
			label_1 = element("label");
			create_component(blocktitle.$$.fragment);
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			input = element("input");
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			create_component(dropdownoptions.$$.fragment);
			attr_dev(input, "class", "border-none s-2tV1OzHR_nQa");
			input.disabled = /*disabled*/ ctx[3];
			attr_dev(input, "autocomplete", "off");
			input.readOnly = input_readonly_value = !/*filterable*/ ctx[7];
			toggle_class(input, "subdued", !/*choices_names*/ ctx[13].includes(/*input_text*/ ctx[8]) && !/*allow_custom_value*/ ctx[6]);
			add_location(input, file$1, 179, 4, 4539);
			attr_dev(div0, "class", "secondary-wrap s-2tV1OzHR_nQa");
			add_location(div0, file$1, 178, 3, 4506);
			attr_dev(div1, "class", "wrap-inner s-2tV1OzHR_nQa");
			toggle_class(div1, "show_options", /*show_options*/ ctx[12]);
			add_location(div1, file$1, 177, 2, 4459);
			attr_dev(div2, "class", "wrap s-2tV1OzHR_nQa");
			add_location(div2, file$1, 176, 1, 4438);
			attr_dev(label_1, "class", "s-2tV1OzHR_nQa");
			toggle_class(label_1, "container", /*container*/ ctx[5]);
			add_location(label_1, file$1, 173, 0, 4358);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			mount_component(blocktitle, label_1, null);
			append_dev(label_1, t0);
			append_dev(label_1, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, input);
			set_input_value(input, /*input_text*/ ctx[8]);
			/*input_binding*/ ctx[29](input);
			append_dev(div0, t1);
			if (if_block) if_block.m(div0, null);
			append_dev(div2, t2);
			mount_component(dropdownoptions, div2, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[28]),
					listen_dev(input, "keydown", /*handle_key_down*/ ctx[18], false, false, false, false),
					listen_dev(input, "blur", /*handle_blur*/ ctx[17], false, false, false, false),
					listen_dev(input, "focus", /*handle_focus*/ ctx[16], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const blocktitle_changes = {};
			if (dirty[0] & /*show_label*/ 16) blocktitle_changes.show_label = /*show_label*/ ctx[4];
			if (dirty[0] & /*info*/ 2) blocktitle_changes.info = /*info*/ ctx[1];

			if (dirty[0] & /*label*/ 1 | dirty[1] & /*$$scope*/ 2) {
				blocktitle_changes.$$scope = { dirty, ctx };
			}

			blocktitle.$set(blocktitle_changes);

			if (!current || dirty[0] & /*disabled*/ 8) {
				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty[0] & /*filterable*/ 128 && input_readonly_value !== (input_readonly_value = !/*filterable*/ ctx[7])) {
				prop_dev(input, "readOnly", input_readonly_value);
			}

			if (dirty[0] & /*input_text*/ 256 && input.value !== /*input_text*/ ctx[8]) {
				set_input_value(input, /*input_text*/ ctx[8]);
			}

			if (!current || dirty[0] & /*choices_names, input_text, allow_custom_value*/ 8512) {
				toggle_class(input, "subdued", !/*choices_names*/ ctx[13].includes(/*input_text*/ ctx[8]) && !/*allow_custom_value*/ ctx[6]);
			}

			if (!/*disabled*/ ctx[3]) {
				if (if_block) {
					if (dirty[0] & /*disabled*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*show_options*/ 4096) {
				toggle_class(div1, "show_options", /*show_options*/ ctx[12]);
			}

			const dropdownoptions_changes = {};
			if (dirty[0] & /*show_options*/ 4096) dropdownoptions_changes.show_options = /*show_options*/ ctx[12];
			if (dirty[0] & /*choices*/ 4) dropdownoptions_changes.choices = /*choices*/ ctx[2];
			if (dirty[0] & /*filtered_indices*/ 512) dropdownoptions_changes.filtered_indices = /*filtered_indices*/ ctx[9];
			if (dirty[0] & /*disabled*/ 8) dropdownoptions_changes.disabled = /*disabled*/ ctx[3];

			if (dirty[0] & /*selected_index*/ 1024) dropdownoptions_changes.selected_indices = /*selected_index*/ ctx[10] === null
			? []
			: [/*selected_index*/ ctx[10]];

			if (dirty[0] & /*active_index*/ 16384) dropdownoptions_changes.active_index = /*active_index*/ ctx[14];
			dropdownoptions.$set(dropdownoptions_changes);

			if (!current || dirty[0] & /*container*/ 32) {
				toggle_class(label_1, "container", /*container*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocktitle.$$.fragment, local);
			transition_in(if_block);
			transition_in(dropdownoptions.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocktitle.$$.fragment, local);
			transition_out(if_block);
			transition_out(dropdownoptions.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(label_1);
			}

			destroy_component(blocktitle);
			/*input_binding*/ ctx[29](null);
			if (if_block) if_block.d();
			destroy_component(dropdownoptions);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Dropdown', slots, []);
	let { label } = $$props;
	let { info = undefined } = $$props;
	let { value = [] } = $$props;
	let old_value = [];
	let { value_is_output = false } = $$props;
	let { choices } = $$props;
	let old_choices;
	let { disabled = false } = $$props;
	let { show_label } = $$props;
	let { container = true } = $$props;
	let { allow_custom_value = false } = $$props;
	let { i18n } = $$props;
	let { filterable = true } = $$props;
	let filter_input;
	let show_options = false;
	let choices_names;
	let choices_values;
	let input_text = "";
	let old_input_text = "";
	let initialized = false;

	// All of these are indices with respect to the choices array
	let filtered_indices = [];

	let active_index = null;

	// selected_index is null if allow_custom_value is true and the input_text is not in choices_names
	let selected_index = null;

	let old_selected_index;
	const dispatch = createEventDispatcher();

	// Setting the initial value of the dropdown
	if (value) {
		old_selected_index = choices.map(c => c[1]).indexOf(value);
		selected_index = old_selected_index;

		if (selected_index === -1) {
			old_value = value;
			selected_index = null;
		} else {
			[input_text, old_value] = choices[selected_index];
			old_input_text = input_text;
		}
	} else if (choices.length > 0) {
		old_selected_index = 0;
		selected_index = 0;
		[input_text, value] = choices[selected_index];
		old_value = value;
		old_input_text = input_text;
	}

	function set_input_text() {
		if (value === undefined) {
			$$invalidate(8, input_text = "");
		} else if (choices_values.includes(value)) {
			$$invalidate(8, input_text = choices_names[choices_values.indexOf(value)]);
		} else if (allow_custom_value) {
			$$invalidate(8, input_text = value);
		} else {
			$$invalidate(8, input_text = "");
		}
	}

	function handle_option_selected(e) {
		$$invalidate(10, selected_index = parseInt(e.detail.target.dataset.index));
		$$invalidate(12, show_options = false);
		$$invalidate(14, active_index = null);
		filter_input.blur();
	}

	function handle_focus(e) {
		$$invalidate(9, filtered_indices = choices.map((_, i) => i));
		$$invalidate(12, show_options = true);
		dispatch("focus");
	}

	function handle_blur() {
		if (!allow_custom_value) {
			$$invalidate(8, input_text = choices_names[choices_values.indexOf(value)]);
		}

		$$invalidate(19, value = input_text);
		$$invalidate(12, show_options = false);
		$$invalidate(14, active_index = null);
		dispatch("blur");
	}

	function handle_key_down(e) {
		$$invalidate(12, [show_options, active_index] = handle_shared_keys(e, active_index, filtered_indices), show_options, (((((((((($$invalidate(14, active_index), $$invalidate(2, choices)), $$invalidate(23, old_choices)), $$invalidate(8, input_text)), $$invalidate(25, old_input_text)), $$invalidate(6, allow_custom_value)), $$invalidate(9, filtered_indices)), $$invalidate(10, selected_index)), $$invalidate(27, old_selected_index)), $$invalidate(26, initialized)), $$invalidate(24, choices_values)));

		if (e.key === "Enter") {
			if (active_index !== null) {
				$$invalidate(10, selected_index = active_index);
				$$invalidate(12, show_options = false);
				filter_input.blur();
				$$invalidate(14, active_index = null);
			} else if (choices_names.includes(input_text)) {
				$$invalidate(10, selected_index = choices_names.indexOf(input_text));
				$$invalidate(12, show_options = false);
				$$invalidate(14, active_index = null);
				filter_input.blur();
			} else if (allow_custom_value) {
				$$invalidate(19, value = input_text);
				$$invalidate(10, selected_index = null);
				$$invalidate(12, show_options = false);
				$$invalidate(14, active_index = null);
				filter_input.blur();
			}
		}
	}

	afterUpdate(() => {
		$$invalidate(20, value_is_output = false);
		$$invalidate(26, initialized = true);
	});

	$$self.$$.on_mount.push(function () {
		if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
			console.warn("<Dropdown> was created without expected prop 'label'");
		}

		if (choices === undefined && !('choices' in $$props || $$self.$$.bound[$$self.$$.props['choices']])) {
			console.warn("<Dropdown> was created without expected prop 'choices'");
		}

		if (show_label === undefined && !('show_label' in $$props || $$self.$$.bound[$$self.$$.props['show_label']])) {
			console.warn("<Dropdown> was created without expected prop 'show_label'");
		}

		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console.warn("<Dropdown> was created without expected prop 'i18n'");
		}
	});

	const writable_props = [
		'label',
		'info',
		'value',
		'value_is_output',
		'choices',
		'disabled',
		'show_label',
		'container',
		'allow_custom_value',
		'i18n',
		'filterable'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dropdown> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		input_text = this.value;
		((((($$invalidate(8, input_text), $$invalidate(10, selected_index)), $$invalidate(27, old_selected_index)), $$invalidate(26, initialized)), $$invalidate(2, choices)), $$invalidate(24, choices_values));
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			filter_input = $$value;
			$$invalidate(11, filter_input);
		});
	}

	$$self.$$set = $$props => {
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('info' in $$props) $$invalidate(1, info = $$props.info);
		if ('value' in $$props) $$invalidate(19, value = $$props.value);
		if ('value_is_output' in $$props) $$invalidate(20, value_is_output = $$props.value_is_output);
		if ('choices' in $$props) $$invalidate(2, choices = $$props.choices);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('show_label' in $$props) $$invalidate(4, show_label = $$props.show_label);
		if ('container' in $$props) $$invalidate(5, container = $$props.container);
		if ('allow_custom_value' in $$props) $$invalidate(6, allow_custom_value = $$props.allow_custom_value);
		if ('i18n' in $$props) $$invalidate(21, i18n = $$props.i18n);
		if ('filterable' in $$props) $$invalidate(7, filterable = $$props.filterable);
	};

	$$self.$capture_state = () => ({
		DropdownOptions,
		createEventDispatcher,
		afterUpdate,
		BlockTitle,
		DropdownArrow,
		handle_filter,
		handle_change,
		handle_shared_keys,
		label,
		info,
		value,
		old_value,
		value_is_output,
		choices,
		old_choices,
		disabled,
		show_label,
		container,
		allow_custom_value,
		i18n,
		filterable,
		filter_input,
		show_options,
		choices_names,
		choices_values,
		input_text,
		old_input_text,
		initialized,
		filtered_indices,
		active_index,
		selected_index,
		old_selected_index,
		dispatch,
		set_input_text,
		handle_option_selected,
		handle_focus,
		handle_blur,
		handle_key_down
	});

	$$self.$inject_state = $$props => {
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('info' in $$props) $$invalidate(1, info = $$props.info);
		if ('value' in $$props) $$invalidate(19, value = $$props.value);
		if ('old_value' in $$props) $$invalidate(22, old_value = $$props.old_value);
		if ('value_is_output' in $$props) $$invalidate(20, value_is_output = $$props.value_is_output);
		if ('choices' in $$props) $$invalidate(2, choices = $$props.choices);
		if ('old_choices' in $$props) $$invalidate(23, old_choices = $$props.old_choices);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('show_label' in $$props) $$invalidate(4, show_label = $$props.show_label);
		if ('container' in $$props) $$invalidate(5, container = $$props.container);
		if ('allow_custom_value' in $$props) $$invalidate(6, allow_custom_value = $$props.allow_custom_value);
		if ('i18n' in $$props) $$invalidate(21, i18n = $$props.i18n);
		if ('filterable' in $$props) $$invalidate(7, filterable = $$props.filterable);
		if ('filter_input' in $$props) $$invalidate(11, filter_input = $$props.filter_input);
		if ('show_options' in $$props) $$invalidate(12, show_options = $$props.show_options);
		if ('choices_names' in $$props) $$invalidate(13, choices_names = $$props.choices_names);
		if ('choices_values' in $$props) $$invalidate(24, choices_values = $$props.choices_values);
		if ('input_text' in $$props) $$invalidate(8, input_text = $$props.input_text);
		if ('old_input_text' in $$props) $$invalidate(25, old_input_text = $$props.old_input_text);
		if ('initialized' in $$props) $$invalidate(26, initialized = $$props.initialized);
		if ('filtered_indices' in $$props) $$invalidate(9, filtered_indices = $$props.filtered_indices);
		if ('active_index' in $$props) $$invalidate(14, active_index = $$props.active_index);
		if ('selected_index' in $$props) $$invalidate(10, selected_index = $$props.selected_index);
		if ('old_selected_index' in $$props) $$invalidate(27, old_selected_index = $$props.old_selected_index);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*choices*/ 4) {
			{
				$$invalidate(13, choices_names = choices.map(c => c[0]));
				$$invalidate(24, choices_values = choices.map(c => c[1]));
			}
		}

		if ($$self.$$.dirty[0] & /*selected_index, old_selected_index, initialized, choices, choices_values*/ 218104836) {
			{
				if (selected_index !== old_selected_index && selected_index !== null && initialized) {
					$$invalidate(8, [input_text, value] = choices[selected_index], input_text, ((((($$invalidate(19, value), $$invalidate(10, selected_index)), $$invalidate(27, old_selected_index)), $$invalidate(26, initialized)), $$invalidate(2, choices)), $$invalidate(24, choices_values)));
					$$invalidate(27, old_selected_index = selected_index);

					dispatch("select", {
						index: selected_index,
						value: choices_values[selected_index],
						selected: true
					});
				}
			}
		}

		if ($$self.$$.dirty[0] & /*value, old_value, value_is_output*/ 5767168) {
			{
				if (value != old_value) {
					set_input_text();
					handle_change(dispatch, value, value_is_output);
					$$invalidate(22, old_value = value);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*choices, old_choices, input_text, old_input_text, allow_custom_value, filtered_indices*/ 41943876) {
			{
				if (choices !== old_choices || input_text !== old_input_text) {
					$$invalidate(9, filtered_indices = handle_filter(choices, input_text));
					$$invalidate(23, old_choices = choices);
					$$invalidate(25, old_input_text = input_text);

					if (!allow_custom_value && filtered_indices.length > 0) {
						$$invalidate(14, active_index = filtered_indices[0]);
					}
				}
			}
		}
	};

	return [
		label,
		info,
		choices,
		disabled,
		show_label,
		container,
		allow_custom_value,
		filterable,
		input_text,
		filtered_indices,
		selected_index,
		filter_input,
		show_options,
		choices_names,
		active_index,
		handle_option_selected,
		handle_focus,
		handle_blur,
		handle_key_down,
		value,
		value_is_output,
		i18n,
		old_value,
		old_choices,
		choices_values,
		old_input_text,
		initialized,
		old_selected_index,
		input_input_handler,
		input_binding
	];
}

class Dropdown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				label: 0,
				info: 1,
				value: 19,
				value_is_output: 20,
				choices: 2,
				disabled: 3,
				show_label: 4,
				container: 5,
				allow_custom_value: 6,
				i18n: 21,
				filterable: 7
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dropdown",
			options,
			id: create_fragment$1.name
		});
	}

	get label() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get info() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set info(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value_is_output() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value_is_output(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get choices() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set choices(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get allow_custom_value() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set allow_custom_value(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filterable() {
		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filterable(value) {
		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const Multiselect_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/dropdown/shared/Multiselect.svelte generated by Svelte v4.0.0 */
const file = "Users/peterallen/Projects/gradio/js/dropdown/shared/Multiselect.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[37] = list[i];
	return child_ctx;
}

// (184:1) <BlockTitle {show_label} {info}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(184:1) <BlockTitle {show_label} {info}>",
		ctx
	});

	return block;
}

// (199:6) {:else}
function create_else_block(ctx) {
	let t_value = /*s*/ ctx[37] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*selected_indices*/ 4096 && t_value !== (t_value = /*s*/ ctx[37] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(199:6) {:else}",
		ctx
	});

	return block;
}

// (197:6) {#if typeof s === "number"}
function create_if_block_3(ctx) {
	let t_value = /*choices_names*/ ctx[15][/*s*/ ctx[37]] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*choices_names, selected_indices*/ 36864 && t_value !== (t_value = /*choices_names*/ ctx[15][/*s*/ ctx[37]] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(197:6) {#if typeof s === \\\"number\\\"}",
		ctx
	});

	return block;
}

// (203:5) {#if !disabled}
function create_if_block_2(ctx) {
	let div;
	let remove;
	let div_title_value;
	let current;
	remove = new Remove({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(remove.$$.fragment);
			attr_dev(div, "class", "token-remove s-qxgXWZbpCA4E");
			attr_dev(div, "title", div_title_value = /*i18n*/ ctx[9]("common.remove") + " " + /*s*/ ctx[37]);
			add_location(div, file, 239, 6, 6210);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(remove, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*i18n, selected_indices*/ 4608 && div_title_value !== (div_title_value = /*i18n*/ ctx[9]("common.remove") + " " + /*s*/ ctx[37])) {
				attr_dev(div, "title", div_title_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(remove.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(remove.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(remove);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(203:5) {#if !disabled}",
		ctx
	});

	return block;
}

// (188:3) {#each selected_indices as s}
function create_each_block(ctx) {
	let div;
	let span;
	let t;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (typeof /*s*/ ctx[37] === "number") return create_if_block_3;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = !/*disabled*/ ctx[4] && create_if_block_2(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[30](/*s*/ ctx[37]);
	}

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "s-qxgXWZbpCA4E");
			add_location(span, file, 231, 5, 6066);
			attr_dev(div, "class", "token s-qxgXWZbpCA4E");
			add_location(div, file, 227, 4, 5968);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			if_block0.m(span, null);
			append_dev(div, t);
			if (if_block1) if_block1.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", prevent_default(click_handler), false, true, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(span, null);
				}
			}

			if (!/*disabled*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*disabled*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(188:3) {#each selected_indices as s}",
		ctx
	});

	return block;
}

// (228:4) {#if !disabled}
function create_if_block(ctx) {
	let t;
	let dropdownarrow;
	let current;
	let if_block = /*selected_indices*/ ctx[12].length > 0 && create_if_block_1(ctx);
	dropdownarrow = new DropdownArrow({ $$inline: true });

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			create_component(dropdownarrow.$$.fragment);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			mount_component(dropdownarrow, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*selected_indices*/ ctx[12].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*selected_indices*/ 4096) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(dropdownarrow.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(dropdownarrow.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}

			if (if_block) if_block.d(detaching);
			destroy_component(dropdownarrow, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(228:4) {#if !disabled}",
		ctx
	});

	return block;
}

// (229:5) {#if selected_indices.length > 0}
function create_if_block_1(ctx) {
	let div;
	let remove;
	let div_title_value;
	let current;
	let mounted;
	let dispose;
	remove = new Remove({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(remove.$$.fragment);
			attr_dev(div, "class", "token-remove remove-all s-qxgXWZbpCA4E");
			attr_dev(div, "title", div_title_value = /*i18n*/ ctx[9]("common.clear"));
			add_location(div, file, 265, 6, 6981);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(remove, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*remove_all*/ ctx[20], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*i18n*/ 512 && div_title_value !== (div_title_value = /*i18n*/ ctx[9]("common.clear"))) {
				attr_dev(div, "title", div_title_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(remove.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(remove.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(remove);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(229:5) {#if selected_indices.length > 0}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let label_1;
	let blocktitle;
	let t0;
	let div2;
	let div1;
	let t1;
	let div0;
	let input;
	let input_readonly_value;
	let t2;
	let t3;
	let dropdownoptions;
	let current;
	let mounted;
	let dispose;

	blocktitle = new BlockTitle({
			props: {
				show_label: /*show_label*/ ctx[5],
				info: /*info*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value = ensure_array_like_dev(/*selected_indices*/ ctx[12]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = !/*disabled*/ ctx[4] && create_if_block(ctx);

	dropdownoptions = new DropdownOptions({
			props: {
				show_options: /*show_options*/ ctx[14],
				choices: /*choices*/ ctx[3],
				filtered_indices: /*filtered_indices*/ ctx[11],
				disabled: /*disabled*/ ctx[4],
				selected_indices: /*selected_indices*/ ctx[12],
				active_index: /*active_index*/ ctx[16]
			},
			$$inline: true
		});

	dropdownoptions.$on("change", /*handle_option_selected*/ ctx[19]);

	const block = {
		c: function create() {
			label_1 = element("label");
			create_component(blocktitle.$$.fragment);
			t0 = space();
			div2 = element("div");
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div0 = element("div");
			input = element("input");
			t2 = space();
			if (if_block) if_block.c();
			t3 = space();
			create_component(dropdownoptions.$$.fragment);
			attr_dev(input, "class", "border-none s-qxgXWZbpCA4E");
			input.disabled = /*disabled*/ ctx[4];
			attr_dev(input, "autocomplete", "off");
			input.readOnly = input_readonly_value = !/*filterable*/ ctx[8];
			toggle_class(input, "subdued", !/*choices_names*/ ctx[15].includes(/*input_text*/ ctx[10]) && !/*allow_custom_value*/ ctx[7] || /*selected_indices*/ ctx[12].length === /*max_choices*/ ctx[2]);
			add_location(input, file, 246, 4, 6377);
			attr_dev(div0, "class", "secondary-wrap s-qxgXWZbpCA4E");
			add_location(div0, file, 245, 3, 6344);
			attr_dev(div1, "class", "wrap-inner s-qxgXWZbpCA4E");
			toggle_class(div1, "show_options", /*show_options*/ ctx[14]);
			add_location(div1, file, 222, 2, 5741);
			attr_dev(div2, "class", "wrap s-qxgXWZbpCA4E");
			add_location(div2, file, 221, 1, 5720);
			attr_dev(label_1, "class", "s-qxgXWZbpCA4E");
			toggle_class(label_1, "container", /*container*/ ctx[6]);
			add_location(label_1, file, 218, 0, 5640);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			mount_component(blocktitle, label_1, null);
			append_dev(label_1, t0);
			append_dev(label_1, div2);
			append_dev(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}

			append_dev(div1, t1);
			append_dev(div1, div0);
			append_dev(div0, input);
			set_input_value(input, /*input_text*/ ctx[10]);
			/*input_binding*/ ctx[32](input);
			append_dev(div0, t2);
			if (if_block) if_block.m(div0, null);
			append_dev(div2, t3);
			mount_component(dropdownoptions, div2, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[31]),
					listen_dev(input, "keydown", /*handle_key_down*/ ctx[22], false, false, false, false),
					listen_dev(input, "blur", /*handle_blur*/ ctx[17], false, false, false, false),
					listen_dev(input, "focus", /*handle_focus*/ ctx[21], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const blocktitle_changes = {};
			if (dirty[0] & /*show_label*/ 32) blocktitle_changes.show_label = /*show_label*/ ctx[5];
			if (dirty[0] & /*info*/ 2) blocktitle_changes.info = /*info*/ ctx[1];

			if (dirty[0] & /*label*/ 1 | dirty[1] & /*$$scope*/ 512) {
				blocktitle_changes.$$scope = { dirty, ctx };
			}

			blocktitle.$set(blocktitle_changes);

			if (dirty[0] & /*remove_selected_choice, selected_indices, i18n, disabled, choices_names*/ 299536) {
				each_value = ensure_array_like_dev(/*selected_indices*/ ctx[12]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, t1);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*disabled*/ 16) {
				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
			}

			if (!current || dirty[0] & /*filterable*/ 256 && input_readonly_value !== (input_readonly_value = !/*filterable*/ ctx[8])) {
				prop_dev(input, "readOnly", input_readonly_value);
			}

			if (dirty[0] & /*input_text*/ 1024 && input.value !== /*input_text*/ ctx[10]) {
				set_input_value(input, /*input_text*/ ctx[10]);
			}

			if (!current || dirty[0] & /*choices_names, input_text, allow_custom_value, selected_indices, max_choices*/ 38020) {
				toggle_class(input, "subdued", !/*choices_names*/ ctx[15].includes(/*input_text*/ ctx[10]) && !/*allow_custom_value*/ ctx[7] || /*selected_indices*/ ctx[12].length === /*max_choices*/ ctx[2]);
			}

			if (!/*disabled*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*disabled*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*show_options*/ 16384) {
				toggle_class(div1, "show_options", /*show_options*/ ctx[14]);
			}

			const dropdownoptions_changes = {};
			if (dirty[0] & /*show_options*/ 16384) dropdownoptions_changes.show_options = /*show_options*/ ctx[14];
			if (dirty[0] & /*choices*/ 8) dropdownoptions_changes.choices = /*choices*/ ctx[3];
			if (dirty[0] & /*filtered_indices*/ 2048) dropdownoptions_changes.filtered_indices = /*filtered_indices*/ ctx[11];
			if (dirty[0] & /*disabled*/ 16) dropdownoptions_changes.disabled = /*disabled*/ ctx[4];
			if (dirty[0] & /*selected_indices*/ 4096) dropdownoptions_changes.selected_indices = /*selected_indices*/ ctx[12];
			if (dirty[0] & /*active_index*/ 65536) dropdownoptions_changes.active_index = /*active_index*/ ctx[16];
			dropdownoptions.$set(dropdownoptions_changes);

			if (!current || dirty[0] & /*container*/ 64) {
				toggle_class(label_1, "container", /*container*/ ctx[6]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocktitle.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			transition_in(dropdownoptions.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocktitle.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			transition_out(dropdownoptions.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(label_1);
			}

			destroy_component(blocktitle);
			destroy_each(each_blocks, detaching);
			/*input_binding*/ ctx[32](null);
			if (if_block) if_block.d();
			destroy_component(dropdownoptions);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Multiselect', slots, []);
	let { label } = $$props;
	let { info = undefined } = $$props;
	let { value = [] } = $$props;
	let old_value = [];
	let { value_is_output = false } = $$props;
	let { max_choices = null } = $$props;
	let { choices } = $$props;
	let old_choices;
	let { disabled = false } = $$props;
	let { show_label } = $$props;
	let { container = true } = $$props;
	let { allow_custom_value = false } = $$props;
	let { filterable = true } = $$props;
	let { i18n } = $$props;
	let filter_input;
	let input_text = "";
	let old_input_text = "";
	let show_options = false;
	let choices_names;
	let choices_values;

	// All of these are indices with respect to the choices array
	let filtered_indices = [];

	let active_index = null;

	// selected_index consists of indices from choices or strings if allow_custom_value is true and user types in a custom value
	let selected_indices = [];

	let old_selected_index = [];
	const dispatch = createEventDispatcher();

	// Setting the initial value of the multiselect dropdown
	if (Array.isArray(value)) {
		value.forEach(element => {
			const index = choices.map(c => c[1]).indexOf(element);

			if (index !== -1) {
				selected_indices.push(index);
			} else {
				selected_indices.push(element);
			}
		});
	}

	function handle_blur() {
		if (!allow_custom_value) {
			$$invalidate(10, input_text = "");
		}

		if (allow_custom_value && input_text !== "") {
			add_selected_choice(input_text);
			$$invalidate(10, input_text = "");
		}

		$$invalidate(14, show_options = false);
		$$invalidate(16, active_index = null);
		dispatch("blur");
	}

	function remove_selected_choice(option_index) {
		$$invalidate(12, selected_indices = selected_indices.filter(v => v !== option_index));

		dispatch("select", {
			index: typeof option_index === "number" ? option_index : -1,
			value: typeof option_index === "number"
			? choices_values[option_index]
			: option_index,
			selected: false
		});
	}

	function add_selected_choice(option_index) {
		if (max_choices === null || selected_indices.length < max_choices) {
			$$invalidate(12, selected_indices = [...selected_indices, option_index]);

			dispatch("select", {
				index: typeof option_index === "number" ? option_index : -1,
				value: typeof option_index === "number"
				? choices_values[option_index]
				: option_index,
				selected: true
			});
		}

		if (selected_indices.length === max_choices) {
			$$invalidate(14, show_options = false);
			$$invalidate(16, active_index = null);
			filter_input.blur();
		}
	}

	function handle_option_selected(e) {
		const option_index = parseInt(e.detail.target.dataset.index);
		add_or_remove_index(option_index);
	}

	function add_or_remove_index(option_index) {
		if (selected_indices.includes(option_index)) {
			remove_selected_choice(option_index);
		} else {
			add_selected_choice(option_index);
		}

		$$invalidate(10, input_text = "");
	}

	function remove_all(e) {
		$$invalidate(12, selected_indices = []);
		$$invalidate(10, input_text = "");
		e.preventDefault();
	}

	function handle_focus(e) {
		$$invalidate(11, filtered_indices = choices.map((_, i) => i));

		if (max_choices === null || selected_indices.length < max_choices) {
			$$invalidate(14, show_options = true);
		}

		dispatch("focus");
	}

	function handle_key_down(e) {
		$$invalidate(14, [show_options, active_index] = handle_shared_keys(e, active_index, filtered_indices), show_options, (((((($$invalidate(16, active_index), $$invalidate(3, choices)), $$invalidate(26, old_choices)), $$invalidate(10, input_text)), $$invalidate(27, old_input_text)), $$invalidate(7, allow_custom_value)), $$invalidate(11, filtered_indices)));

		if (e.key === "Enter") {
			if (active_index !== null) {
				add_or_remove_index(active_index);
			} else {
				if (allow_custom_value) {
					add_selected_choice(input_text);
					$$invalidate(10, input_text = "");
				}
			}
		}

		if (e.key === "Backspace" && input_text === "") {
			$$invalidate(12, selected_indices = [...selected_indices.slice(0, -1)]);
		}

		if (selected_indices.length === max_choices) {
			$$invalidate(14, show_options = false);
			$$invalidate(16, active_index = null);
		}
	}

	function set_selected_indices() {
		if (value === undefined) {
			$$invalidate(12, selected_indices = []);
		} else if (Array.isArray(value)) {
			$$invalidate(12, selected_indices = value.map(v => {
				const index = choices_values.indexOf(v);

				if (index !== -1) {
					return index;
				}

				if (allow_custom_value) {
					return v;
				}

				// Instead of returning null, skip this iteration
				return undefined;
			}).filter(val => val !== undefined));
		}
	}

	afterUpdate(() => {
		$$invalidate(24, value_is_output = false);
	});

	$$self.$$.on_mount.push(function () {
		if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
			console.warn("<Multiselect> was created without expected prop 'label'");
		}

		if (choices === undefined && !('choices' in $$props || $$self.$$.bound[$$self.$$.props['choices']])) {
			console.warn("<Multiselect> was created without expected prop 'choices'");
		}

		if (show_label === undefined && !('show_label' in $$props || $$self.$$.bound[$$self.$$.props['show_label']])) {
			console.warn("<Multiselect> was created without expected prop 'show_label'");
		}

		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console.warn("<Multiselect> was created without expected prop 'i18n'");
		}
	});

	const writable_props = [
		'label',
		'info',
		'value',
		'value_is_output',
		'max_choices',
		'choices',
		'disabled',
		'show_label',
		'container',
		'allow_custom_value',
		'filterable',
		'i18n'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Multiselect> was created with unknown prop '${key}'`);
	});

	const click_handler = s => remove_selected_choice(s);

	function input_input_handler() {
		input_text = this.value;
		$$invalidate(10, input_text);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			filter_input = $$value;
			$$invalidate(13, filter_input);
		});
	}

	$$self.$$set = $$props => {
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('info' in $$props) $$invalidate(1, info = $$props.info);
		if ('value' in $$props) $$invalidate(23, value = $$props.value);
		if ('value_is_output' in $$props) $$invalidate(24, value_is_output = $$props.value_is_output);
		if ('max_choices' in $$props) $$invalidate(2, max_choices = $$props.max_choices);
		if ('choices' in $$props) $$invalidate(3, choices = $$props.choices);
		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ('show_label' in $$props) $$invalidate(5, show_label = $$props.show_label);
		if ('container' in $$props) $$invalidate(6, container = $$props.container);
		if ('allow_custom_value' in $$props) $$invalidate(7, allow_custom_value = $$props.allow_custom_value);
		if ('filterable' in $$props) $$invalidate(8, filterable = $$props.filterable);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		createEventDispatcher,
		_: X,
		number: ne,
		BlockTitle,
		Remove,
		DropdownArrow,
		DropdownOptions,
		handle_filter,
		handle_change,
		handle_shared_keys,
		label,
		info,
		value,
		old_value,
		value_is_output,
		max_choices,
		choices,
		old_choices,
		disabled,
		show_label,
		container,
		allow_custom_value,
		filterable,
		i18n,
		filter_input,
		input_text,
		old_input_text,
		show_options,
		choices_names,
		choices_values,
		filtered_indices,
		active_index,
		selected_indices,
		old_selected_index,
		dispatch,
		handle_blur,
		remove_selected_choice,
		add_selected_choice,
		handle_option_selected,
		add_or_remove_index,
		remove_all,
		handle_focus,
		handle_key_down,
		set_selected_indices
	});

	$$self.$inject_state = $$props => {
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('info' in $$props) $$invalidate(1, info = $$props.info);
		if ('value' in $$props) $$invalidate(23, value = $$props.value);
		if ('old_value' in $$props) $$invalidate(25, old_value = $$props.old_value);
		if ('value_is_output' in $$props) $$invalidate(24, value_is_output = $$props.value_is_output);
		if ('max_choices' in $$props) $$invalidate(2, max_choices = $$props.max_choices);
		if ('choices' in $$props) $$invalidate(3, choices = $$props.choices);
		if ('old_choices' in $$props) $$invalidate(26, old_choices = $$props.old_choices);
		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ('show_label' in $$props) $$invalidate(5, show_label = $$props.show_label);
		if ('container' in $$props) $$invalidate(6, container = $$props.container);
		if ('allow_custom_value' in $$props) $$invalidate(7, allow_custom_value = $$props.allow_custom_value);
		if ('filterable' in $$props) $$invalidate(8, filterable = $$props.filterable);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
		if ('filter_input' in $$props) $$invalidate(13, filter_input = $$props.filter_input);
		if ('input_text' in $$props) $$invalidate(10, input_text = $$props.input_text);
		if ('old_input_text' in $$props) $$invalidate(27, old_input_text = $$props.old_input_text);
		if ('show_options' in $$props) $$invalidate(14, show_options = $$props.show_options);
		if ('choices_names' in $$props) $$invalidate(15, choices_names = $$props.choices_names);
		if ('choices_values' in $$props) $$invalidate(28, choices_values = $$props.choices_values);
		if ('filtered_indices' in $$props) $$invalidate(11, filtered_indices = $$props.filtered_indices);
		if ('active_index' in $$props) $$invalidate(16, active_index = $$props.active_index);
		if ('selected_indices' in $$props) $$invalidate(12, selected_indices = $$props.selected_indices);
		if ('old_selected_index' in $$props) $$invalidate(29, old_selected_index = $$props.old_selected_index);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*choices*/ 8) {
			{
				$$invalidate(15, choices_names = choices.map(c => c[0]));
				$$invalidate(28, choices_values = choices.map(c => c[1]));
			}
		}

		if ($$self.$$.dirty[0] & /*choices, old_choices, input_text, old_input_text, allow_custom_value, filtered_indices*/ 201329800) {
			{
				if (choices !== old_choices || input_text !== old_input_text) {
					$$invalidate(11, filtered_indices = handle_filter(choices, input_text));
					$$invalidate(26, old_choices = choices);
					$$invalidate(27, old_input_text = input_text);

					if (!allow_custom_value) {
						$$invalidate(16, active_index = filtered_indices[0]);
					}
				}
			}
		}

		if ($$self.$$.dirty[0] & /*selected_indices, old_selected_index, choices_values*/ 805310464) {
			{
				if (JSON.stringify(selected_indices) != JSON.stringify(old_selected_index)) {
					$$invalidate(23, value = selected_indices.map(index => typeof index === "number"
					? choices_values[index]
					: index));

					$$invalidate(29, old_selected_index = selected_indices.slice());
				}
			}
		}

		if ($$self.$$.dirty[0] & /*value, old_value, value_is_output*/ 58720256) {
			{
				if (JSON.stringify(value) != JSON.stringify(old_value)) {
					handle_change(dispatch, value, value_is_output);
					$$invalidate(25, old_value = Array.isArray(value) ? value.slice() : value);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*value*/ 8388608) {
			(set_selected_indices());
		}
	};

	return [
		label,
		info,
		max_choices,
		choices,
		disabled,
		show_label,
		container,
		allow_custom_value,
		filterable,
		i18n,
		input_text,
		filtered_indices,
		selected_indices,
		filter_input,
		show_options,
		choices_names,
		active_index,
		handle_blur,
		remove_selected_choice,
		handle_option_selected,
		remove_all,
		handle_focus,
		handle_key_down,
		value,
		value_is_output,
		old_value,
		old_choices,
		old_input_text,
		choices_values,
		old_selected_index,
		click_handler,
		input_input_handler,
		input_binding
	];
}

class Multiselect extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				label: 0,
				info: 1,
				value: 23,
				value_is_output: 24,
				max_choices: 2,
				choices: 3,
				disabled: 4,
				show_label: 5,
				container: 6,
				allow_custom_value: 7,
				filterable: 8,
				i18n: 9
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Multiselect",
			options,
			id: create_fragment.name
		});
	}

	get label() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get info() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set info(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value_is_output() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value_is_output(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max_choices() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max_choices(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get choices() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set choices(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get allow_custom_value() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set allow_custom_value(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filterable() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filterable(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<Multiselect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<Multiselect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Dropdown as D, Multiselect as M };
//# sourceMappingURL=Multiselect-4d348364.js.map
