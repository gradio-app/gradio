import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, svg_element, attr_dev, add_location, insert_dev, append_dev, noop, detach_dev, text, onDestroy, globals, element, space, listen_dev, transition_in, group_outros, transition_out, check_outros, create_component, mount_component, destroy_component, createEventDispatcher, beforeUpdate, afterUpdate, ensure_array_like_dev, action_destroyer, bubble, binding_callbacks, empty, destroy_each, toggle_class, src_url_equal, run_all, set_data_dev, assign, get_spread_update, get_spread_object } from './svelte/svelte-internal.js';
import { u as uploadToHuggingFace, d as copy, g as get_fetchable_url_or_file, B as Block, n as normalise_file } from './Button-153ea7e7.js';
import { S as ShareButton } from './ShareButton-67809009.js';
import { M as MarkdownCode } from './StaticMarkdown-08860037.js';
import { S as Static } from './index-30423ace.js';
import { C as Copy, a as Check } from './Copy-51753e2b.js';
import { B as BlockLabel } from './BlockLabel-6e86bddb.js';
import './IconButton-a7cec4e3.js';

/* Users/peterallen/Projects/gradio/js/icons/src/Chat.svelte generated by Svelte v4.0.0 */

const file$5 = "Users/peterallen/Projects/gradio/js/icons/src/Chat.svelte";

function create_fragment$5(ctx) {
	let svg;
	let path0;
	let path1;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "fill", "currentColor");
			attr_dev(path0, "d", "M17.74 30L16 29l4-7h6a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h9v2H6a4 4 0 0 1-4-4V8a4 4 0 0 1 4-4h20a4 4 0 0 1 4 4v12a4 4 0 0 1-4 4h-4.84Z");
			add_location(path0, file$5, 11, 1, 240);
			attr_dev(path1, "fill", "currentColor");
			attr_dev(path1, "d", "M8 10h16v2H8zm0 6h10v2H8z");
			add_location(path1, file$5, 15, 1, 441);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "class", "iconify iconify--carbon");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "preserveAspectRatio", "xMidYMid meet");
			attr_dev(svg, "viewBox", "0 0 32 32");
			add_location(svg, file$5, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Chat', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chat> was created with unknown prop '${key}'`);
	});

	return [];
}

class Chat extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Chat",
			options,
			id: create_fragment$5.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Dislike.svelte generated by Svelte v4.0.0 */

const file$4 = "Users/peterallen/Projects/gradio/js/icons/src/Dislike.svelte";

function create_fragment$4(ctx) {
	let svg;
	let g0;
	let g1;
	let g5;
	let title;
	let t0;
	let desc;
	let t1;
	let defs;
	let g4;
	let g3;
	let g2;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			g0 = svg_element("g");
			g1 = svg_element("g");
			g5 = svg_element("g");
			title = svg_element("title");
			t0 = text("dislike [#1388]");
			desc = svg_element("desc");
			t1 = text("Created with Sketch.");
			defs = svg_element("defs");
			g4 = svg_element("g");
			g3 = svg_element("g");
			g2 = svg_element("g");
			path = svg_element("path");
			attr_dev(g0, "id", "SVGRepo_bgCarrier");
			attr_dev(g0, "stroke-width", "0");
			add_location(g0, file$4, 8, 2, 174);
			attr_dev(g1, "id", "SVGRepo_tracerCarrier");
			attr_dev(g1, "stroke-linecap", "round");
			attr_dev(g1, "stroke-linejoin", "round");
			add_location(g1, file$4, 8, 49, 221);
			add_location(title, file$4, 13, 2, 341);
			add_location(desc, file$4, 13, 33, 372);
			add_location(defs, file$4, 14, 2, 408);
			attr_dev(path, "d", "M101.900089,600 L99.8000892,600 L99.8000892,611.987622 L101.900089,611.987622 C103.060339,611.987622 104.000088,611.093545 104.000088,609.989685 L104.000088,601.997937 C104.000088,600.894077 103.060339,600 101.900089,600 M87.6977917,600 L97.7000896,600 L97.7000896,611.987622 L95.89514,618.176232 C95.6819901,619.491874 94.2455904,620.374962 92.7902907,619.842512 C91.9198408,619.52484 91.400091,618.66273 91.400091,617.774647 L91.400091,612.986591 C91.400091,612.43516 90.9296911,611.987622 90.3500912,611.987622 L85.8728921,611.987622 C84.0259425,611.987622 82.6598928,610.35331 83.0746427,608.641078 L84.8995423,602.117813 C85.1998423,600.878093 86.360092,600 87.6977917,600");
			attr_dev(path, "id", "dislike-[#1388]");
			add_location(path, file$4, 28, 5, 710);
			attr_dev(g2, "id", "icons");
			attr_dev(g2, "transform", "translate(56.000000, 160.000000)");
			add_location(g2, file$4, 27, 4, 645);
			attr_dev(g3, "id", "Dribbble-Light-Preview");
			attr_dev(g3, "transform", "translate(-139.000000, -760.000000)");
			attr_dev(g3, "fill", "currentColor");
			add_location(g3, file$4, 22, 3, 525);
			attr_dev(g4, "id", "Page-1");
			attr_dev(g4, "stroke", "none");
			attr_dev(g4, "stroke-width", "1");
			attr_dev(g4, "fill", "none");
			attr_dev(g4, "fill-rule", "evenodd");
			add_location(g4, file$4, 15, 2, 425);
			attr_dev(g5, "id", "SVGRepo_iconCarrier");
			add_location(g5, file$4, 12, 6, 310);
			attr_dev(svg, "viewBox", "0 -3 32 32");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "version", "1.1");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr_dev(svg, "fill", "currentColor");
			add_location(svg, file$4, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, g0);
			append_dev(svg, g1);
			append_dev(svg, g5);
			append_dev(g5, title);
			append_dev(title, t0);
			append_dev(g5, desc);
			append_dev(desc, t1);
			append_dev(g5, defs);
			append_dev(g5, g4);
			append_dev(g4, g3);
			append_dev(g3, g2);
			append_dev(g2, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Dislike', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dislike> was created with unknown prop '${key}'`);
	});

	return [];
}

class Dislike extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dislike",
			options,
			id: create_fragment$4.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Like.svelte generated by Svelte v4.0.0 */

const file$3 = "Users/peterallen/Projects/gradio/js/icons/src/Like.svelte";

function create_fragment$3(ctx) {
	let svg;
	let g0;
	let g1;
	let g5;
	let title;
	let t0;
	let desc;
	let t1;
	let defs;
	let g4;
	let g3;
	let g2;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			g0 = svg_element("g");
			g1 = svg_element("g");
			g5 = svg_element("g");
			title = svg_element("title");
			t0 = text("like [#1385]");
			desc = svg_element("desc");
			t1 = text("Created with Sketch.");
			defs = svg_element("defs");
			g4 = svg_element("g");
			g3 = svg_element("g");
			g2 = svg_element("g");
			path = svg_element("path");
			attr_dev(g0, "id", "SVGRepo_bgCarrier");
			attr_dev(g0, "stroke-width", "0");
			add_location(g0, file$3, 8, 2, 173);
			attr_dev(g1, "id", "SVGRepo_tracerCarrier");
			attr_dev(g1, "stroke-linecap", "round");
			attr_dev(g1, "stroke-linejoin", "round");
			add_location(g1, file$3, 8, 49, 220);
			add_location(title, file$3, 13, 2, 340);
			add_location(desc, file$3, 13, 30, 368);
			add_location(defs, file$3, 13, 64, 402);
			attr_dev(path, "d", "M203,620 L207.200006,620 L207.200006,608 L203,608 L203,620 Z M223.924431,611.355 L222.100579,617.89 C221.799228,619.131 220.638976,620 219.302324,620 L209.300009,620 L209.300009,608.021 L211.104962,601.825 C211.274012,600.775 212.223214,600 213.339366,600 C214.587817,600 215.600019,600.964 215.600019,602.153 L215.600019,608 L221.126177,608 C222.97313,608 224.340232,609.641 223.924431,611.355 L223.924431,611.355 Z");
			attr_dev(path, "id", "like-[#1385]");
			add_location(path, file$3, 27, 5, 704);
			attr_dev(g2, "id", "icons");
			attr_dev(g2, "transform", "translate(56.000000, 160.000000)");
			add_location(g2, file$3, 26, 4, 639);
			attr_dev(g3, "id", "Dribbble-Light-Preview");
			attr_dev(g3, "transform", "translate(-259.000000, -760.000000)");
			attr_dev(g3, "fill", "currentColor");
			add_location(g3, file$3, 21, 3, 519);
			attr_dev(g4, "id", "Page-1");
			attr_dev(g4, "stroke", "none");
			attr_dev(g4, "stroke-width", "1");
			attr_dev(g4, "fill", "none");
			attr_dev(g4, "fill-rule", "evenodd");
			add_location(g4, file$3, 14, 2, 419);
			attr_dev(g5, "id", "SVGRepo_iconCarrier");
			add_location(g5, file$3, 12, 6, 309);
			attr_dev(svg, "viewBox", "0 0 32 32");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "version", "1.1");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr_dev(svg, "fill", "currentColor");
			add_location(svg, file$3, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, g0);
			append_dev(svg, g1);
			append_dev(svg, g5);
			append_dev(g5, title);
			append_dev(title, t0);
			append_dev(g5, desc);
			append_dev(desc, t1);
			append_dev(g5, defs);
			append_dev(g5, g4);
			append_dev(g4, g3);
			append_dev(g3, g2);
			append_dev(g2, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Like', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Like> was created with unknown prop '${key}'`);
	});

	return [];
}

class Like extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Like",
			options,
			id: create_fragment$3.name
		});
	}
}

const format_chat_for_sharing = async (chat) => {
  let messages = await Promise.all(
    chat.map(async (message_pair) => {
      return await Promise.all(
        message_pair.map(async (message, i) => {
          if (message === null)
            return "";
          let speaker_emoji = i === 0 ? "ðŸ˜ƒ" : "ðŸ¤–";
          let html_content = "";
          if (typeof message === "string") {
            const regexPatterns = {
              audio: /<audio.*?src="(\/file=.*?)"/g,
              video: /<video.*?src="(\/file=.*?)"/g,
              image: /<img.*?src="(\/file=.*?)".*?\/>|!\[.*?\]\((\/file=.*?)\)/g
            };
            html_content = message;
            for (let [_, regex] of Object.entries(regexPatterns)) {
              let match;
              while ((match = regex.exec(message)) !== null) {
                const fileUrl = match[1] || match[2];
                const newUrl = await uploadToHuggingFace(fileUrl, "url");
                html_content = html_content.replace(fileUrl, newUrl);
              }
            }
          } else {
            const file_url = await uploadToHuggingFace(message.data, "url");
            if (message.mime_type?.includes("audio")) {
              html_content = `<audio controls src="${file_url}"></audio>`;
            } else if (message.mime_type?.includes("video")) {
              html_content = file_url;
            } else if (message.mime_type?.includes("image")) {
              html_content = `<img src="${file_url}" />`;
            }
          }
          return `${speaker_emoji}: ${html_content}`;
        })
      );
    })
  );
  return messages.map(
    (message_pair) => message_pair.join(
      message_pair[0] !== "" && message_pair[1] !== "" ? "\n" : ""
    )
  ).join("\n");
};

const Copy_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/chatbot/static/Copy.svelte generated by Svelte v4.0.0 */

const { console: console_1 } = globals;
const file$2 = "Users/peterallen/Projects/gradio/js/chatbot/static/Copy.svelte";

// (45:1) {#if !copied}
function create_if_block_1$2(ctx) {
	let span;
	let copy;
	let current;
	copy = new Copy({ $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(copy.$$.fragment);
			add_location(span, file$2, 48, 2, 1089);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(copy, span, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(copy.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(copy.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			destroy_component(copy);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(45:1) {#if !copied}",
		ctx
	});

	return block;
}

// (48:1) {#if copied}
function create_if_block$2(ctx) {
	let span;
	let check;
	let current;
	check = new Check({ $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(check.$$.fragment);
			add_location(span, file$2, 51, 2, 1135);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(check, span, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(check.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(check.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			destroy_component(check);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(48:1) {#if copied}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let button;
	let t;
	let current;
	let mounted;
	let dispose;
	let if_block0 = !/*copied*/ ctx[0] && create_if_block_1$2(ctx);
	let if_block1 = /*copied*/ ctx[0] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			button = element("button");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(button, "title", "copy");
			attr_dev(button, "class", "s-oaLqunO3Pj6P");
			add_location(button, file$2, 46, 0, 1027);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append_dev(button, t);
			if (if_block1) if_block1.m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*handle_copy*/ ctx[1], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!/*copied*/ ctx[0]) {
				if (if_block0) {
					if (dirty & /*copied*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(button, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*copied*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*copied*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Copy', slots, []);
	let copied = false;
	let { value } = $$props;
	let timer;

	function copy_feedback() {
		$$invalidate(0, copied = true);
		if (timer) clearTimeout(timer);

		timer = setTimeout(
			() => {
				$$invalidate(0, copied = false);
			},
			2000
		);
	}

	async function handle_copy() {
		if ("clipboard" in navigator) {
			await navigator.clipboard.writeText(value);
			copy_feedback();
		} else {
			const textArea = document.createElement("textarea");
			textArea.value = value;
			textArea.style.position = "absolute";
			textArea.style.left = "-999999px";
			document.body.prepend(textArea);
			textArea.select();

			try {
				document.execCommand("copy");
				copy_feedback();
			} catch(error) {
				console.error(error);
			} finally {
				textArea.remove();
			}
		}
	}

	onDestroy(() => {
		if (timer) clearTimeout(timer);
	});

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console_1.warn("<Copy> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Copy> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(2, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		onDestroy,
		Copy,
		Check,
		copied,
		value,
		timer,
		copy_feedback,
		handle_copy
	});

	$$self.$inject_state = $$props => {
		if ('copied' in $$props) $$invalidate(0, copied = $$props.copied);
		if ('value' in $$props) $$invalidate(2, value = $$props.value);
		if ('timer' in $$props) timer = $$props.timer;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [copied, handle_copy, value];
}

class Copy_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { value: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Copy_1",
			options,
			id: create_fragment$2.name
		});
	}

	get value() {
		throw new Error("<Copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const ChatBot_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/chatbot/static/ChatBot.svelte generated by Svelte v4.0.0 */
const file$1 = "Users/peterallen/Projects/gradio/js/chatbot/static/ChatBot.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[36] = list[i];
	child_ctx[38] = i;
	return child_ctx;
}

// (67:0) {#if show_share_button && value !== null && value.length > 0}
function create_if_block_10(ctx) {
	let div_1;
	let sharebutton;
	let current;

	sharebutton = new ShareButton({
			props: {
				i18n: /*i18n*/ ctx[13],
				formatter: format_chat_for_sharing,
				value: /*value*/ ctx[0]
			},
			$$inline: true
		});

	sharebutton.$on("error", /*error_handler*/ ctx[25]);
	sharebutton.$on("share", /*share_handler*/ ctx[26]);

	const block = {
		c: function create() {
			div_1 = element("div");
			create_component(sharebutton.$$.fragment);
			attr_dev(div_1, "class", "share-button s-4CGYAZFhuluy");
			add_location(div_1, file$1, 107, 1, 1818);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div_1, anchor);
			mount_component(sharebutton, div_1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sharebutton_changes = {};
			if (dirty[0] & /*i18n*/ 8192) sharebutton_changes.i18n = /*i18n*/ ctx[13];
			if (dirty[0] & /*value*/ 1) sharebutton_changes.value = /*value*/ ctx[0];
			sharebutton.$set(sharebutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sharebutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sharebutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div_1);
			}

			destroy_component(sharebutton);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(67:0) {#if show_share_button && value !== null && value.length > 0}",
		ctx
	});

	return block;
}

// (81:2) {#if value !== null}
function create_if_block_1$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like_dev(/*value*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value, rtl, bubble_full_width, selectable, handle_select, latex_delimiters, sanitize_html, scroll, show_copy_button, handle_like, likeable, avatar_images, root, root_url*/ 237531) {
				each_value = ensure_array_like_dev(/*value*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(81:2) {#if value !== null}",
		ctx
	});

	return block;
}

// (88:6) {#if avatar_images[j] !== null}
function create_if_block_9(ctx) {
	let div_1;
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			div_1 = element("div");
			img = element("img");
			attr_dev(img, "class", "avatar-image s-4CGYAZFhuluy");
			if (!src_url_equal(img.src, img_src_value = get_fetchable_url_or_file(/*avatar_images*/ ctx[8][/*j*/ ctx[38]], /*root*/ ctx[11], /*root_url*/ ctx[12]))) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "avatar-" + (/*j*/ ctx[38] == 0 ? 'user' : 'bot'));
			add_location(img, file$1, 129, 8, 2331);
			attr_dev(div_1, "class", "avatar-container s-4CGYAZFhuluy");
			add_location(div_1, file$1, 128, 7, 2292);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div_1, anchor);
			append_dev(div_1, img);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*avatar_images, root, root_url*/ 6400 && !src_url_equal(img.src, img_src_value = get_fetchable_url_or_file(/*avatar_images*/ ctx[8][/*j*/ ctx[38]], /*root*/ ctx[11], /*root_url*/ ctx[12]))) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div_1);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(88:6) {#if avatar_images[j] !== null}",
		ctx
	});

	return block;
}

// (118:8) {#if likeable && j == 1}
function create_if_block_8(ctx) {
	let div_1;
	let button0;
	let like;
	let t;
	let button1;
	let dislike;
	let current;
	let mounted;
	let dispose;
	like = new Like({ $$inline: true });

	function click_handler() {
		return /*click_handler*/ ctx[27](/*i*/ ctx[35], /*j*/ ctx[38], /*message*/ ctx[36]);
	}

	dislike = new Dislike({ $$inline: true });

	function click_handler_1() {
		return /*click_handler_1*/ ctx[28](/*i*/ ctx[35], /*j*/ ctx[38], /*message*/ ctx[36]);
	}

	const block = {
		c: function create() {
			div_1 = element("div");
			button0 = element("button");
			create_component(like.$$.fragment);
			t = space();
			button1 = element("button");
			create_component(dislike.$$.fragment);
			attr_dev(button0, "class", "s-4CGYAZFhuluy");
			add_location(button0, file$1, 159, 10, 3275);
			attr_dev(button1, "class", "s-4CGYAZFhuluy");
			add_location(button1, file$1, 162, 10, 3384);
			attr_dev(div_1, "class", "like s-4CGYAZFhuluy");
			add_location(div_1, file$1, 158, 9, 3246);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div_1, anchor);
			append_dev(div_1, button0);
			mount_component(like, button0, null);
			append_dev(div_1, t);
			append_dev(div_1, button1);
			mount_component(dislike, button1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", click_handler, false, false, false, false),
					listen_dev(button1, "click", click_handler_1, false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(like.$$.fragment, local);
			transition_in(dislike.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(like.$$.fragment, local);
			transition_out(dislike.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div_1);
			}

			destroy_component(like);
			destroy_component(dislike);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(118:8) {#if likeable && j == 1}",
		ctx
	});

	return block;
}

// (129:8) {#if show_copy_button && message && typeof message === "string"}
function create_if_block_7(ctx) {
	let div_1;
	let copy_1;
	let current;

	copy_1 = new Copy_1({
			props: { value: /*message*/ ctx[36] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div_1 = element("div");
			create_component(copy_1.$$.fragment);
			attr_dev(div_1, "class", "copy-button s-4CGYAZFhuluy");
			add_location(div_1, file$1, 169, 9, 3600);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div_1, anchor);
			mount_component(copy_1, div_1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const copy_1_changes = {};
			if (dirty[0] & /*value*/ 1) copy_1_changes.value = /*message*/ ctx[36];
			copy_1.$set(copy_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(copy_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(copy_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div_1);
			}

			destroy_component(copy_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(129:8) {#if show_copy_button && message && typeof message === \\\"string\\\"}",
		ctx
	});

	return block;
}

// (172:64) 
function create_if_block_6(ctx) {
	let a;
	let t_value = (/*message*/ ctx[36].file.orig_name || /*message*/ ctx[36].file.name) + "";
	let t;
	let a_href_value;
	let a_download_value;

	const block = {
		c: function create() {
			a = element("a");
			t = text(t_value);
			attr_dev(a, "data-testid", "chatbot-file");
			attr_dev(a, "href", a_href_value = /*message*/ ctx[36].file.data);
			attr_dev(a, "target", "_blank");

			attr_dev(a, "download", a_download_value = window.__is_colab__
			? null
			: /*message*/ ctx[36].file.orig_name || /*message*/ ctx[36].file.name);

			attr_dev(a, "class", "s-4CGYAZFhuluy");
			add_location(a, file$1, 212, 8, 4817);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && t_value !== (t_value = (/*message*/ ctx[36].file.orig_name || /*message*/ ctx[36].file.name) + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*value*/ 1 && a_href_value !== (a_href_value = /*message*/ ctx[36].file.data)) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty[0] & /*value*/ 1 && a_download_value !== (a_download_value = window.__is_colab__
			? null
			: /*message*/ ctx[36].file.orig_name || /*message*/ ctx[36].file.name)) {
				attr_dev(a, "download", a_download_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(172:64) ",
		ctx
	});

	return block;
}

// (166:79) 
function create_if_block_5(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "data-testid", "chatbot-image");
			if (!src_url_equal(img.src, img_src_value = /*message*/ ctx[36].file.data)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*message*/ ctx[36].alt_text);
			attr_dev(img, "class", "s-4CGYAZFhuluy");
			add_location(img, file$1, 206, 8, 4626);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(img.src, img_src_value = /*message*/ ctx[36].file.data)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*value*/ 1 && img_alt_value !== (img_alt_value = /*message*/ ctx[36].alt_text)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(166:79) ",
		ctx
	});

	return block;
}

// (153:79) 
function create_if_block_4(ctx) {
	let video;
	let track;
	let video_src_value;
	let video_title_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			video = element("video");
			track = element("track");
			attr_dev(track, "kind", "captions");
			attr_dev(track, "class", "s-4CGYAZFhuluy");
			add_location(track, file$1, 203, 9, 4495);
			attr_dev(video, "data-testid", "chatbot-video");
			video.controls = true;
			if (!src_url_equal(video.src, video_src_value = /*message*/ ctx[36].file.data)) attr_dev(video, "src", video_src_value);
			attr_dev(video, "title", video_title_value = /*message*/ ctx[36].alt_text);
			attr_dev(video, "preload", "auto");
			attr_dev(video, "class", "s-4CGYAZFhuluy");
			add_location(video, file$1, 193, 8, 4270);
		},
		m: function mount(target, anchor) {
			insert_dev(target, video, anchor);
			append_dev(video, track);

			if (!mounted) {
				dispose = [
					listen_dev(video, "play", /*play_handler_1*/ ctx[22], false, false, false, false),
					listen_dev(video, "pause", /*pause_handler_1*/ ctx[23], false, false, false, false),
					listen_dev(video, "ended", /*ended_handler_1*/ ctx[24], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(video.src, video_src_value = /*message*/ ctx[36].file.data)) {
				attr_dev(video, "src", video_src_value);
			}

			if (dirty[0] & /*value*/ 1 && video_title_value !== (video_title_value = /*message*/ ctx[36].alt_text)) {
				attr_dev(video, "title", video_title_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(video);
			}

			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(153:79) ",
		ctx
	});

	return block;
}

// (142:79) 
function create_if_block_3(ctx) {
	let audio;
	let audio_src_value;
	let audio_title_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			audio = element("audio");
			attr_dev(audio, "data-testid", "chatbot-audio");
			audio.controls = true;
			attr_dev(audio, "preload", "metadata");
			if (!src_url_equal(audio.src, audio_src_value = /*message*/ ctx[36].file.data)) attr_dev(audio, "src", audio_src_value);
			attr_dev(audio, "title", audio_title_value = /*message*/ ctx[36].alt_text);
			attr_dev(audio, "class", "s-4CGYAZFhuluy");
			add_location(audio, file$1, 182, 8, 3961);
		},
		m: function mount(target, anchor) {
			insert_dev(target, audio, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(audio, "play", /*play_handler*/ ctx[19], false, false, false, false),
					listen_dev(audio, "pause", /*pause_handler*/ ctx[20], false, false, false, false),
					listen_dev(audio, "ended", /*ended_handler*/ ctx[21], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(audio.src, audio_src_value = /*message*/ ctx[36].file.data)) {
				attr_dev(audio, "src", audio_src_value);
			}

			if (dirty[0] & /*value*/ 1 && audio_title_value !== (audio_title_value = /*message*/ ctx[36].alt_text)) {
				attr_dev(audio, "title", audio_title_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(audio);
			}

			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(142:79) ",
		ctx
	});

	return block;
}

// (135:7) {#if typeof message === "string"}
function create_if_block_2(ctx) {
	let markdown;
	let current;

	markdown = new MarkdownCode({
			props: {
				message: /*message*/ ctx[36],
				latex_delimiters: /*latex_delimiters*/ ctx[1],
				sanitize_html: /*sanitize_html*/ ctx[9]
			},
			$$inline: true
		});

	markdown.$on("load", /*scroll*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(markdown.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(markdown, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const markdown_changes = {};
			if (dirty[0] & /*value*/ 1) markdown_changes.message = /*message*/ ctx[36];
			if (dirty[0] & /*latex_delimiters*/ 2) markdown_changes.latex_delimiters = /*latex_delimiters*/ ctx[1];
			if (dirty[0] & /*sanitize_html*/ 512) markdown_changes.sanitize_html = /*sanitize_html*/ ctx[9];
			markdown.$set(markdown_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(markdown.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(markdown.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(markdown, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(135:7) {#if typeof message === \\\"string\\\"}",
		ctx
	});

	return block;
}

// (83:4) {#each message_pair as message, j}
function create_each_block_1(ctx) {
	let div2;
	let t0;
	let div1;
	let div0;
	let t1;
	let t2;
	let show_if;
	let show_if_1;
	let show_if_2;
	let current_block_type_index;
	let if_block3;
	let div1_dir_value;
	let t3;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*avatar_images*/ ctx[8][/*j*/ ctx[38]] !== null && create_if_block_9(ctx);
	let if_block1 = /*likeable*/ ctx[4] && /*j*/ ctx[38] == 1 && create_if_block_8(ctx);
	let if_block2 = /*show_copy_button*/ ctx[7] && /*message*/ ctx[36] && typeof /*message*/ ctx[36] === "string" && create_if_block_7(ctx);

	const if_block_creators = [
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_if_block_5,
		create_if_block_6
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty[0] & /*value*/ 1) show_if = null;
		if (dirty[0] & /*value*/ 1) show_if_1 = null;
		if (dirty[0] & /*value*/ 1) show_if_2 = null;
		if (typeof /*message*/ ctx[36] === "string") return 0;
		if (show_if == null) show_if = !!(/*message*/ ctx[36] !== null && /*message*/ ctx[36].file.mime_type?.includes("audio"));
		if (show_if) return 1;
		if (show_if_1 == null) show_if_1 = !!(/*message*/ ctx[36] !== null && /*message*/ ctx[36].file.mime_type?.includes("video"));
		if (show_if_1) return 2;
		if (show_if_2 == null) show_if_2 = !!(/*message*/ ctx[36] !== null && /*message*/ ctx[36].file.mime_type?.includes("image"));
		if (show_if_2) return 3;
		if (/*message*/ ctx[36] !== null && /*message*/ ctx[36].file.data !== null) return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
		if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	function click_handler_2() {
		return /*click_handler_2*/ ctx[29](/*i*/ ctx[35], /*j*/ ctx[38], /*message*/ ctx[36]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			attr_dev(div0, "class", "message-buttons-" + (/*j*/ ctx[38] == 0 ? 'user' : 'bot') + " s-4CGYAZFhuluy");
			toggle_class(div0, "message-buttons-fit", !/*bubble_full_width*/ ctx[10]);
			toggle_class(div0, "hide", /*message*/ ctx[36] === null);
			add_location(div0, file$1, 152, 7, 3039);
			attr_dev(div1, "data-testid", /*j*/ ctx[38] == 0 ? "user" : "bot");
			attr_dev(div1, "class", "message " + (/*j*/ ctx[38] == 0 ? 'user' : 'bot') + " s-4CGYAZFhuluy");
			attr_dev(div1, "dir", div1_dir_value = /*rtl*/ ctx[6] ? "rtl" : "ltr");
			toggle_class(div1, "latest", /*i*/ ctx[35] === /*value*/ ctx[0].length - 1);
			toggle_class(div1, "message-fit", !/*bubble_full_width*/ ctx[10]);
			toggle_class(div1, "selectable", /*selectable*/ ctx[3]);
			add_location(div1, file$1, 143, 6, 2724);
			attr_dev(div2, "class", "message-row " + (/*j*/ ctx[38] == 0 ? 'user-row' : 'bot-row') + " s-4CGYAZFhuluy");
			toggle_class(div2, "hide", /*message*/ ctx[36] === null);
			add_location(div2, file$1, 123, 5, 2139);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t0);
			append_dev(div2, div1);
			append_dev(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append_dev(div0, t1);
			if (if_block2) if_block2.m(div0, null);
			append_dev(div1, t2);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div1, null);
			}

			append_dev(div2, t3);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", click_handler_2, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*avatar_images*/ ctx[8][/*j*/ ctx[38]] !== null) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					if_block0.m(div2, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*likeable*/ ctx[4] && /*j*/ ctx[38] == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*likeable*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_8(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*show_copy_button*/ ctx[7] && /*message*/ ctx[36] && typeof /*message*/ ctx[36] === "string") {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*show_copy_button, value*/ 129) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_7(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div0, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*bubble_full_width*/ 1024) {
				toggle_class(div0, "message-buttons-fit", !/*bubble_full_width*/ ctx[10]);
			}

			if (!current || dirty[0] & /*value*/ 1) {
				toggle_class(div0, "hide", /*message*/ ctx[36] === null);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block3) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block3 = if_blocks[current_block_type_index];

					if (!if_block3) {
						if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block3.c();
					} else {
						if_block3.p(ctx, dirty);
					}

					transition_in(if_block3, 1);
					if_block3.m(div1, null);
				} else {
					if_block3 = null;
				}
			}

			if (!current || dirty[0] & /*rtl*/ 64 && div1_dir_value !== (div1_dir_value = /*rtl*/ ctx[6] ? "rtl" : "ltr")) {
				attr_dev(div1, "dir", div1_dir_value);
			}

			if (!current || dirty[0] & /*value*/ 1) {
				toggle_class(div1, "latest", /*i*/ ctx[35] === /*value*/ ctx[0].length - 1);
			}

			if (!current || dirty[0] & /*bubble_full_width*/ 1024) {
				toggle_class(div1, "message-fit", !/*bubble_full_width*/ ctx[10]);
			}

			if (!current || dirty[0] & /*selectable*/ 8) {
				toggle_class(div1, "selectable", /*selectable*/ ctx[3]);
			}

			if (!current || dirty[0] & /*value*/ 1) {
				toggle_class(div2, "hide", /*message*/ ctx[36] === null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(83:4) {#each message_pair as message, j}",
		ctx
	});

	return block;
}

// (82:3) {#each value as message_pair, i}
function create_each_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = ensure_array_like_dev(/*message_pair*/ ctx[33]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value, rtl, bubble_full_width, selectable, handle_select, latex_delimiters, sanitize_html, scroll, show_copy_button, handle_like, likeable, avatar_images, root, root_url*/ 237531) {
				each_value_1 = ensure_array_like_dev(/*message_pair*/ ctx[33]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(82:3) {#each value as message_pair, i}",
		ctx
	});

	return block;
}

// (189:2) {#if pending_message}
function create_if_block$1(ctx) {
	let div3;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			t0 = text("\n\t\t\t\tÂ \n\t\t\t\t");
			div1 = element("div");
			t1 = text("\n\t\t\t\tÂ \n\t\t\t\t");
			div2 = element("div");
			attr_dev(div0, "class", "dot-flashing s-4CGYAZFhuluy");
			add_location(div0, file$1, 230, 4, 5236);
			attr_dev(div1, "class", "dot-flashing s-4CGYAZFhuluy");
			add_location(div1, file$1, 232, 4, 5280);
			attr_dev(div2, "class", "dot-flashing s-4CGYAZFhuluy");
			add_location(div2, file$1, 234, 4, 5324);
			attr_dev(div3, "class", "message pending s-4CGYAZFhuluy");
			add_location(div3, file$1, 229, 3, 5202);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div3, t0);
			append_dev(div3, div1);
			append_dev(div3, t1);
			append_dev(div3, div2);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div3);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(189:2) {#if pending_message}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let t0;
	let div1;
	let div0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*show_share_button*/ ctx[5] && /*value*/ ctx[0] !== null && /*value*/ ctx[0].length > 0 && create_if_block_10(ctx);
	let if_block1 = /*value*/ ctx[0] !== null && create_if_block_1$1(ctx);
	let if_block2 = /*pending_message*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			attr_dev(div0, "class", "message-wrap s-4CGYAZFhuluy");
			add_location(div0, file$1, 119, 1, 2000);
			attr_dev(div1, "class", "wrap s-4CGYAZFhuluy");
			add_location(div1, file$1, 118, 0, 1964);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append_dev(div0, t1);
			if (if_block2) if_block2.m(div0, null);
			/*div1_binding*/ ctx[30](div1);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(copy.call(null, div0));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*show_share_button*/ ctx[5] && /*value*/ ctx[0] !== null && /*value*/ ctx[0].length > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_share_button, value*/ 33) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_10(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*value*/ ctx[0] !== null) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*value*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*pending_message*/ ctx[2]) {
				if (if_block2) ; else {
					if_block2 = create_if_block$1(ctx);
					if_block2.c();
					if_block2.m(div0, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(div1);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			/*div1_binding*/ ctx[30](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChatBot', slots, []);
	let { value } = $$props;
	let old_value = null;
	let { latex_delimiters } = $$props;
	let { pending_message = false } = $$props;
	let { selectable = false } = $$props;
	let { likeable = false } = $$props;
	let { show_share_button = false } = $$props;
	let { rtl = false } = $$props;
	let { show_copy_button = false } = $$props;
	let { avatar_images = [null, null] } = $$props;
	let { sanitize_html = true } = $$props;
	let { bubble_full_width = true } = $$props;
	let { root } = $$props;
	let { root_url } = $$props;
	let { i18n } = $$props;
	let div;
	let autoscroll;
	const dispatch = createEventDispatcher();

	beforeUpdate(() => {
		autoscroll = div && div.offsetHeight + div.scrollTop > div.scrollHeight - 100;
	});

	const scroll = () => {
		if (autoscroll) {
			div.scrollTo(0, div.scrollHeight);
		}
	};

	afterUpdate(() => {
		if (autoscroll) {
			scroll();

			div.querySelectorAll("img").forEach(n => {
				n.addEventListener("load", () => {
					scroll();
				});
			});
		}
	});

	function handle_select(i, j, message) {
		dispatch("select", { index: [i, j], value: message });
	}

	function handle_like(i, j, message, liked) {
		dispatch("like", { index: [i, j], value: message, liked });
	}

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<ChatBot> was created without expected prop 'value'");
		}

		if (latex_delimiters === undefined && !('latex_delimiters' in $$props || $$self.$$.bound[$$self.$$.props['latex_delimiters']])) {
			console.warn("<ChatBot> was created without expected prop 'latex_delimiters'");
		}

		if (root === undefined && !('root' in $$props || $$self.$$.bound[$$self.$$.props['root']])) {
			console.warn("<ChatBot> was created without expected prop 'root'");
		}

		if (root_url === undefined && !('root_url' in $$props || $$self.$$.bound[$$self.$$.props['root_url']])) {
			console.warn("<ChatBot> was created without expected prop 'root_url'");
		}

		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console.warn("<ChatBot> was created without expected prop 'i18n'");
		}
	});

	const writable_props = [
		'value',
		'latex_delimiters',
		'pending_message',
		'selectable',
		'likeable',
		'show_share_button',
		'rtl',
		'show_copy_button',
		'avatar_images',
		'sanitize_html',
		'bubble_full_width',
		'root',
		'root_url',
		'i18n'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChatBot> was created with unknown prop '${key}'`);
	});

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	function play_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function error_handler(event) {
		bubble.call(this, $$self, event);
	}

	function share_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = (i, j, message) => handle_like(i, j, message, true);
	const click_handler_1 = (i, j, message) => handle_like(i, j, message, false);
	const click_handler_2 = (i, j, message) => handle_select(i, j, message);

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			div = $$value;
			$$invalidate(14, div);
		});
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('latex_delimiters' in $$props) $$invalidate(1, latex_delimiters = $$props.latex_delimiters);
		if ('pending_message' in $$props) $$invalidate(2, pending_message = $$props.pending_message);
		if ('selectable' in $$props) $$invalidate(3, selectable = $$props.selectable);
		if ('likeable' in $$props) $$invalidate(4, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(5, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(6, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(7, show_copy_button = $$props.show_copy_button);
		if ('avatar_images' in $$props) $$invalidate(8, avatar_images = $$props.avatar_images);
		if ('sanitize_html' in $$props) $$invalidate(9, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(10, bubble_full_width = $$props.bubble_full_width);
		if ('root' in $$props) $$invalidate(11, root = $$props.root);
		if ('root_url' in $$props) $$invalidate(12, root_url = $$props.root_url);
		if ('i18n' in $$props) $$invalidate(13, i18n = $$props.i18n);
	};

	$$self.$capture_state = () => ({
		format_chat_for_sharing,
		copy,
		beforeUpdate,
		afterUpdate,
		createEventDispatcher,
		ShareButton,
		Markdown: MarkdownCode,
		get_fetchable_url_or_file,
		Copy: Copy_1,
		Like,
		Dislike,
		Check,
		value,
		old_value,
		latex_delimiters,
		pending_message,
		selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		avatar_images,
		sanitize_html,
		bubble_full_width,
		root,
		root_url,
		i18n,
		div,
		autoscroll,
		dispatch,
		scroll,
		handle_select,
		handle_like
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('old_value' in $$props) $$invalidate(18, old_value = $$props.old_value);
		if ('latex_delimiters' in $$props) $$invalidate(1, latex_delimiters = $$props.latex_delimiters);
		if ('pending_message' in $$props) $$invalidate(2, pending_message = $$props.pending_message);
		if ('selectable' in $$props) $$invalidate(3, selectable = $$props.selectable);
		if ('likeable' in $$props) $$invalidate(4, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(5, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(6, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(7, show_copy_button = $$props.show_copy_button);
		if ('avatar_images' in $$props) $$invalidate(8, avatar_images = $$props.avatar_images);
		if ('sanitize_html' in $$props) $$invalidate(9, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(10, bubble_full_width = $$props.bubble_full_width);
		if ('root' in $$props) $$invalidate(11, root = $$props.root);
		if ('root_url' in $$props) $$invalidate(12, root_url = $$props.root_url);
		if ('i18n' in $$props) $$invalidate(13, i18n = $$props.i18n);
		if ('div' in $$props) $$invalidate(14, div = $$props.div);
		if ('autoscroll' in $$props) autoscroll = $$props.autoscroll;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, old_value*/ 262145) {
			{
				if (value !== old_value) {
					$$invalidate(18, old_value = value);
					dispatch("change");
				}
			}
		}
	};

	return [
		value,
		latex_delimiters,
		pending_message,
		selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		avatar_images,
		sanitize_html,
		bubble_full_width,
		root,
		root_url,
		i18n,
		div,
		scroll,
		handle_select,
		handle_like,
		old_value,
		play_handler,
		pause_handler,
		ended_handler,
		play_handler_1,
		pause_handler_1,
		ended_handler_1,
		error_handler,
		share_handler,
		click_handler,
		click_handler_1,
		click_handler_2,
		div1_binding
	];
}

class ChatBot extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				value: 0,
				latex_delimiters: 1,
				pending_message: 2,
				selectable: 3,
				likeable: 4,
				show_share_button: 5,
				rtl: 6,
				show_copy_button: 7,
				avatar_images: 8,
				sanitize_html: 9,
				bubble_full_width: 10,
				root: 11,
				root_url: 12,
				i18n: 13
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChatBot",
			options,
			id: create_fragment$1.name
		});
	}

	get value() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get latex_delimiters() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set latex_delimiters(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pending_message() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pending_message(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectable() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectable(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get likeable() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set likeable(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_share_button() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_share_button(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rtl() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rtl(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_copy_button() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_copy_button(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get avatar_images() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set avatar_images(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sanitize_html() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sanitize_html(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bubble_full_width() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bubble_full_width(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get root() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set root(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get root_url() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set root_url(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const StaticChatbot_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/chatbot/static/StaticChatbot.svelte generated by Svelte v4.0.0 */
const file = "Users/peterallen/Projects/gradio/js/chatbot/static/StaticChatbot.svelte";

// (61:1) {#if loading_status}
function create_if_block_1(ctx) {
	let statustracker;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[18].autoscroll
		},
		{ i18n: /*gradio*/ ctx[18].i18n },
		/*loading_status*/ ctx[20],
		{
			show_progress: /*loading_status*/ ctx[20].show_progress === "hidden"
			? "hidden"
			: "minimal"
		}
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({
			props: statustracker_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(statustracker.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(statustracker, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const statustracker_changes = (dirty & /*gradio, loading_status*/ 1310720)
			? get_spread_update(statustracker_spread_levels, [
					dirty & /*gradio*/ 262144 && {
						autoscroll: /*gradio*/ ctx[18].autoscroll
					},
					dirty & /*gradio*/ 262144 && { i18n: /*gradio*/ ctx[18].i18n },
					dirty & /*loading_status*/ 1048576 && get_spread_object(/*loading_status*/ ctx[20]),
					dirty & /*loading_status*/ 1048576 && {
						show_progress: /*loading_status*/ ctx[20].show_progress === "hidden"
						? "hidden"
						: "minimal"
					}
				])
			: {};

			statustracker.$set(statustracker_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(statustracker.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(statustracker, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(61:1) {#if loading_status}",
		ctx
	});

	return block;
}

// (72:2) {#if show_label}
function create_if_block(ctx) {
	let blocklabel;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[7],
				Icon: Chat,
				float: false,
				label: /*label*/ ctx[6] || "Chatbot"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(blocklabel.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(blocklabel, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty & /*show_label*/ 128) blocklabel_changes.show_label = /*show_label*/ ctx[7];
			if (dirty & /*label*/ 64) blocklabel_changes.label = /*label*/ ctx[6] || "Chatbot";
			blocklabel.$set(blocklabel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocklabel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(blocklabel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(72:2) {#if show_label}",
		ctx
	});

	return block;
}

// (51:0) <Block  {elem_id}  {elem_classes}  {visible}  padding={false}  {scale}  {min_width}  {height}  allow_overflow={false} >
function create_default_slot(ctx) {
	let t0;
	let div;
	let t1;
	let chatbot;
	let current;
	let if_block0 = /*loading_status*/ ctx[20] && create_if_block_1(ctx);
	let if_block1 = /*show_label*/ ctx[7] && create_if_block(ctx);

	chatbot = new ChatBot({
			props: {
				i18n: /*gradio*/ ctx[18].i18n,
				selectable: /*selectable*/ ctx[10],
				likeable: /*likeable*/ ctx[11],
				show_share_button: /*show_share_button*/ ctx[12],
				value: /*_value*/ ctx[22],
				latex_delimiters: /*latex_delimiters*/ ctx[17],
				pending_message: /*loading_status*/ ctx[20]?.status === "pending",
				rtl: /*rtl*/ ctx[13],
				show_copy_button: /*show_copy_button*/ ctx[14],
				avatar_images: /*avatar_images*/ ctx[19],
				sanitize_html: /*sanitize_html*/ ctx[15],
				bubble_full_width: /*bubble_full_width*/ ctx[16],
				root_url: /*root_url*/ ctx[9],
				root: /*root*/ ctx[8]
			},
			$$inline: true
		});

	chatbot.$on("change", /*change_handler*/ ctx[23]);
	chatbot.$on("select", /*select_handler*/ ctx[24]);
	chatbot.$on("like", /*like_handler*/ ctx[25]);
	chatbot.$on("share", /*share_handler*/ ctx[26]);
	chatbot.$on("error", /*error_handler*/ ctx[27]);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			create_component(chatbot.$$.fragment);
			attr_dev(div, "class", "wrapper s-Jre3urmsW5K1");
			add_location(div, file, 100, 1, 1864);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			mount_component(chatbot, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*loading_status*/ ctx[20]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*loading_status*/ 1048576) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*show_label*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*show_label*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const chatbot_changes = {};
			if (dirty & /*gradio*/ 262144) chatbot_changes.i18n = /*gradio*/ ctx[18].i18n;
			if (dirty & /*selectable*/ 1024) chatbot_changes.selectable = /*selectable*/ ctx[10];
			if (dirty & /*likeable*/ 2048) chatbot_changes.likeable = /*likeable*/ ctx[11];
			if (dirty & /*show_share_button*/ 4096) chatbot_changes.show_share_button = /*show_share_button*/ ctx[12];
			if (dirty & /*_value*/ 4194304) chatbot_changes.value = /*_value*/ ctx[22];
			if (dirty & /*latex_delimiters*/ 131072) chatbot_changes.latex_delimiters = /*latex_delimiters*/ ctx[17];
			if (dirty & /*loading_status*/ 1048576) chatbot_changes.pending_message = /*loading_status*/ ctx[20]?.status === "pending";
			if (dirty & /*rtl*/ 8192) chatbot_changes.rtl = /*rtl*/ ctx[13];
			if (dirty & /*show_copy_button*/ 16384) chatbot_changes.show_copy_button = /*show_copy_button*/ ctx[14];
			if (dirty & /*avatar_images*/ 524288) chatbot_changes.avatar_images = /*avatar_images*/ ctx[19];
			if (dirty & /*sanitize_html*/ 32768) chatbot_changes.sanitize_html = /*sanitize_html*/ ctx[15];
			if (dirty & /*bubble_full_width*/ 65536) chatbot_changes.bubble_full_width = /*bubble_full_width*/ ctx[16];
			if (dirty & /*root_url*/ 512) chatbot_changes.root_url = /*root_url*/ ctx[9];
			if (dirty & /*root*/ 256) chatbot_changes.root = /*root*/ ctx[8];
			chatbot.$set(chatbot_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(chatbot.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(chatbot.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(div);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			destroy_component(chatbot);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(51:0) <Block  {elem_id}  {elem_classes}  {visible}  padding={false}  {scale}  {min_width}  {height}  allow_overflow={false} >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				elem_id: /*elem_id*/ ctx[0],
				elem_classes: /*elem_classes*/ ctx[1],
				visible: /*visible*/ ctx[2],
				padding: false,
				scale: /*scale*/ ctx[4],
				min_width: /*min_width*/ ctx[5],
				height: /*height*/ ctx[21],
				allow_overflow: false,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block_1 = {
		c: function create() {
			create_component(block.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const block_changes = {};
			if (dirty & /*elem_id*/ 1) block_changes.elem_id = /*elem_id*/ ctx[0];
			if (dirty & /*elem_classes*/ 2) block_changes.elem_classes = /*elem_classes*/ ctx[1];
			if (dirty & /*visible*/ 4) block_changes.visible = /*visible*/ ctx[2];
			if (dirty & /*scale*/ 16) block_changes.scale = /*scale*/ ctx[4];
			if (dirty & /*min_width*/ 32) block_changes.min_width = /*min_width*/ ctx[5];
			if (dirty & /*height*/ 2097152) block_changes.height = /*height*/ ctx[21];

			if (dirty & /*$$scope, gradio, selectable, likeable, show_share_button, _value, latex_delimiters, loading_status, rtl, show_copy_button, avatar_images, sanitize_html, bubble_full_width, root_url, root, value, show_label, label*/ 1080033224) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(block, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block_1;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('StaticChatbot', slots, []);
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { value = [] } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { label } = $$props;
	let { show_label = true } = $$props;
	let { root } = $$props;
	let { root_url } = $$props;
	let { selectable = false } = $$props;
	let { likeable = false } = $$props;
	let { show_share_button = false } = $$props;
	let { rtl = false } = $$props;
	let { show_copy_button = false } = $$props;
	let { sanitize_html = true } = $$props;
	let { bubble_full_width = true } = $$props;
	let { latex_delimiters } = $$props;
	let { gradio } = $$props;
	let { avatar_images = [null, null] } = $$props;
	let _value;
	const redirect_src_url = src => src.replace('src="/file', `src="${root}file`);

	function normalize_messages(message) {
		if (message === null) {
			return message;
		}

		return {
			file: normalise_file(message?.file, root, root_url),
			alt_text: message?.alt_text
		};
	}

	let { loading_status = undefined } = $$props;
	let { height = 400 } = $$props;

	$$self.$$.on_mount.push(function () {
		if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
			console.warn("<StaticChatbot> was created without expected prop 'label'");
		}

		if (root === undefined && !('root' in $$props || $$self.$$.bound[$$self.$$.props['root']])) {
			console.warn("<StaticChatbot> was created without expected prop 'root'");
		}

		if (root_url === undefined && !('root_url' in $$props || $$self.$$.bound[$$self.$$.props['root_url']])) {
			console.warn("<StaticChatbot> was created without expected prop 'root_url'");
		}

		if (latex_delimiters === undefined && !('latex_delimiters' in $$props || $$self.$$.bound[$$self.$$.props['latex_delimiters']])) {
			console.warn("<StaticChatbot> was created without expected prop 'latex_delimiters'");
		}

		if (gradio === undefined && !('gradio' in $$props || $$self.$$.bound[$$self.$$.props['gradio']])) {
			console.warn("<StaticChatbot> was created without expected prop 'gradio'");
		}
	});

	const writable_props = [
		'elem_id',
		'elem_classes',
		'visible',
		'value',
		'scale',
		'min_width',
		'label',
		'show_label',
		'root',
		'root_url',
		'selectable',
		'likeable',
		'show_share_button',
		'rtl',
		'show_copy_button',
		'sanitize_html',
		'bubble_full_width',
		'latex_delimiters',
		'gradio',
		'avatar_images',
		'loading_status',
		'height'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StaticChatbot> was created with unknown prop '${key}'`);
	});

	const change_handler = () => gradio.dispatch("change", value);
	const select_handler = e => gradio.dispatch("select", e.detail);
	const like_handler = e => gradio.dispatch("like", e.detail);
	const share_handler = e => gradio.dispatch("share", e.detail);
	const error_handler = e => gradio.dispatch("error", e.detail);

	$$self.$$set = $$props => {
		if ('elem_id' in $$props) $$invalidate(0, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(1, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(2, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('scale' in $$props) $$invalidate(4, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(5, min_width = $$props.min_width);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(7, show_label = $$props.show_label);
		if ('root' in $$props) $$invalidate(8, root = $$props.root);
		if ('root_url' in $$props) $$invalidate(9, root_url = $$props.root_url);
		if ('selectable' in $$props) $$invalidate(10, selectable = $$props.selectable);
		if ('likeable' in $$props) $$invalidate(11, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(12, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(13, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(14, show_copy_button = $$props.show_copy_button);
		if ('sanitize_html' in $$props) $$invalidate(15, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(16, bubble_full_width = $$props.bubble_full_width);
		if ('latex_delimiters' in $$props) $$invalidate(17, latex_delimiters = $$props.latex_delimiters);
		if ('gradio' in $$props) $$invalidate(18, gradio = $$props.gradio);
		if ('avatar_images' in $$props) $$invalidate(19, avatar_images = $$props.avatar_images);
		if ('loading_status' in $$props) $$invalidate(20, loading_status = $$props.loading_status);
		if ('height' in $$props) $$invalidate(21, height = $$props.height);
	};

	$$self.$capture_state = () => ({
		ChatBot,
		Block,
		BlockLabel,
		Chat,
		normalise_file,
		StatusTracker: Static,
		elem_id,
		elem_classes,
		visible,
		value,
		scale,
		min_width,
		label,
		show_label,
		root,
		root_url,
		selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		sanitize_html,
		bubble_full_width,
		latex_delimiters,
		gradio,
		avatar_images,
		_value,
		redirect_src_url,
		normalize_messages,
		loading_status,
		height
	});

	$$self.$inject_state = $$props => {
		if ('elem_id' in $$props) $$invalidate(0, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(1, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(2, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('scale' in $$props) $$invalidate(4, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(5, min_width = $$props.min_width);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(7, show_label = $$props.show_label);
		if ('root' in $$props) $$invalidate(8, root = $$props.root);
		if ('root_url' in $$props) $$invalidate(9, root_url = $$props.root_url);
		if ('selectable' in $$props) $$invalidate(10, selectable = $$props.selectable);
		if ('likeable' in $$props) $$invalidate(11, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(12, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(13, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(14, show_copy_button = $$props.show_copy_button);
		if ('sanitize_html' in $$props) $$invalidate(15, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(16, bubble_full_width = $$props.bubble_full_width);
		if ('latex_delimiters' in $$props) $$invalidate(17, latex_delimiters = $$props.latex_delimiters);
		if ('gradio' in $$props) $$invalidate(18, gradio = $$props.gradio);
		if ('avatar_images' in $$props) $$invalidate(19, avatar_images = $$props.avatar_images);
		if ('_value' in $$props) $$invalidate(22, _value = $$props._value);
		if ('loading_status' in $$props) $$invalidate(20, loading_status = $$props.loading_status);
		if ('height' in $$props) $$invalidate(21, height = $$props.height);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 8) {
			$$invalidate(22, _value = value
			? value.map(([user_msg, bot_msg]) => [
					typeof user_msg === "string"
					? redirect_src_url(user_msg)
					: normalize_messages(user_msg),
					typeof bot_msg === "string"
					? redirect_src_url(bot_msg)
					: normalize_messages(bot_msg)
				])
			: []);
		}
	};

	return [
		elem_id,
		elem_classes,
		visible,
		value,
		scale,
		min_width,
		label,
		show_label,
		root,
		root_url,
		selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		sanitize_html,
		bubble_full_width,
		latex_delimiters,
		gradio,
		avatar_images,
		loading_status,
		height,
		_value,
		change_handler,
		select_handler,
		like_handler,
		share_handler,
		error_handler
	];
}

class StaticChatbot extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			elem_id: 0,
			elem_classes: 1,
			visible: 2,
			value: 3,
			scale: 4,
			min_width: 5,
			label: 6,
			show_label: 7,
			root: 8,
			root_url: 9,
			selectable: 10,
			likeable: 11,
			show_share_button: 12,
			rtl: 13,
			show_copy_button: 14,
			sanitize_html: 15,
			bubble_full_width: 16,
			latex_delimiters: 17,
			gradio: 18,
			avatar_images: 19,
			loading_status: 20,
			height: 21
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StaticChatbot",
			options,
			id: create_fragment.name
		});
	}

	get elem_id() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set elem_id(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get elem_classes() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set elem_classes(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get visible() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visible(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scale() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min_width() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min_width(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get root() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set root(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get root_url() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set root_url(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectable() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectable(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get likeable() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set likeable(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_share_button() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_share_button(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rtl() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rtl(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_copy_button() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_copy_button(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sanitize_html() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sanitize_html(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bubble_full_width() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bubble_full_width(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get latex_delimiters() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set latex_delimiters(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gradio() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gradio(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get avatar_images() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set avatar_images(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loading_status() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loading_status(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<StaticChatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<StaticChatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const StaticChatbot$1 = StaticChatbot;

export { StaticChatbot$1 as default };
//# sourceMappingURL=index-686f3f97.js.map
