import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, createEventDispatcher, beforeUpdate, afterUpdate, tick, element, create_component, space, attr_dev, toggle_class, add_location, insert_dev, mount_component, append_dev, group_outros, transition_out, check_outros, transition_in, detach_dev, destroy_component, bubble, binding_callbacks, text, set_data_dev, set_input_value, action_destroyer, listen_dev, prop_dev, is_function, run_all, empty, noop, add_render_callback, create_in_transition } from './svelte/svelte-internal.js';
import { f as fade } from './Button-153ea7e7.js';
import { B as BlockTitle } from './BlockTitle-10d6508b.js';
import { C as Copy, a as Check } from './Copy-51753e2b.js';
import './index-30423ace.js';

const Textbox_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/textbox/shared/Textbox.svelte generated by Svelte v4.0.0 */
const file = "Users/peterallen/Projects/gradio/js/textbox/shared/Textbox.svelte";

// (127:1) <BlockTitle {show_label} {info}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[3]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*label*/ 8) set_data_dev(t, /*label*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(127:1) <BlockTitle {show_label} {info}>",
		ctx
	});

	return block;
}

// (180:1) {:else}
function create_else_block(ctx) {
	let t;
	let textarea;
	let textarea_dir_value;
	let textarea_style_value;
	let text_area_resize_action;
	let current;
	let mounted;
	let dispose;
	let if_block = /*show_label*/ ctx[6] && /*show_copy_button*/ ctx[10] && create_if_block_4(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			textarea = element("textarea");
			attr_dev(textarea, "data-testid", "textbox");
			attr_dev(textarea, "class", "scroll-hide s-jJ4xg9kAnj-0");
			attr_dev(textarea, "dir", textarea_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr");
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[2]);
			attr_dev(textarea, "rows", /*lines*/ ctx[1]);
			textarea.disabled = /*disabled*/ ctx[5];
			textarea.autofocus = /*autofocus*/ ctx[12];

			attr_dev(textarea, "style", textarea_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "");

			add_location(textarea, file, 224, 2, 4638);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);
			/*textarea_binding*/ ctx[37](textarea);
			current = true;
			if (/*autofocus*/ ctx[12]) textarea.focus();

			if (!mounted) {
				dispose = [
					action_destroyer(text_area_resize_action = /*text_area_resize*/ ctx[19].call(null, textarea, /*value*/ ctx[0])),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[36]),
					listen_dev(textarea, "keypress", /*handle_keypress*/ ctx[18], false, false, false, false),
					listen_dev(textarea, "blur", /*blur_handler_3*/ ctx[28], false, false, false, false),
					listen_dev(textarea, "select", /*handle_select*/ ctx[17], false, false, false, false),
					listen_dev(textarea, "focus", /*focus_handler_3*/ ctx[29], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*show_label*/ ctx[6] && /*show_copy_button*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*show_label, show_copy_button*/ 1088) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*rtl*/ 2048 && textarea_dir_value !== (textarea_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr")) {
				attr_dev(textarea, "dir", textarea_dir_value);
			}

			if (!current || dirty[0] & /*placeholder*/ 4) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (!current || dirty[0] & /*lines*/ 2) {
				attr_dev(textarea, "rows", /*lines*/ ctx[1]);
			}

			if (!current || dirty[0] & /*disabled*/ 32) {
				prop_dev(textarea, "disabled", /*disabled*/ ctx[5]);
			}

			if (!current || dirty[0] & /*autofocus*/ 4096) {
				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[12]);
			}

			if (!current || dirty[0] & /*text_align*/ 8192 && textarea_style_value !== (textarea_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "")) {
				attr_dev(textarea, "style", textarea_style_value);
			}

			if (text_area_resize_action && is_function(text_area_resize_action.update) && dirty[0] & /*value*/ 1) text_area_resize_action.update.call(null, /*value*/ ctx[0]);

			if (dirty[0] & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(textarea);
			}

			if (if_block) if_block.d(detaching);
			/*textarea_binding*/ ctx[37](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(180:1) {:else}",
		ctx
	});

	return block;
}

// (129:1) {#if lines === 1 && max_lines === 1}
function create_if_block(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[9] === "text") return create_if_block_1;
		if (/*type*/ ctx[9] === "password") return create_if_block_2;
		if (/*type*/ ctx[9] === "email") return create_if_block_3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) {
				if_block.d(detaching);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(129:1) {#if lines === 1 && max_lines === 1}",
		ctx
	});

	return block;
}

// (181:2) {#if show_label && show_copy_button}
function create_if_block_4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5, create_else_block_1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*copied*/ ctx[15]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(181:2) {#if show_label && show_copy_button}",
		ctx
	});

	return block;
}

// (184:3) {:else}
function create_else_block_1(ctx) {
	let button;
	let copy;
	let current;
	let mounted;
	let dispose;
	copy = new Copy({ $$inline: true });

	const block = {
		c: function create() {
			button = element("button");
			create_component(copy.$$.fragment);
			attr_dev(button, "class", "copy-text s-jJ4xg9kAnj-0");
			add_location(button, file, 221, 4, 4552);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			mount_component(copy, button, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*handle_copy*/ ctx[16], false, false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(copy.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(copy.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			destroy_component(copy);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(184:3) {:else}",
		ctx
	});

	return block;
}

// (182:3) {#if copied}
function create_if_block_5(ctx) {
	let button;
	let check;
	let button_intro;
	let current;
	check = new Check({ $$inline: true });

	const block = {
		c: function create() {
			button = element("button");
			create_component(check.$$.fragment);
			attr_dev(button, "class", "s-jJ4xg9kAnj-0");
			add_location(button, file, 219, 4, 4482);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			mount_component(check, button, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(check.$$.fragment, local);

			if (local) {
				if (!button_intro) {
					add_render_callback(() => {
						button_intro = create_in_transition(button, fade, { duration: 300 });
						button_intro.start();
					});
				}
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(check.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			destroy_component(check);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(182:3) {#if copied}",
		ctx
	});

	return block;
}

// (163:29) 
function create_if_block_3(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "data-testid", "textbox");
			attr_dev(input, "type", "email");
			attr_dev(input, "class", "scroll-hide s-jJ4xg9kAnj-0");
			attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[5];
			input.autofocus = /*autofocus*/ ctx[12];
			attr_dev(input, "autocomplete", "email");
			add_location(input, file, 200, 3, 4129);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			/*input_binding_2*/ ctx[35](input);
			if (/*autofocus*/ ctx[12]) input.focus();

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler_2*/ ctx[34]),
					listen_dev(input, "keypress", /*handle_keypress*/ ctx[18], false, false, false, false),
					listen_dev(input, "blur", /*blur_handler_2*/ ctx[26], false, false, false, false),
					listen_dev(input, "select", /*handle_select*/ ctx[17], false, false, false, false),
					listen_dev(input, "focus", /*focus_handler_2*/ ctx[27], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 32) {
				prop_dev(input, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				prop_dev(input, "autofocus", /*autofocus*/ ctx[12]);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(input);
			}

			/*input_binding_2*/ ctx[35](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(163:29) ",
		ctx
	});

	return block;
}

// (147:32) 
function create_if_block_2(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "data-testid", "password");
			attr_dev(input, "type", "password");
			attr_dev(input, "class", "scroll-hide s-jJ4xg9kAnj-0");
			attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[5];
			input.autofocus = /*autofocus*/ ctx[12];
			attr_dev(input, "autocomplete", "");
			add_location(input, file, 184, 3, 3820);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			/*input_binding_1*/ ctx[33](input);
			if (/*autofocus*/ ctx[12]) input.focus();

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler_1*/ ctx[32]),
					listen_dev(input, "keypress", /*handle_keypress*/ ctx[18], false, false, false, false),
					listen_dev(input, "blur", /*blur_handler_1*/ ctx[24], false, false, false, false),
					listen_dev(input, "select", /*handle_select*/ ctx[17], false, false, false, false),
					listen_dev(input, "focus", /*focus_handler_1*/ ctx[25], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 32) {
				prop_dev(input, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				prop_dev(input, "autofocus", /*autofocus*/ ctx[12]);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(input);
			}

			/*input_binding_1*/ ctx[33](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(147:32) ",
		ctx
	});

	return block;
}

// (130:2) {#if type === "text"}
function create_if_block_1(ctx) {
	let input;
	let input_dir_value;
	let input_style_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "data-testid", "textbox");
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "scroll-hide s-jJ4xg9kAnj-0");
			attr_dev(input, "dir", input_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr");
			attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[5];
			input.autofocus = /*autofocus*/ ctx[12];

			attr_dev(input, "style", input_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "");

			add_location(input, file, 167, 3, 3445);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			/*input_binding*/ ctx[31](input);
			if (/*autofocus*/ ctx[12]) input.focus();

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[30]),
					listen_dev(input, "keypress", /*handle_keypress*/ ctx[18], false, false, false, false),
					listen_dev(input, "blur", /*blur_handler*/ ctx[22], false, false, false, false),
					listen_dev(input, "select", /*handle_select*/ ctx[17], false, false, false, false),
					listen_dev(input, "focus", /*focus_handler*/ ctx[23], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*rtl*/ 2048 && input_dir_value !== (input_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr")) {
				attr_dev(input, "dir", input_dir_value);
			}

			if (dirty[0] & /*placeholder*/ 4) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 32) {
				prop_dev(input, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				prop_dev(input, "autofocus", /*autofocus*/ ctx[12]);
			}

			if (dirty[0] & /*text_align*/ 8192 && input_style_value !== (input_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "")) {
				attr_dev(input, "style", input_style_value);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(input);
			}

			/*input_binding*/ ctx[31](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(130:2) {#if type === \\\"text\\\"}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let label_1;
	let blocktitle;
	let t;
	let current_block_type_index;
	let if_block;
	let current;

	blocktitle = new BlockTitle({
			props: {
				show_label: /*show_label*/ ctx[6],
				info: /*info*/ ctx[4],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*lines*/ ctx[1] === 1 && /*max_lines*/ ctx[8] === 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			label_1 = element("label");
			create_component(blocktitle.$$.fragment);
			t = space();
			if_block.c();
			attr_dev(label_1, "class", "s-jJ4xg9kAnj-0");
			toggle_class(label_1, "container", /*container*/ ctx[7]);
			add_location(label_1, file, 162, 0, 3301);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			mount_component(blocktitle, label_1, null);
			append_dev(label_1, t);
			if_blocks[current_block_type_index].m(label_1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const blocktitle_changes = {};
			if (dirty[0] & /*show_label*/ 64) blocktitle_changes.show_label = /*show_label*/ ctx[6];
			if (dirty[0] & /*info*/ 16) blocktitle_changes.info = /*info*/ ctx[4];

			if (dirty[0] & /*label*/ 8 | dirty[1] & /*$$scope*/ 16384) {
				blocktitle_changes.$$scope = { dirty, ctx };
			}

			blocktitle.$set(blocktitle_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(label_1, null);
			}

			if (!current || dirty[0] & /*container*/ 128) {
				toggle_class(label_1, "container", /*container*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocktitle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocktitle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(label_1);
			}

			destroy_component(blocktitle);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Textbox', slots, []);
	let { value = "" } = $$props;
	let { value_is_output = false } = $$props;
	let { lines = 1 } = $$props;
	let { placeholder = "Type here..." } = $$props;
	let { label } = $$props;
	let { info = undefined } = $$props;
	let { disabled = false } = $$props;
	let { show_label = true } = $$props;
	let { container = true } = $$props;
	let { max_lines } = $$props;
	let { type = "text" } = $$props;
	let { show_copy_button = false } = $$props;
	let { rtl = false } = $$props;
	let { autofocus = false } = $$props;
	let { text_align = undefined } = $$props;
	let { autoscroll = true } = $$props;
	let el;
	let copied = false;
	let timer;
	let can_scroll;
	const dispatch = createEventDispatcher();

	beforeUpdate(() => {
		can_scroll = el && el.offsetHeight + el.scrollTop > el.scrollHeight - 100;
	});

	const scroll = () => {
		if (can_scroll && autoscroll) {
			el.scrollTo(0, el.scrollHeight);
		}
	};

	function handle_change() {
		dispatch("change", value);

		if (!value_is_output) {
			dispatch("input");
		}
	}

	afterUpdate(() => {
		if (can_scroll && autoscroll) {
			scroll();
		}

		$$invalidate(20, value_is_output = false);
	});

	async function handle_copy() {
		if ("clipboard" in navigator) {
			await navigator.clipboard.writeText(value);
			copy_feedback();
		}
	}

	function copy_feedback() {
		$$invalidate(15, copied = true);
		if (timer) clearTimeout(timer);

		timer = setTimeout(
			() => {
				$$invalidate(15, copied = false);
			},
			1000
		);
	}

	function handle_select(event) {
		const target = event.target;
		const text = target.value;
		const index = [target.selectionStart, target.selectionEnd];
		dispatch("select", { value: text.substring(...index), index });
	}

	async function handle_keypress(e) {
		await tick();

		if (e.key === "Enter" && e.shiftKey && lines > 1) {
			e.preventDefault();
			dispatch("submit");
		} else if (e.key === "Enter" && !e.shiftKey && lines === 1 && max_lines >= 1) {
			e.preventDefault();
			dispatch("submit");
		}
	}

	async function resize(event) {
		await tick();
		if (lines === max_lines || !container) return;

		let max = max_lines === undefined
		? false
		: max_lines === undefined ? 21 * 11 : 21 * (max_lines + 1); // default

		let min = 21 * (lines + 1);
		const target = event.target;
		target.style.height = "1px";
		let scroll_height;

		if (max && target.scrollHeight > max) {
			scroll_height = max;
		} else if (target.scrollHeight < min) {
			scroll_height = min;
		} else {
			scroll_height = target.scrollHeight;
		}

		target.style.height = `${scroll_height}px`;
	}

	function text_area_resize(_el, _value) {
		if (lines === max_lines) return;
		_el.style.overflowY = "scroll";
		_el.addEventListener("input", resize);
		if (!_value.trim()) return;
		resize({ target: _el });

		return {
			destroy: () => _el.removeEventListener("input", resize)
		};
	}

	$$self.$$.on_mount.push(function () {
		if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
			console.warn("<Textbox> was created without expected prop 'label'");
		}

		if (max_lines === undefined && !('max_lines' in $$props || $$self.$$.bound[$$self.$$.props['max_lines']])) {
			console.warn("<Textbox> was created without expected prop 'max_lines'");
		}
	});

	const writable_props = [
		'value',
		'value_is_output',
		'lines',
		'placeholder',
		'label',
		'info',
		'disabled',
		'show_label',
		'container',
		'max_lines',
		'type',
		'show_copy_button',
		'rtl',
		'autofocus',
		'text_align',
		'autoscroll'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Textbox> was created with unknown prop '${key}'`);
	});

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	function input_input_handler_1() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	function input_input_handler_2() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('value_is_output' in $$props) $$invalidate(20, value_is_output = $$props.value_is_output);
		if ('lines' in $$props) $$invalidate(1, lines = $$props.lines);
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('info' in $$props) $$invalidate(4, info = $$props.info);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('show_label' in $$props) $$invalidate(6, show_label = $$props.show_label);
		if ('container' in $$props) $$invalidate(7, container = $$props.container);
		if ('max_lines' in $$props) $$invalidate(8, max_lines = $$props.max_lines);
		if ('type' in $$props) $$invalidate(9, type = $$props.type);
		if ('show_copy_button' in $$props) $$invalidate(10, show_copy_button = $$props.show_copy_button);
		if ('rtl' in $$props) $$invalidate(11, rtl = $$props.rtl);
		if ('autofocus' in $$props) $$invalidate(12, autofocus = $$props.autofocus);
		if ('text_align' in $$props) $$invalidate(13, text_align = $$props.text_align);
		if ('autoscroll' in $$props) $$invalidate(21, autoscroll = $$props.autoscroll);
	};

	$$self.$capture_state = () => ({
		beforeUpdate,
		afterUpdate,
		createEventDispatcher,
		tick,
		BlockTitle,
		Copy,
		Check,
		fade,
		value,
		value_is_output,
		lines,
		placeholder,
		label,
		info,
		disabled,
		show_label,
		container,
		max_lines,
		type,
		show_copy_button,
		rtl,
		autofocus,
		text_align,
		autoscroll,
		el,
		copied,
		timer,
		can_scroll,
		dispatch,
		scroll,
		handle_change,
		handle_copy,
		copy_feedback,
		handle_select,
		handle_keypress,
		resize,
		text_area_resize
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('value_is_output' in $$props) $$invalidate(20, value_is_output = $$props.value_is_output);
		if ('lines' in $$props) $$invalidate(1, lines = $$props.lines);
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('info' in $$props) $$invalidate(4, info = $$props.info);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('show_label' in $$props) $$invalidate(6, show_label = $$props.show_label);
		if ('container' in $$props) $$invalidate(7, container = $$props.container);
		if ('max_lines' in $$props) $$invalidate(8, max_lines = $$props.max_lines);
		if ('type' in $$props) $$invalidate(9, type = $$props.type);
		if ('show_copy_button' in $$props) $$invalidate(10, show_copy_button = $$props.show_copy_button);
		if ('rtl' in $$props) $$invalidate(11, rtl = $$props.rtl);
		if ('autofocus' in $$props) $$invalidate(12, autofocus = $$props.autofocus);
		if ('text_align' in $$props) $$invalidate(13, text_align = $$props.text_align);
		if ('autoscroll' in $$props) $$invalidate(21, autoscroll = $$props.autoscroll);
		if ('el' in $$props) $$invalidate(14, el = $$props.el);
		if ('copied' in $$props) $$invalidate(15, copied = $$props.copied);
		if ('timer' in $$props) timer = $$props.timer;
		if ('can_scroll' in $$props) can_scroll = $$props.can_scroll;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			if (value === null) $$invalidate(0, value = "");
		}

		if ($$self.$$.dirty[0] & /*value, el, lines, max_lines*/ 16643) {
			(el && lines !== max_lines && resize({ target: el }));
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			(handle_change());
		}
	};

	return [
		value,
		lines,
		placeholder,
		label,
		info,
		disabled,
		show_label,
		container,
		max_lines,
		type,
		show_copy_button,
		rtl,
		autofocus,
		text_align,
		el,
		copied,
		handle_copy,
		handle_select,
		handle_keypress,
		text_area_resize,
		value_is_output,
		autoscroll,
		blur_handler,
		focus_handler,
		blur_handler_1,
		focus_handler_1,
		blur_handler_2,
		focus_handler_2,
		blur_handler_3,
		focus_handler_3,
		input_input_handler,
		input_binding,
		input_input_handler_1,
		input_binding_1,
		input_input_handler_2,
		input_binding_2,
		textarea_input_handler,
		textarea_binding
	];
}

class Textbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 0,
				value_is_output: 20,
				lines: 1,
				placeholder: 2,
				label: 3,
				info: 4,
				disabled: 5,
				show_label: 6,
				container: 7,
				max_lines: 8,
				type: 9,
				show_copy_button: 10,
				rtl: 11,
				autofocus: 12,
				text_align: 13,
				autoscroll: 21
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Textbox",
			options,
			id: create_fragment.name
		});
	}

	get value() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value_is_output() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value_is_output(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lines() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lines(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get info() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set info(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max_lines() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max_lines(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_copy_button() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_copy_button(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rtl() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rtl(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autofocus() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autofocus(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text_align() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text_align(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoscroll() {
		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoscroll(value) {
		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Textbox as T };
//# sourceMappingURL=Textbox-d96ff70c.js.map
