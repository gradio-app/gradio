import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, svg_element, attr_dev, add_location, insert_dev, append_dev, noop, detach_dev, createEventDispatcher, globals, create_component, mount_component, transition_in, transition_out, destroy_component } from './svelte/svelte-internal.js';
import { I as IconButton } from './IconButton-a7cec4e3.js';
import './index-30423ace.js';
import { S as ShareError } from './Button-153ea7e7.js';

/* Users/peterallen/Projects/gradio/js/icons/src/Community.svelte generated by Svelte v4.0.0 */

const file = "Users/peterallen/Projects/gradio/js/icons/src/Community.svelte";

function create_fragment$1(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M23,20a5,5,0,0,0-3.89,1.89L11.8,17.32a4.46,4.46,0,0,0,0-2.64l7.31-4.57A5,5,0,1,0,18,7a4.79,4.79,0,0,0,.2,1.32l-7.31,4.57a5,5,0,1,0,0,6.22l7.31,4.57A4.79,4.79,0,0,0,18,25a5,5,0,1,0,5-5ZM23,4a3,3,0,1,1-3,3A3,3,0,0,1,23,4ZM7,19a3,3,0,1,1,3-3A3,3,0,0,1,7,19Zm16,9a3,3,0,1,1,3-3A3,3,0,0,1,23,28Z");
			attr_dev(path, "fill", "currentColor");
			add_location(path, file, 1, 2, 72);
			attr_dev(svg, "id", "icon");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 32 32");
			add_location(svg, file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Community', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Community> was created with unknown prop '${key}'`);
	});

	return [];
}

class Community extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Community",
			options,
			id: create_fragment$1.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/atoms/src/ShareButton.svelte generated by Svelte v4.0.0 */

const { console: console_1 } = globals;

function create_fragment(ctx) {
	let iconbutton;
	let current;

	iconbutton = new IconButton({
			props: {
				Icon: Community,
				label: /*i18n*/ ctx[2]("common.share"),
				pending: /*pending*/ ctx[3]
			},
			$$inline: true
		});

	iconbutton.$on("click", /*click_handler*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbutton_changes = {};
			if (dirty & /*i18n*/ 4) iconbutton_changes.label = /*i18n*/ ctx[2]("common.share");
			if (dirty & /*pending*/ 8) iconbutton_changes.pending = /*pending*/ ctx[3];
			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ShareButton', slots, []);
	const dispatch = createEventDispatcher();
	let { formatter } = $$props;
	let { value } = $$props;
	let { i18n } = $$props;
	let pending = false;

	$$self.$$.on_mount.push(function () {
		if (formatter === undefined && !('formatter' in $$props || $$self.$$.bound[$$self.$$.props['formatter']])) {
			console_1.warn("<ShareButton> was created without expected prop 'formatter'");
		}

		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console_1.warn("<ShareButton> was created without expected prop 'value'");
		}

		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console_1.warn("<ShareButton> was created without expected prop 'i18n'");
		}
	});

	const writable_props = ['formatter', 'value', 'i18n'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<ShareButton> was created with unknown prop '${key}'`);
	});

	const click_handler = async () => {
		try {
			$$invalidate(3, pending = true);
			const formatted = await formatter(value);
			dispatch("share", { description: formatted });
		} catch(e) {
			console.error(e);
			let message = e instanceof ShareError ? e.message : "Share failed.";
			dispatch("error", message);
		} finally {
			$$invalidate(3, pending = false);
		}
	};

	$$self.$$set = $$props => {
		if ('formatter' in $$props) $$invalidate(0, formatter = $$props.formatter);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('i18n' in $$props) $$invalidate(2, i18n = $$props.i18n);
	};

	$$self.$capture_state = () => ({
		IconButton,
		Community,
		createEventDispatcher,
		ShareError,
		dispatch,
		formatter,
		value,
		i18n,
		pending
	});

	$$self.$inject_state = $$props => {
		if ('formatter' in $$props) $$invalidate(0, formatter = $$props.formatter);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('i18n' in $$props) $$invalidate(2, i18n = $$props.i18n);
		if ('pending' in $$props) $$invalidate(3, pending = $$props.pending);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [formatter, value, i18n, pending, dispatch, click_handler];
}

class ShareButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { formatter: 0, value: 1, i18n: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ShareButton",
			options,
			id: create_fragment.name
		});
	}

	get formatter() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatter(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<ShareButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<ShareButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { ShareButton as S };
//# sourceMappingURL=ShareButton-67809009.js.map
