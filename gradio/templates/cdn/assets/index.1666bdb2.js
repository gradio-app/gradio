import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, a as svg_element, b as attr_dev, c as add_location, e as insert_dev, f as append_dev, n as noop, g as detach_dev, h as element, t as toggle_class, l as listen_dev, j as is_function, p as prevent_default, r as run_all, k as text, m as set_data_dev, o as validate_each_argument, q as empty, u as destroy_each, w as space, x as globals, y as createEventDispatcher, z as spring, A as subscribe, B as create_component, C as mount_component, D as transition_in, E as transition_out, F as destroy_component, G as group_outros, H as check_outros, I as binding_callbacks, J as onDestroy, K as bubble, L as bind, M as add_flush_callback, N as src_url_equal, O as action_destroyer, P as validate_store, X, Q as component_subscribe, R as StatusTracker, T as assign, U as get_spread_update, V as get_spread_object } from './index.a172f41e.js';
import { U as Upload } from './Upload.56241c10.js';
import { M as ModifyUpload } from './ModifyUpload.b2b4da5f.js';
import { B as BlockLabel } from './BlockLabel.a122a485.js';
import { B as Block } from './Block.317c92c7.js';
import { n as normalise_file } from './utils.49185b04.js';
import './styles.d87a390f.js';

/* Users/pngwn/Projects/gradio/ui/packages/icons/src/Music.svelte generated by Svelte v3.47.0 */

const file$4 = "Users/pngwn/Projects/gradio/ui/packages/icons/src/Music.svelte";

function create_fragment$5(ctx) {
	let svg;
	let path;
	let circle0;
	let circle1;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr_dev(path, "d", "M9 18V5l12-2v13");
			add_location(path, file$4, 11, 2, 229);
			attr_dev(circle0, "cx", "6");
			attr_dev(circle0, "cy", "18");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$4, 11, 30, 257);
			attr_dev(circle1, "cx", "18");
			attr_dev(circle1, "cy", "16");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$4, 11, 61, 288);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "stroke-width", "1.5");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", "feather feather-music");
			add_location(svg, file$4, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Music', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Music> was created with unknown prop '${key}'`);
	});

	return [];
}

class Music extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Music",
			options,
			id: create_fragment$5.name
		});
	}
}

var RangePips_svelte_svelte_type_style_lang = '';

/* Users/pngwn/Projects/gradio/ui/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangePips.svelte generated by Svelte v3.47.0 */

const file$3 = "Users/pngwn/Projects/gradio/ui/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangePips.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	child_ctx[29] = i;
	return child_ctx;
}

// (173:2) {#if ( all && first !== false ) || first }
function create_if_block_9(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') && create_if_block_10(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block) if_block.c();
			attr_dev(span, "class", "pip first s--qTYIRQ2Q_sl");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*min*/ ctx[0]));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*min*/ ctx[0]));
			add_location(span, file$3, 173, 4, 4343);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen_dev(
						span,
						"click",
						function () {
							if (is_function(/*labelClick*/ ctx[20](/*min*/ ctx[0]))) /*labelClick*/ ctx[20](/*min*/ ctx[0]).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						span,
						"touchend",
						prevent_default(function () {
							if (is_function(/*labelClick*/ ctx[20](/*min*/ ctx[0]))) /*labelClick*/ ctx[20](/*min*/ ctx[0]).apply(this, arguments);
						}),
						false,
						true,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"))) {
				attr_dev(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, min*/ 131073) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*min*/ ctx[0]));
			}

			if (dirty & /*inRange, min*/ 65537) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*min*/ ctx[0]));
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(173:2) {#if ( all && first !== false ) || first }",
		ctx
	});

	return block;
}

// (182:6) {#if all === 'label' || first === 'label'}
function create_if_block_10(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*min*/ ctx[0], 0, 0) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_12(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_11(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "pipVal s--qTYIRQ2Q_sl");
			add_location(span, file$3, 182, 8, 4633);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, min*/ 4097 && t_value !== (t_value = /*formatter*/ ctx[12](/*min*/ ctx[0], 0, 0) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_11(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(182:6) {#if all === 'label' || first === 'label'}",
		ctx
	});

	return block;
}

// (184:10) {#if prefix}
function create_if_block_12(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr_dev(span, "class", "pipVal-prefix s--qTYIRQ2Q_sl");
			add_location(span, file$3, 183, 22, 4677);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(184:10) {#if prefix}",
		ctx
	});

	return block;
}

// (184:90) {#if suffix}
function create_if_block_11(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr_dev(span, "class", "pipVal-suffix s--qTYIRQ2Q_sl");
			add_location(span, file$3, 183, 102, 4757);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(184:90) {#if suffix}",
		ctx
	});

	return block;
}

// (190:2) {#if ( all && rest !== false ) || rest}
function create_if_block_4$2(ctx) {
	let each_1_anchor;
	let each_value = Array(/*pipCount*/ ctx[19] + 1);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelClick, suffix, formatter, prefix, all, rest, min, max, pipCount*/ 2088515) {
				each_value = Array(/*pipCount*/ ctx[19] + 1);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(190:2) {#if ( all && rest !== false ) || rest}",
		ctx
	});

	return block;
}

// (192:6) {#if pipVal(i) !== min && pipVal(i) !== max}
function create_if_block_5(ctx) {
	let span;
	let t;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') && create_if_block_6(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block) if_block.c();
			t = space();
			attr_dev(span, "class", "pip s--qTYIRQ2Q_sl");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29])) + "%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			add_location(span, file$3, 192, 8, 4996);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block) if_block.m(span, null);
			append_dev(span, t);

			if (!mounted) {
				dispose = [
					listen_dev(
						span,
						"click",
						function () {
							if (is_function(/*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])))) /*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						span,
						"touchend",
						prevent_default(function () {
							if (is_function(/*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])))) /*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])).apply(this, arguments);
						}),
						false,
						true,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart, percentOf, pipVal*/ 311296 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29])) + "%;"))) {
				attr_dev(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, pipVal*/ 393216) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			}

			if (dirty & /*inRange, pipVal*/ 327680) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(192:6) {#if pipVal(i) !== min && pipVal(i) !== max}",
		ctx
	});

	return block;
}

// (201:10) {#if all === 'label' || rest === 'label'}
function create_if_block_6(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[29]), /*i*/ ctx[29], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29]))) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_8(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_7(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "pipVal s--qTYIRQ2Q_sl");
			add_location(span, file$3, 201, 12, 5360);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, pipVal, percentOf*/ 299008 && t_value !== (t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[29]), /*i*/ ctx[29], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29]))) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(201:10) {#if all === 'label' || rest === 'label'}",
		ctx
	});

	return block;
}

// (203:14) {#if prefix}
function create_if_block_8(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr_dev(span, "class", "pipVal-prefix s--qTYIRQ2Q_sl");
			add_location(span, file$3, 202, 26, 5408);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(203:14) {#if prefix}",
		ctx
	});

	return block;
}

// (203:119) {#if suffix}
function create_if_block_7(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr_dev(span, "class", "pipVal-suffix s--qTYIRQ2Q_sl");
			add_location(span, file$3, 202, 131, 5513);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(203:119) {#if suffix}",
		ctx
	});

	return block;
}

// (191:4) {#each Array(pipCount + 1) as _, i}
function create_each_block$1(ctx) {
	let show_if = /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*max*/ ctx[1];
	let if_block_anchor;
	let if_block = show_if && create_if_block_5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*pipVal, min, max*/ 262147) show_if = /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*max*/ ctx[1];

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(191:4) {#each Array(pipCount + 1) as _, i}",
		ctx
	});

	return block;
}

// (211:2) {#if ( all && last !== false ) || last}
function create_if_block$4(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block) if_block.c();
			attr_dev(span, "class", "pip last s--qTYIRQ2Q_sl");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*max*/ ctx[1]));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*max*/ ctx[1]));
			add_location(span, file$3, 211, 4, 5693);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen_dev(
						span,
						"click",
						function () {
							if (is_function(/*labelClick*/ ctx[20](/*max*/ ctx[1]))) /*labelClick*/ ctx[20](/*max*/ ctx[1]).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						span,
						"touchend",
						prevent_default(function () {
							if (is_function(/*labelClick*/ ctx[20](/*max*/ ctx[1]))) /*labelClick*/ ctx[20](/*max*/ ctx[1]).apply(this, arguments);
						}),
						false,
						true,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"))) {
				attr_dev(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, max*/ 131074) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*max*/ ctx[1]));
			}

			if (dirty & /*inRange, max*/ 65538) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*max*/ ctx[1]));
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(211:2) {#if ( all && last !== false ) || last}",
		ctx
	});

	return block;
}

// (220:6) {#if all === 'label' || last === 'label'}
function create_if_block_1$2(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*max*/ ctx[1], /*pipCount*/ ctx[19], 100) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_3$2(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_2$2(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "pipVal s--qTYIRQ2Q_sl");
			add_location(span, file$3, 220, 8, 5983);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, max, pipCount*/ 528386 && t_value !== (t_value = /*formatter*/ ctx[12](/*max*/ ctx[1], /*pipCount*/ ctx[19], 100) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(220:6) {#if all === 'label' || last === 'label'}",
		ctx
	});

	return block;
}

// (222:10) {#if prefix}
function create_if_block_3$2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr_dev(span, "class", "pipVal-prefix s--qTYIRQ2Q_sl");
			add_location(span, file$3, 221, 22, 6027);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(222:10) {#if prefix}",
		ctx
	});

	return block;
}

// (222:99) {#if suffix}
function create_if_block_2$2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr_dev(span, "class", "pipVal-suffix s--qTYIRQ2Q_sl");
			add_location(span, file$3, 221, 111, 6116);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(222:99) {#if suffix}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div;
	let t0;
	let t1;
	let if_block0 = (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) && create_if_block_9(ctx);
	let if_block1 = (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) && create_if_block_4$2(ctx);
	let if_block2 = (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) && create_if_block$4(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			attr_dev(div, "class", "rangePips s--qTYIRQ2Q_sl");
			toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			toggle_class(div, "focus", /*focus*/ ctx[13]);
			add_location(div, file$3, 164, 0, 4178);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$2(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$4(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*disabled*/ 32) {
				toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty & /*hoverable*/ 16) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			}

			if (dirty & /*vertical*/ 4) {
				toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			}

			if (dirty & /*reversed*/ 8) {
				toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			}

			if (dirty & /*focus*/ 8192) {
				toggle_class(div, "focus", /*focus*/ ctx[13]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let pipStep;
	let pipCount;
	let pipVal;
	let isSelected;
	let inRange;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RangePips', slots, []);
	let { range = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = true } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i) => v } = $$props;
	let { focus = undefined } = $$props;
	let { orientationStart = undefined } = $$props;
	let { percentOf = undefined } = $$props;
	let { moveHandle = undefined } = $$props;

	function labelClick(val) {
		moveHandle(undefined, val);
	}

	const writable_props = [
		'range',
		'min',
		'max',
		'step',
		'values',
		'vertical',
		'reversed',
		'hoverable',
		'disabled',
		'pipstep',
		'all',
		'first',
		'last',
		'rest',
		'prefix',
		'suffix',
		'formatter',
		'focus',
		'orientationStart',
		'percentOf',
		'moveHandle'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RangePips> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('range' in $$props) $$invalidate(21, range = $$props.range);
		if ('min' in $$props) $$invalidate(0, min = $$props.min);
		if ('max' in $$props) $$invalidate(1, max = $$props.max);
		if ('step' in $$props) $$invalidate(22, step = $$props.step);
		if ('values' in $$props) $$invalidate(23, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(2, vertical = $$props.vertical);
		if ('reversed' in $$props) $$invalidate(3, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('pipstep' in $$props) $$invalidate(24, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(6, all = $$props.all);
		if ('first' in $$props) $$invalidate(7, first = $$props.first);
		if ('last' in $$props) $$invalidate(8, last = $$props.last);
		if ('rest' in $$props) $$invalidate(9, rest = $$props.rest);
		if ('prefix' in $$props) $$invalidate(10, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(11, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(12, formatter = $$props.formatter);
		if ('focus' in $$props) $$invalidate(13, focus = $$props.focus);
		if ('orientationStart' in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
		if ('percentOf' in $$props) $$invalidate(15, percentOf = $$props.percentOf);
		if ('moveHandle' in $$props) $$invalidate(25, moveHandle = $$props.moveHandle);
	};

	$$self.$capture_state = () => ({
		range,
		min,
		max,
		step,
		values,
		vertical,
		reversed,
		hoverable,
		disabled,
		pipstep,
		all,
		first,
		last,
		rest,
		prefix,
		suffix,
		formatter,
		focus,
		orientationStart,
		percentOf,
		moveHandle,
		labelClick,
		inRange,
		isSelected,
		pipStep,
		pipVal,
		pipCount
	});

	$$self.$inject_state = $$props => {
		if ('range' in $$props) $$invalidate(21, range = $$props.range);
		if ('min' in $$props) $$invalidate(0, min = $$props.min);
		if ('max' in $$props) $$invalidate(1, max = $$props.max);
		if ('step' in $$props) $$invalidate(22, step = $$props.step);
		if ('values' in $$props) $$invalidate(23, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(2, vertical = $$props.vertical);
		if ('reversed' in $$props) $$invalidate(3, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('pipstep' in $$props) $$invalidate(24, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(6, all = $$props.all);
		if ('first' in $$props) $$invalidate(7, first = $$props.first);
		if ('last' in $$props) $$invalidate(8, last = $$props.last);
		if ('rest' in $$props) $$invalidate(9, rest = $$props.rest);
		if ('prefix' in $$props) $$invalidate(10, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(11, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(12, formatter = $$props.formatter);
		if ('focus' in $$props) $$invalidate(13, focus = $$props.focus);
		if ('orientationStart' in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
		if ('percentOf' in $$props) $$invalidate(15, percentOf = $$props.percentOf);
		if ('moveHandle' in $$props) $$invalidate(25, moveHandle = $$props.moveHandle);
		if ('inRange' in $$props) $$invalidate(16, inRange = $$props.inRange);
		if ('isSelected' in $$props) $$invalidate(17, isSelected = $$props.isSelected);
		if ('pipStep' in $$props) $$invalidate(26, pipStep = $$props.pipStep);
		if ('pipVal' in $$props) $$invalidate(18, pipVal = $$props.pipVal);
		if ('pipCount' in $$props) $$invalidate(19, pipCount = $$props.pipCount);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pipstep, max, min, step, vertical*/ 20971527) {
			$$invalidate(26, pipStep = pipstep || ((max - min) / step >= (vertical ? 50 : 100)
			? (max - min) / (vertical ? 10 : 20)
			: 1));
		}

		if ($$self.$$.dirty & /*max, min, step, pipStep*/ 71303171) {
			$$invalidate(19, pipCount = parseInt((max - min) / (step * pipStep), 10));
		}

		if ($$self.$$.dirty & /*min, step, pipStep*/ 71303169) {
			$$invalidate(18, pipVal = function (val) {
				return min + val * step * pipStep;
			});
		}

		if ($$self.$$.dirty & /*values*/ 8388608) {
			$$invalidate(17, isSelected = function (val) {
				return values.some(v => v === val);
			});
		}

		if ($$self.$$.dirty & /*range, values*/ 10485760) {
			$$invalidate(16, inRange = function (val) {
				if (range === "min") {
					return values[0] > val;
				} else if (range === "max") {
					return values[0] < val;
				} else if (range) {
					return values[0] < val && values[1] > val;
				}
			});
		}
	};

	return [
		min,
		max,
		vertical,
		reversed,
		hoverable,
		disabled,
		all,
		first,
		last,
		rest,
		prefix,
		suffix,
		formatter,
		focus,
		orientationStart,
		percentOf,
		inRange,
		isSelected,
		pipVal,
		pipCount,
		labelClick,
		range,
		step,
		values,
		pipstep,
		moveHandle,
		pipStep
	];
}

class RangePips extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			range: 21,
			min: 0,
			max: 1,
			step: 22,
			values: 23,
			vertical: 2,
			reversed: 3,
			hoverable: 4,
			disabled: 5,
			pipstep: 24,
			all: 6,
			first: 7,
			last: 8,
			rest: 9,
			prefix: 10,
			suffix: 11,
			formatter: 12,
			focus: 13,
			orientationStart: 14,
			percentOf: 15,
			moveHandle: 25
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RangePips",
			options,
			id: create_fragment$4.name
		});
	}

	get range() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set range(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get values() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set values(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get reversed() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set reversed(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoverable() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hoverable(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pipstep() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pipstep(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get all() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set all(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get first() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set first(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get last() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set last(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rest() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rest(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get prefix() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set prefix(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get suffix() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set suffix(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formatter() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatter(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set focus(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orientationStart() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orientationStart(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get percentOf() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set percentOf(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get moveHandle() {
		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set moveHandle(value) {
		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var RangeSlider_svelte_svelte_type_style_lang = '';

/* Users/pngwn/Projects/gradio/ui/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangeSlider.svelte generated by Svelte v3.47.0 */

const { console: console_1 } = globals;
const file$2 = "Users/pngwn/Projects/gradio/ui/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangeSlider.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[63] = list[i];
	child_ctx[65] = i;
	return child_ctx;
}

// (817:6) {#if float}
function create_if_block_2$1(ctx) {
	let span;
	let t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[18] && create_if_block_4$1(ctx);
	let if_block1 = /*suffix*/ ctx[19] && create_if_block_3$1(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "rangeFloat s-9iShwbfH6hvP");
			add_location(span, file$2, 817, 8, 24351);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_dev(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p: function update(ctx, dirty) {
			if (/*prefix*/ ctx[18]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*handleFormatter, values, percentOf*/ 10485761 && t_value !== (t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + "")) set_data_dev(t, t_value);

			if (/*suffix*/ ctx[19]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$1(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(817:6) {#if float}",
		ctx
	});

	return block;
}

// (819:10) {#if prefix}
function create_if_block_4$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*prefix*/ ctx[18]);
			attr_dev(span, "class", "rangeFloat-prefix s-9iShwbfH6hvP");
			add_location(span, file$2, 818, 22, 24399);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*prefix*/ 262144) set_data_dev(t, /*prefix*/ ctx[18]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(819:10) {#if prefix}",
		ctx
	});

	return block;
}

// (819:121) {#if suffix}
function create_if_block_3$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*suffix*/ ctx[19]);
			attr_dev(span, "class", "rangeFloat-suffix s-9iShwbfH6hvP");
			add_location(span, file$2, 818, 133, 24510);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*suffix*/ 524288) set_data_dev(t, /*suffix*/ ctx[19]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(819:121) {#if suffix}",
		ctx
	});

	return block;
}

// (796:2) {#each values as value, index}
function create_each_block(ctx) {
	let span1;
	let span0;
	let t;
	let span1_style_value;
	let span1_aria_valuemin_value;
	let span1_aria_valuemax_value;
	let span1_aria_valuenow_value;
	let span1_aria_valuetext_value;
	let span1_aria_orientation_value;
	let span1_tabindex_value;
	let mounted;
	let dispose;
	let if_block = /*float*/ ctx[7] && create_if_block_2$1(ctx);

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = space();
			if (if_block) if_block.c();
			attr_dev(span0, "class", "rangeNub s-9iShwbfH6hvP");
			add_location(span0, file$2, 815, 6, 24299);
			attr_dev(span1, "role", "slider");
			attr_dev(span1, "class", "rangeHandle s-9iShwbfH6hvP");
			attr_dev(span1, "data-handle", /*index*/ ctx[65]);
			attr_dev(span1, "style", span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[65]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[65] ? 3 : 2) + ";"));

			attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3]);

			attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4]);

			attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value = /*value*/ ctx[63]);
			attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + /*suffix*/ ctx[19]));
			attr_dev(span1, "aria-orientation", span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal');
			attr_dev(span1, "aria-disabled", /*disabled*/ ctx[10]);
			attr_dev(span1, "disabled", /*disabled*/ ctx[10]);
			attr_dev(span1, "tabindex", span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0);
			toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			add_location(span1, file$2, 796, 4, 23486);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t);
			if (if_block) if_block.m(span1, null);

			if (!mounted) {
				dispose = [
					listen_dev(span1, "blur", /*sliderBlurHandle*/ ctx[33], false, false, false),
					listen_dev(span1, "focus", /*sliderFocusHandle*/ ctx[34], false, false, false),
					listen_dev(span1, "keydown", /*sliderKeydown*/ ctx[35], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*float*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					if_block.m(span1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*orientationStart, $springPositions, activeHandle*/ 872415232 && span1_style_value !== (span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[65]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[65] ? 3 : 2) + ";"))) {
				attr_dev(span1, "style", span1_style_value);
			}

			if (dirty[0] & /*range, values, min*/ 13 && span1_aria_valuemin_value !== (span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3])) {
				attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value);
			}

			if (dirty[0] & /*range, values, max*/ 21 && span1_aria_valuemax_value !== (span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4])) {
				attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value);
			}

			if (dirty[0] & /*values*/ 1 && span1_aria_valuenow_value !== (span1_aria_valuenow_value = /*value*/ ctx[63])) {
				attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value);
			}

			if (dirty[0] & /*prefix, handleFormatter, values, percentOf, suffix*/ 11272193 && span1_aria_valuetext_value !== (span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + /*suffix*/ ctx[19]))) {
				attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value);
			}

			if (dirty[0] & /*vertical*/ 64 && span1_aria_orientation_value !== (span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal')) {
				attr_dev(span1, "aria-orientation", span1_aria_orientation_value);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr_dev(span1, "aria-disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr_dev(span1, "disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024 && span1_tabindex_value !== (span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0)) {
				attr_dev(span1, "tabindex", span1_tabindex_value);
			}

			if (dirty[0] & /*focus, activeHandle*/ 83886080) {
				toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			}

			if (dirty[0] & /*handlePressed, activeHandle*/ 100663296) {
				toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(796:2) {#each values as value, index}",
		ctx
	});

	return block;
}

// (824:2) {#if range}
function create_if_block_1$1(ctx) {
	let span;
	let span_style_value;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "rangeBar s-9iShwbfH6hvP");
			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[31](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[32](/*$springPositions*/ ctx[29]) + "%;"));
			add_location(span, file$2, 824, 4, 24631);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, orientationEnd*/ 939524096 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[31](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[32](/*$springPositions*/ ctx[29]) + "%;"))) {
				attr_dev(span, "style", span_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(824:2) {#if range}",
		ctx
	});

	return block;
}

// (830:2) {#if pips}
function create_if_block$3(ctx) {
	let rangepips;
	let current;

	rangepips = new RangePips({
			props: {
				values: /*values*/ ctx[0],
				min: /*min*/ ctx[3],
				max: /*max*/ ctx[4],
				step: /*step*/ ctx[5],
				range: /*range*/ ctx[2],
				vertical: /*vertical*/ ctx[6],
				reversed: /*reversed*/ ctx[8],
				orientationStart: /*orientationStart*/ ctx[28],
				hoverable: /*hoverable*/ ctx[9],
				disabled: /*disabled*/ ctx[10],
				all: /*all*/ ctx[13],
				first: /*first*/ ctx[14],
				last: /*last*/ ctx[15],
				rest: /*rest*/ ctx[16],
				pipstep: /*pipstep*/ ctx[12],
				prefix: /*prefix*/ ctx[18],
				suffix: /*suffix*/ ctx[19],
				formatter: /*formatter*/ ctx[20],
				focus: /*focus*/ ctx[24],
				percentOf: /*percentOf*/ ctx[23],
				moveHandle: /*moveHandle*/ ctx[30]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(rangepips.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(rangepips, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const rangepips_changes = {};
			if (dirty[0] & /*values*/ 1) rangepips_changes.values = /*values*/ ctx[0];
			if (dirty[0] & /*min*/ 8) rangepips_changes.min = /*min*/ ctx[3];
			if (dirty[0] & /*max*/ 16) rangepips_changes.max = /*max*/ ctx[4];
			if (dirty[0] & /*step*/ 32) rangepips_changes.step = /*step*/ ctx[5];
			if (dirty[0] & /*range*/ 4) rangepips_changes.range = /*range*/ ctx[2];
			if (dirty[0] & /*vertical*/ 64) rangepips_changes.vertical = /*vertical*/ ctx[6];
			if (dirty[0] & /*reversed*/ 256) rangepips_changes.reversed = /*reversed*/ ctx[8];
			if (dirty[0] & /*orientationStart*/ 268435456) rangepips_changes.orientationStart = /*orientationStart*/ ctx[28];
			if (dirty[0] & /*hoverable*/ 512) rangepips_changes.hoverable = /*hoverable*/ ctx[9];
			if (dirty[0] & /*disabled*/ 1024) rangepips_changes.disabled = /*disabled*/ ctx[10];
			if (dirty[0] & /*all*/ 8192) rangepips_changes.all = /*all*/ ctx[13];
			if (dirty[0] & /*first*/ 16384) rangepips_changes.first = /*first*/ ctx[14];
			if (dirty[0] & /*last*/ 32768) rangepips_changes.last = /*last*/ ctx[15];
			if (dirty[0] & /*rest*/ 65536) rangepips_changes.rest = /*rest*/ ctx[16];
			if (dirty[0] & /*pipstep*/ 4096) rangepips_changes.pipstep = /*pipstep*/ ctx[12];
			if (dirty[0] & /*prefix*/ 262144) rangepips_changes.prefix = /*prefix*/ ctx[18];
			if (dirty[0] & /*suffix*/ 524288) rangepips_changes.suffix = /*suffix*/ ctx[19];
			if (dirty[0] & /*formatter*/ 1048576) rangepips_changes.formatter = /*formatter*/ ctx[20];
			if (dirty[0] & /*focus*/ 16777216) rangepips_changes.focus = /*focus*/ ctx[24];
			if (dirty[0] & /*percentOf*/ 8388608) rangepips_changes.percentOf = /*percentOf*/ ctx[23];
			rangepips.$set(rangepips_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(rangepips.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(rangepips.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(rangepips, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(830:2) {#if pips}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let each_value = /*values*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block0 = /*range*/ ctx[2] && create_if_block_1$1(ctx);
	let if_block1 = /*pips*/ ctx[11] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "id", /*id*/ ctx[17]);
			attr_dev(div, "class", "rangeSlider s-9iShwbfH6hvP");
			toggle_class(div, "range", /*range*/ ctx[2]);
			toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			toggle_class(div, "focus", /*focus*/ ctx[24]);
			toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			toggle_class(div, "pips", /*pips*/ ctx[11]);
			toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
			add_location(div, file$2, 776, 0, 22952);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[49](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "mousedown", /*bodyInteractStart*/ ctx[38], false, false, false),
					listen_dev(window, "touchstart", /*bodyInteractStart*/ ctx[38], false, false, false),
					listen_dev(window, "mousemove", /*bodyInteract*/ ctx[39], false, false, false),
					listen_dev(window, "touchmove", /*bodyInteract*/ ctx[39], false, false, false),
					listen_dev(window, "mouseup", /*bodyMouseUp*/ ctx[40], false, false, false),
					listen_dev(window, "touchend", /*bodyTouchEnd*/ ctx[41], false, false, false),
					listen_dev(window, "keydown", /*bodyKeyDown*/ ctx[42], false, false, false),
					listen_dev(div, "mousedown", /*sliderInteractStart*/ ctx[36], false, false, false),
					listen_dev(div, "mouseup", /*sliderInteractEnd*/ ctx[37], false, false, false),
					listen_dev(div, "touchstart", prevent_default(/*sliderInteractStart*/ ctx[36]), false, true, false),
					listen_dev(div, "touchend", prevent_default(/*sliderInteractEnd*/ ctx[37]), false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, activeHandle, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/ 934020317 | dirty[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/ 28) {
				each_value = /*values*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*range*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*pips*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*pips*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*id*/ 131072) {
				attr_dev(div, "id", /*id*/ ctx[17]);
			}

			if (dirty[0] & /*range*/ 4) {
				toggle_class(div, "range", /*range*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*hoverable*/ 512) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			}

			if (dirty[0] & /*vertical*/ 64) {
				toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			}

			if (dirty[0] & /*reversed*/ 256) {
				toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			}

			if (dirty[0] & /*focus*/ 16777216) {
				toggle_class(div, "focus", /*focus*/ ctx[24]);
			}

			if (dirty[0] & /*range*/ 4) {
				toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			}

			if (dirty[0] & /*range*/ 4) {
				toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			}

			if (dirty[0] & /*pips*/ 2048) {
				toggle_class(div, "pips", /*pips*/ ctx[11]);
			}

			if (dirty[0] & /*all, first, last, rest*/ 122880) {
				toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[49](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function index(el) {
	if (!el) return -1;
	var i = 0;

	while (el = el.previousElementSibling) {
		i++;
	}

	return i;
}

/**
 * normalise a mouse or touch event to return the
 * client (x/y) object for that event
 * @param {event} e a mouse/touch event to normalise
 * @returns {object} normalised event client object (x,y)
 **/
function normalisedClient(e) {
	if (e.type.includes("touch")) {
		return e.touches[0];
	} else {
		return e;
	}
}

function instance$3($$self, $$props, $$invalidate) {
	let percentOf;
	let clampValue;
	let alignValueToStep;
	let orientationStart;
	let orientationEnd;

	let $springPositions,
		$$unsubscribe_springPositions = noop,
		$$subscribe_springPositions = () => ($$unsubscribe_springPositions(), $$unsubscribe_springPositions = subscribe(springPositions, $$value => $$invalidate(29, $springPositions = $$value)), springPositions);

	$$self.$$.on_destroy.push(() => $$unsubscribe_springPositions());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RangeSlider', slots, []);
	let { slider } = $$props;
	let { range = false } = $$props;
	let { pushy = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { float = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pips = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = undefined } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { id = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i, p) => v } = $$props;
	let { handleFormatter = formatter } = $$props;
	let { precision = 2 } = $$props;
	let { springValues = { stiffness: 0.15, damping: 0.4 } } = $$props;

	// prepare dispatched events
	const dispatch = createEventDispatcher();

	// state management
	let valueLength = 0;

	let focus = false;
	let handleActivated = false;
	let handlePressed = false;
	let keyboardActive = false;
	let activeHandle = values.length - 1;
	let startValue;
	let previousValue;

	// copy the initial values in to a spring function which
	// will update every time the values array is modified
	let springPositions;

	/**
 * check if an element is a handle on the slider
 * @param {object} el dom object reference we want to check
 * @returns {boolean}
 **/
	function targetIsHandle(el) {
		const handles = slider.querySelectorAll(".handle");
		const isHandle = Array.prototype.includes.call(handles, el);
		const isChild = Array.prototype.some.call(handles, e => e.contains(el));
		return isHandle || isChild;
	}

	/**
 * trim the values array based on whether the property
 * for 'range' is 'min', 'max', or truthy. This is because we
 * do not want more than one handle for a min/max range, and we do
 * not want more than two handles for a true range.
 * @param {array} values the input values for the rangeSlider
 * @return {array} the range array for creating a rangeSlider
 **/
	function trimRange(values) {
		if (range === "min" || range === "max") {
			return values.slice(0, 1);
		} else if (range) {
			return values.slice(0, 2);
		} else {
			return values;
		}
	}

	/**
 * helper to return the slider dimensions for finding
 * the closest handle to user interaction
 * @return {object} the range slider DOM client rect
 **/
	function getSliderDimensions() {
		return slider.getBoundingClientRect();
	}

	/**
 * helper to return closest handle to user interaction
 * @param {object} clientPos the client{x,y} positions to check against
 * @return {number} the index of the closest handle to clientPos
 **/
	function getClosestHandle(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;
		let closest;

		// if we have a range, and the handles are at the same
		// position, we want a simple check if the interaction
		// value is greater than return the second handle
		if (range === true && values[0] === values[1]) {
			if (handleVal > values[1]) {
				return 1;
			} else {
				return 0;
			}
		} else // we sort the handles values, and return the first one closest
		// to the interaction value
		{
			closest = values.indexOf([...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]); // if there are multiple handles, and not a range, then
		}

		return closest;
	}

	/**
 * take the interaction position on the slider, convert
 * it to a value on the range, and then send that value
 * through to the moveHandle() method to set the active
 * handle's position
 * @param {object} clientPos the client{x,y} of the interaction
 **/
	function handleInteract(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;

		// move handle to the value
		moveHandle(activeHandle, handleVal);
	}

	/**
 * move a handle to a specific value, respecting the clamp/align rules
 * @param {number} index the index of the handle we want to move
 * @param {number} value the value to move the handle to
 * @return {number} the value that was moved to (after alignment/clamping)
 **/
	function moveHandle(index, value) {
		// align & clamp the value so we're not doing extra
		// calculation on an out-of-range value down below
		value = alignValueToStep(value);

		// use the active handle if handle index is not provided
		if (typeof index === 'undefined') {
			index = activeHandle;
		}

		// if this is a range slider perform special checks
		if (range) {
			// restrict the handles of a range-slider from
			// going past one-another unless "pushy" is true
			if (index === 0 && value > values[1]) {
				if (pushy) {
					$$invalidate(0, values[1] = value, values);
				} else {
					value = values[1];
				}
			} else if (index === 1 && value < values[0]) {
				if (pushy) {
					$$invalidate(0, values[0] = value, values);
				} else {
					value = values[0];
				}
			}
		}

		// if the value has changed, update it
		if (values[index] !== value) {
			$$invalidate(0, values[index] = value, values);
		}

		// fire the change event when the handle moves,
		// and store the previous value for the next time
		if (previousValue !== value) {
			eChange();
			previousValue = value;
		}

		return value;
	}

	/**
 * helper to find the beginning range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the beginning of the range
 **/
	function rangeStart(values) {
		if (range === "min") {
			return 0;
		} else {
			return values[0];
		}
	}

	/**
 * helper to find the ending range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the end of the range
 **/
	function rangeEnd(values) {
		if (range === "max") {
			return 0;
		} else if (range === "min") {
			return 100 - values[0];
		} else {
			return 100 - values[1];
		}
	}

	/**
 * when the user has unfocussed (blurred) from the
 * slider, deactivate all handles
 * @param {event} e the event from browser
 **/
	function sliderBlurHandle(e) {
		if (keyboardActive) {
			$$invalidate(24, focus = false);
			handleActivated = false;
			$$invalidate(25, handlePressed = false);
		}
	}

	/**
 * when the user focusses the handle of a slider
 * set it to be active
 * @param {event} e the event from browser
 **/
	function sliderFocusHandle(e) {
		if (!disabled) {
			$$invalidate(26, activeHandle = index(e.target));
			$$invalidate(24, focus = true);
		}
	}

	/**
 * handle the keyboard accessible features by checking the
 * input type, and modfier key then moving handle by appropriate amount
 * @param {event} e the event from browser
 **/
	function sliderKeydown(e) {
		if (!disabled) {
			const handle = index(e.target);
			let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;
			let prevent = false;

			switch (e.key) {
				case "PageDown":
					jump *= 10;
				case "ArrowRight":
				case "ArrowUp":
					moveHandle(handle, values[handle] + jump);
					prevent = true;
					break;
				case "PageUp":
					jump *= 10;
				case "ArrowLeft":
				case "ArrowDown":
					moveHandle(handle, values[handle] - jump);
					prevent = true;
					break;
				case "Home":
					moveHandle(handle, min);
					prevent = true;
					break;
				case "End":
					moveHandle(handle, max);
					prevent = true;
					break;
			}

			if (prevent) {
				e.preventDefault();
				e.stopPropagation();
			}
		}
	}

	/**
 * function to run when the user touches
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractStart(e) {
		if (!disabled) {
			const el = e.target;
			const clientPos = normalisedClient(e);

			// set the closest handle as active
			$$invalidate(24, focus = true);

			handleActivated = true;
			$$invalidate(25, handlePressed = true);
			$$invalidate(26, activeHandle = getClosestHandle(clientPos));

			// fire the start event
			startValue = previousValue = alignValueToStep(values[activeHandle]);

			eStart();

			// for touch devices we want the handle to instantly
			// move to the position touched for more responsive feeling
			if (e.type === "touchstart" && !el.matches(".pipVal")) {
				handleInteract(clientPos);
			}
		}
	}

	/**
 * function to run when the user stops touching
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractEnd(e) {
		// fire the stop event for touch devices
		if (e.type === "touchend") {
			eStop();
		}

		$$invalidate(25, handlePressed = false);
	}

	/**
 * unfocus the slider if the user clicked off of
 * it, somewhere else on the screen
 * @param {event} e the event from browser
 **/
	function bodyInteractStart(e) {
		keyboardActive = false;

		if (focus && e.target !== slider && !slider.contains(e.target)) {
			$$invalidate(24, focus = false);
		}
	}

	/**
 * send the clientX through to handle the interaction
 * whenever the user moves acros screen while active
 * @param {event} e the event from browser
 **/
	function bodyInteract(e) {
		if (!disabled) {
			if (handleActivated) {
				handleInteract(normalisedClient(e));
			}
		}
	}

	/**
 * if user triggers mouseup on the body while
 * a handle is active (without moving) then we
 * trigger an interact event there
 * @param {event} e the event from browser
 **/
	function bodyMouseUp(e) {
		if (!disabled) {
			const el = e.target;

			// this only works if a handle is active, which can
			// only happen if there was sliderInteractStart triggered
			// on the slider, already
			if (handleActivated) {
				if (el === slider || slider.contains(el)) {
					$$invalidate(24, focus = true);

					// don't trigger interact if the target is a handle (no need) or
					// if the target is a label (we want to move to that value from rangePips)
					if (!targetIsHandle(el) && !el.matches(".pipVal")) {
						handleInteract(normalisedClient(e));
					}
				}

				// fire the stop event for mouse device
				// when the body is triggered with an active handle
				eStop();
			}
		}

		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	/**
 * if user triggers touchend on the body then we
 * defocus the slider completely
 * @param {event} e the event from browser
 **/
	function bodyTouchEnd(e) {
		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	function bodyKeyDown(e) {
		if (!disabled) {
			if (e.target === slider || slider.contains(e.target)) {
				keyboardActive = true;
			}
		}
	}

	function eStart() {
		!disabled && dispatch("start", {
			activeHandle,
			value: startValue,
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eStop() {
		!disabled && dispatch("stop", {
			activeHandle,
			startValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eChange() {
		!disabled && dispatch("change", {
			activeHandle,
			startValue,
			previousValue: typeof previousValue === "undefined"
			? startValue
			: previousValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	const writable_props = [
		'slider',
		'range',
		'pushy',
		'min',
		'max',
		'step',
		'values',
		'vertical',
		'float',
		'reversed',
		'hoverable',
		'disabled',
		'pips',
		'pipstep',
		'all',
		'first',
		'last',
		'rest',
		'id',
		'prefix',
		'suffix',
		'formatter',
		'handleFormatter',
		'precision',
		'springValues'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<RangeSlider> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			slider = $$value;
			$$invalidate(1, slider);
		});
	}

	$$self.$$set = $$props => {
		if ('slider' in $$props) $$invalidate(1, slider = $$props.slider);
		if ('range' in $$props) $$invalidate(2, range = $$props.range);
		if ('pushy' in $$props) $$invalidate(43, pushy = $$props.pushy);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('values' in $$props) $$invalidate(0, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(6, vertical = $$props.vertical);
		if ('float' in $$props) $$invalidate(7, float = $$props.float);
		if ('reversed' in $$props) $$invalidate(8, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(9, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('pips' in $$props) $$invalidate(11, pips = $$props.pips);
		if ('pipstep' in $$props) $$invalidate(12, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(13, all = $$props.all);
		if ('first' in $$props) $$invalidate(14, first = $$props.first);
		if ('last' in $$props) $$invalidate(15, last = $$props.last);
		if ('rest' in $$props) $$invalidate(16, rest = $$props.rest);
		if ('id' in $$props) $$invalidate(17, id = $$props.id);
		if ('prefix' in $$props) $$invalidate(18, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(19, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(20, formatter = $$props.formatter);
		if ('handleFormatter' in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
		if ('precision' in $$props) $$invalidate(44, precision = $$props.precision);
		if ('springValues' in $$props) $$invalidate(45, springValues = $$props.springValues);
	};

	$$self.$capture_state = () => ({
		spring,
		createEventDispatcher,
		RangePips,
		slider,
		range,
		pushy,
		min,
		max,
		step,
		values,
		vertical,
		float,
		reversed,
		hoverable,
		disabled,
		pips,
		pipstep,
		all,
		first,
		last,
		rest,
		id,
		prefix,
		suffix,
		formatter,
		handleFormatter,
		precision,
		springValues,
		dispatch,
		valueLength,
		focus,
		handleActivated,
		handlePressed,
		keyboardActive,
		activeHandle,
		startValue,
		previousValue,
		springPositions,
		index,
		normalisedClient,
		targetIsHandle,
		trimRange,
		getSliderDimensions,
		getClosestHandle,
		handleInteract,
		moveHandle,
		rangeStart,
		rangeEnd,
		sliderBlurHandle,
		sliderFocusHandle,
		sliderKeydown,
		sliderInteractStart,
		sliderInteractEnd,
		bodyInteractStart,
		bodyInteract,
		bodyMouseUp,
		bodyTouchEnd,
		bodyKeyDown,
		eStart,
		eStop,
		eChange,
		alignValueToStep,
		orientationEnd,
		orientationStart,
		clampValue,
		percentOf,
		$springPositions
	});

	$$self.$inject_state = $$props => {
		if ('slider' in $$props) $$invalidate(1, slider = $$props.slider);
		if ('range' in $$props) $$invalidate(2, range = $$props.range);
		if ('pushy' in $$props) $$invalidate(43, pushy = $$props.pushy);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('values' in $$props) $$invalidate(0, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(6, vertical = $$props.vertical);
		if ('float' in $$props) $$invalidate(7, float = $$props.float);
		if ('reversed' in $$props) $$invalidate(8, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(9, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('pips' in $$props) $$invalidate(11, pips = $$props.pips);
		if ('pipstep' in $$props) $$invalidate(12, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(13, all = $$props.all);
		if ('first' in $$props) $$invalidate(14, first = $$props.first);
		if ('last' in $$props) $$invalidate(15, last = $$props.last);
		if ('rest' in $$props) $$invalidate(16, rest = $$props.rest);
		if ('id' in $$props) $$invalidate(17, id = $$props.id);
		if ('prefix' in $$props) $$invalidate(18, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(19, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(20, formatter = $$props.formatter);
		if ('handleFormatter' in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
		if ('precision' in $$props) $$invalidate(44, precision = $$props.precision);
		if ('springValues' in $$props) $$invalidate(45, springValues = $$props.springValues);
		if ('valueLength' in $$props) $$invalidate(46, valueLength = $$props.valueLength);
		if ('focus' in $$props) $$invalidate(24, focus = $$props.focus);
		if ('handleActivated' in $$props) handleActivated = $$props.handleActivated;
		if ('handlePressed' in $$props) $$invalidate(25, handlePressed = $$props.handlePressed);
		if ('keyboardActive' in $$props) keyboardActive = $$props.keyboardActive;
		if ('activeHandle' in $$props) $$invalidate(26, activeHandle = $$props.activeHandle);
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('previousValue' in $$props) previousValue = $$props.previousValue;
		if ('springPositions' in $$props) $$subscribe_springPositions($$invalidate(22, springPositions = $$props.springPositions));
		if ('alignValueToStep' in $$props) $$invalidate(47, alignValueToStep = $$props.alignValueToStep);
		if ('orientationEnd' in $$props) $$invalidate(27, orientationEnd = $$props.orientationEnd);
		if ('orientationStart' in $$props) $$invalidate(28, orientationStart = $$props.orientationStart);
		if ('clampValue' in $$props) $$invalidate(48, clampValue = $$props.clampValue);
		if ('percentOf' in $$props) $$invalidate(23, percentOf = $$props.percentOf);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*min, max*/ 24) {
			/**
 * clamp a value from the range so that it always
 * falls within the min/max values
 * @param {number} val the value to clamp
 * @return {number} the value after it's been clamped
 **/
			$$invalidate(48, clampValue = function (val) {
				// return the min/max if outside of that range
				return val <= min ? min : val >= max ? max : val;
			});
		}

		if ($$self.$$.dirty[0] & /*min, max, step*/ 56 | $$self.$$.dirty[1] & /*clampValue, precision*/ 139264) {
			/**
 * align the value with the steps so that it
 * always sits on the closest (above/below) step
 * @param {number} val the value to align
 * @return {number} the value after it's been aligned
 **/
			$$invalidate(47, alignValueToStep = function (val) {
				// sanity check for performance
				if (val <= min) {
					return min;
				} else if (val >= max) {
					return max;
				}

				// find the middle-point between steps
				// and see if the value is closer to the
				// next step, or previous step
				let remainder = (val - min) % step;

				let aligned = val - remainder;

				if (Math.abs(remainder) * 2 >= step) {
					aligned += remainder > 0 ? step : -step;
				}

				// make sure the value is within acceptable limits
				aligned = clampValue(aligned);

				// make sure the returned value is set to the precision desired
				// this is also because javascript often returns weird floats
				// when dealing with odd numbers and percentages
				return parseFloat(aligned.toFixed(precision));
			});
		}

		if ($$self.$$.dirty[0] & /*min, max*/ 24 | $$self.$$.dirty[1] & /*precision*/ 8192) {
			/**
 * take in a value, and then calculate that value's percentage
 * of the overall range (min-max);
 * @param {number} val the value we're getting percent for
 * @return {number} the percentage value
 **/
			$$invalidate(23, percentOf = function (val) {
				let perc = (val - min) / (max - min) * 100;

				if (isNaN(perc) || perc <= 0) {
					return 0;
				} else if (perc >= 100) {
					return 100;
				} else {
					return parseFloat(perc.toFixed(precision));
				}
			});
		}

		if ($$self.$$.dirty[0] & /*values, max, min, percentOf, springPositions*/ 12582937 | $$self.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/ 114688) {
			{
				// check that "values" is an array, or set it as array
				// to prevent any errors in springs, or range trimming
				if (!Array.isArray(values)) {
					$$invalidate(0, values = [(max + min) / 2]);
					console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
				}

				// trim the range so it remains as a min/max (only 2 handles)
				// and also align the handles to the steps
				$$invalidate(0, values = trimRange(values.map(v => alignValueToStep(v))));

				// check if the valueLength (length of values[]) has changed,
				// because if so we need to re-seed the spring function with the
				// new values array.
				if (valueLength !== values.length) {
					// set the initial spring values when the slider initialises,
					// or when values array length has changed
					$$subscribe_springPositions($$invalidate(22, springPositions = spring(values.map(v => percentOf(v)), springValues)));
				} else {
					// update the value of the spring function for animated handles
					// whenever the values has updated
					springPositions.set(values.map(v => percentOf(v)));
				}

				// set the valueLength for the next check
				$$invalidate(46, valueLength = values.length);
			}
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			/**
 * the orientation of the handles/pips based on the
 * input values of vertical and reversed
 **/
			$$invalidate(28, orientationStart = vertical
			? reversed ? 'top' : 'bottom'
			: reversed ? 'right' : 'left');
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			$$invalidate(27, orientationEnd = vertical
			? reversed ? 'bottom' : 'top'
			: reversed ? 'left' : 'right');
		}
	};

	return [
		values,
		slider,
		range,
		min,
		max,
		step,
		vertical,
		float,
		reversed,
		hoverable,
		disabled,
		pips,
		pipstep,
		all,
		first,
		last,
		rest,
		id,
		prefix,
		suffix,
		formatter,
		handleFormatter,
		springPositions,
		percentOf,
		focus,
		handlePressed,
		activeHandle,
		orientationEnd,
		orientationStart,
		$springPositions,
		moveHandle,
		rangeStart,
		rangeEnd,
		sliderBlurHandle,
		sliderFocusHandle,
		sliderKeydown,
		sliderInteractStart,
		sliderInteractEnd,
		bodyInteractStart,
		bodyInteract,
		bodyMouseUp,
		bodyTouchEnd,
		bodyKeyDown,
		pushy,
		precision,
		springValues,
		valueLength,
		alignValueToStep,
		clampValue,
		div_binding
	];
}

class RangeSlider extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				slider: 1,
				range: 2,
				pushy: 43,
				min: 3,
				max: 4,
				step: 5,
				values: 0,
				vertical: 6,
				float: 7,
				reversed: 8,
				hoverable: 9,
				disabled: 10,
				pips: 11,
				pipstep: 12,
				all: 13,
				first: 14,
				last: 15,
				rest: 16,
				id: 17,
				prefix: 18,
				suffix: 19,
				formatter: 20,
				handleFormatter: 21,
				precision: 44,
				springValues: 45
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RangeSlider",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*slider*/ ctx[1] === undefined && !('slider' in props)) {
			console_1.warn("<RangeSlider> was created without expected prop 'slider'");
		}
	}

	get slider() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slider(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get range() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set range(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pushy() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pushy(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get values() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set values(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get float() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set float(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get reversed() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set reversed(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoverable() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hoverable(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pips() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pips(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pipstep() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pipstep(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get all() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set all(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get first() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set first(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get last() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set last(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rest() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rest(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get prefix() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set prefix(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get suffix() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set suffix(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formatter() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatter(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleFormatter() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handleFormatter(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get precision() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set precision(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get springValues() {
		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set springValues(value) {
		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/pngwn/Projects/gradio/ui/packages/audio/src/Audio.svelte generated by Svelte v3.47.0 */

const file$1 = "Users/pngwn/Projects/gradio/ui/packages/audio/src/Audio.svelte";

// (147:0) {:else}
function create_else_block_1(ctx) {
	let modifyupload;
	let t0;
	let audio;
	let audio_src_value;
	let t1;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	modifyupload = new ModifyUpload({
			props: { editable: true, absolute: false },
			$$inline: true
		});

	modifyupload.$on("clear", /*clear*/ ctx[14]);
	modifyupload.$on("edit", /*edit_handler*/ ctx[24]);
	let if_block = /*mode*/ ctx[9] === "edit" && /*player*/ ctx[10]?.duration && create_if_block_4(ctx);

	const block = {
		c: function create() {
			create_component(modifyupload.$$.fragment);
			t0 = space();
			audio = element("audio");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(audio, "class", "w-full h-14 p-2");
			audio.controls = true;
			attr_dev(audio, "preload", "metadata");
			if (!src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1].data)) attr_dev(audio, "src", audio_src_value);
			add_location(audio, file$1, 154, 1, 4310);
		},
		m: function mount(target, anchor) {
			mount_component(modifyupload, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, audio, anchor);
			/*audio_binding*/ ctx[25](audio);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(/*loaded*/ ctx[15].call(null, audio)),
					listen_dev(audio, "play", /*play_handler*/ ctx[20], false, false, false),
					listen_dev(audio, "pause", /*pause_handler*/ ctx[21], false, false, false),
					listen_dev(audio, "ended", /*ended_handler*/ ctx[22], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*value*/ 2 && !src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1].data)) {
				attr_dev(audio, "src", audio_src_value);
			}

			if (/*mode*/ ctx[9] === "edit" && /*player*/ ctx[10]?.duration) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*mode, player*/ 1536) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modifyupload.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(modifyupload.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modifyupload, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(audio);
			/*audio_binding*/ ctx[25](null);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(147:0) {:else}",
		ctx
	});

	return block;
}

// (112:0) {#if value === null}
function create_if_block$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*source*/ ctx[4] === "microphone") return 0;
		if (/*source*/ ctx[4] === "upload") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(112:0) {#if value === null}",
		ctx
	});

	return block;
}

// (167:1) {#if mode === "edit" && player?.duration}
function create_if_block_4(ctx) {
	let range;
	let updating_values;
	let current;

	function range_values_binding(value) {
		/*range_values_binding*/ ctx[26](value);
	}

	let range_props = { range: true, min: 0, max: 100, step: 1 };

	if (/*crop_values*/ ctx[11] !== void 0) {
		range_props.values = /*crop_values*/ ctx[11];
	}

	range = new RangeSlider({ props: range_props, $$inline: true });
	binding_callbacks.push(() => bind(range, 'values', range_values_binding));
	range.$on("change", /*handle_change*/ ctx[16]);

	const block = {
		c: function create() {
			create_component(range.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const range_changes = {};

			if (!updating_values && dirty[0] & /*crop_values*/ 2048) {
				updating_values = true;
				range_changes.values = /*crop_values*/ ctx[11];
				add_flush_callback(() => updating_values = false);
			}

			range.$set(range_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(range, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(167:1) {#if mode === \\\"edit\\\" && player?.duration}",
		ctx
	});

	return block;
}

// (138:31) 
function create_if_block_3(ctx) {
	let upload;
	let updating_dragging;
	let current;

	function upload_dragging_binding(value) {
		/*upload_dragging_binding*/ ctx[23](value);
	}

	let upload_props = {
		filetype: "audio/*",
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	if (/*dragging*/ ctx[0] !== void 0) {
		upload_props.dragging = /*dragging*/ ctx[0];
	}

	upload = new Upload({ props: upload_props, $$inline: true });
	binding_callbacks.push(() => bind(upload, 'dragging', upload_dragging_binding));
	upload.$on("load", /*handle_load*/ ctx[17]);

	const block = {
		c: function create() {
			create_component(upload.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(upload, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const upload_changes = {};

			if (dirty[0] & /*upload_text, or_text, drop_text*/ 224 | dirty[1] & /*$$scope*/ 4) {
				upload_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 1) {
				updating_dragging = true;
				upload_changes.dragging = /*dragging*/ ctx[0];
				add_flush_callback(() => updating_dragging = false);
			}

			upload.$set(upload_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(upload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(upload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(upload, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(138:31) ",
		ctx
	});

	return block;
}

// (113:1) {#if source === "microphone"}
function create_if_block_1(ctx) {
	let div;

	function select_block_type_2(ctx, dirty) {
		if (/*recording*/ ctx[8]) return create_if_block_2;
		return create_else_block$2;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "class", "mt-6 p-2");
			add_location(div, file$1, 113, 2, 3160);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(113:1) {#if source === \\\"microphone\\\"}",
		ctx
	});

	return block;
}

// (139:2) <Upload filetype="audio/*" on:load={handle_load} bind:dragging>
function create_default_slot$1(ctx) {
	let div;
	let t0;
	let t1;
	let span;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(/*drop_text*/ ctx[5]);
			t1 = space();
			span = element("span");
			t2 = text("- ");
			t3 = text(/*or_text*/ ctx[6]);
			t4 = text(" -");
			t5 = space();
			t6 = text(/*upload_text*/ ctx[7]);
			attr_dev(span, "class", "text-gray-300");
			add_location(span, file$1, 141, 4, 4102);
			attr_dev(div, "class", "flex flex-col");
			add_location(div, file$1, 139, 3, 4054);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, span);
			append_dev(span, t2);
			append_dev(span, t3);
			append_dev(span, t4);
			append_dev(div, t5);
			append_dev(div, t6);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*drop_text*/ 32) set_data_dev(t0, /*drop_text*/ ctx[5]);
			if (dirty[0] & /*or_text*/ 64) set_data_dev(t3, /*or_text*/ ctx[6]);
			if (dirty[0] & /*upload_text*/ 128) set_data_dev(t6, /*upload_text*/ ctx[7]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(139:2) <Upload filetype=\\\"audio/*\\\" on:load={handle_load} bind:dragging>",
		ctx
	});

	return block;
}

// (127:3) {:else}
function create_else_block$2(ctx) {
	let button;
	let span1;
	let span0;
	let t0;
	let div;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span1 = element("span");
			span0 = element("span");
			t0 = space();
			div = element("div");
			div.textContent = "Record from microphone";
			attr_dev(span0, "class", "relative inline-flex rounded-full h-1.5 w-1.5 bg-red-500");
			add_location(span0, file$1, 129, 6, 3756);
			attr_dev(span1, "class", "flex h-1.5 w-1.5 relative mr-2");
			add_location(span1, file$1, 128, 5, 3704);
			attr_dev(div, "class", "whitespace-nowrap");
			add_location(div, file$1, 133, 5, 3861);
			attr_dev(button, "class", "gr-button text-gray-800");
			add_location(button, file$1, 127, 4, 3640);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span1);
			append_dev(span1, span0);
			append_dev(button, t0);
			append_dev(button, div);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*record*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(127:3) {:else}",
		ctx
	});

	return block;
}

// (115:3) {#if recording}
function create_if_block_2(ctx) {
	let button;
	let span2;
	let span0;
	let t0;
	let span1;
	let t1;
	let div;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span2 = element("span");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			div = element("div");
			div.textContent = "Stop recording";
			attr_dev(span0, "class", "animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75");
			add_location(span0, file$1, 117, 6, 3322);
			attr_dev(span1, "class", "relative inline-flex rounded-full h-1.5 w-1.5 bg-red-500");
			add_location(span1, file$1, 120, 6, 3441);
			attr_dev(span2, "class", "flex h-1.5 w-1.5 relative mr-2 ");
			add_location(span2, file$1, 116, 5, 3269);
			attr_dev(div, "class", "whitespace-nowrap text-red-500");
			add_location(div, file$1, 124, 5, 3546);
			attr_dev(button, "class", "gr-button !bg-red-500/10");
			add_location(button, file$1, 115, 4, 3206);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span2);
			append_dev(span2, span0);
			append_dev(span2, t0);
			append_dev(span2, span1);
			append_dev(button, t1);
			append_dev(button, div);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*stop*/ ctx[13], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(115:3) {#if recording}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let blocklabel;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[3],
				Icon: Music,
				label: /*label*/ ctx[2] || "Audio"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$2, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[1] === null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(blocklabel.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(blocklabel, target, anchor);
			insert_dev(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 8) blocklabel_changes.show_label = /*show_label*/ ctx[3];
			if (dirty[0] & /*label*/ 4) blocklabel_changes.label = /*label*/ ctx[2] || "Audio";
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocklabel.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(blocklabel, detaching);
			if (detaching) detach_dev(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function blob_to_data_url(blob) {
	return new Promise((fulfill, reject) => {
			let reader = new FileReader();
			reader.onerror = reject;
			reader.onload = e => fulfill(reader.result);
			reader.readAsDataURL(blob);
		});
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Audio', slots, []);
	let { value = null } = $$props;
	let { label } = $$props;
	let { show_label } = $$props;
	let { name } = $$props;
	let { source } = $$props;
	let { drop_text = "Drop an audio file" } = $$props;
	let { or_text = "or" } = $$props;
	let { upload_text = "click to upload" } = $$props;
	let { type = "normal" } = $$props;
	let recording = false;
	let recorder;
	let mode = "";
	let audio_chunks = [];
	let audio_blob;
	let player;
	let inited = false;
	let crop_values = [0, 100];
	const dispatch = createEventDispatcher();

	async function prepare_audio() {
		const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
		recorder = new MediaRecorder(stream);

		recorder.addEventListener("dataavailable", event => {
			audio_chunks.push(event.data);
		});

		recorder.addEventListener("stop", async () => {
			$$invalidate(8, recording = false);
			audio_blob = new Blob(audio_chunks, { type: "audio/wav" });

			$$invalidate(1, value = {
				data: await blob_to_data_url(audio_blob),
				name
			});

			dispatch("change", {
				data: await blob_to_data_url(audio_blob),
				name
			});
		});
	}

	async function record() {
		$$invalidate(8, recording = true);
		audio_chunks = [];
		if (!inited) await prepare_audio();
		recorder.start();
	}

	onDestroy(() => {
		if (recorder && recorder.state !== "inactive") {
			recorder.stop();
		}
	});

	const stop = () => {
		recorder.stop();
	};

	function clear() {
		dispatch("change");
		$$invalidate(9, mode = "");
		$$invalidate(1, value = null);
	}

	function loaded(node) {
		function clamp_playback() {
			const start_time = crop_values[0] / 100 * node.duration;
			const end_time = crop_values[1] / 100 * node.duration;

			if (node.currentTime < start_time) {
				node.currentTime = start_time;
			}

			if (node.currentTime > end_time) {
				node.currentTime = start_time;
				node.pause();
			}
		}

		node.addEventListener("timeupdate", clamp_playback);

		return {
			destroy: () => node.removeEventListener("timeupdate", clamp_playback)
		};
	}

	function handle_change({ detail: { values } }) {
		if (!value) return;

		dispatch("change", {
			data: value.data,
			name,
			crop_min: values[0],
			crop_max: values[1]
		});

		dispatch("edit");
	}

	function handle_load({ detail }) {
		$$invalidate(1, value = detail);
		dispatch("change", { data: detail.data, name: detail.name });
	}

	let { dragging = false } = $$props;

	const writable_props = [
		'value',
		'label',
		'show_label',
		'name',
		'source',
		'drop_text',
		'or_text',
		'upload_text',
		'type',
		'dragging'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Audio> was created with unknown prop '${key}'`);
	});

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	function upload_dragging_binding(value) {
		dragging = value;
		$$invalidate(0, dragging);
	}

	const edit_handler = () => $$invalidate(9, mode = "edit");

	function audio_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			player = $$value;
			$$invalidate(10, player);
		});
	}

	function range_values_binding(value) {
		crop_values = value;
		$$invalidate(11, crop_values);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(3, show_label = $$props.show_label);
		if ('name' in $$props) $$invalidate(18, name = $$props.name);
		if ('source' in $$props) $$invalidate(4, source = $$props.source);
		if ('drop_text' in $$props) $$invalidate(5, drop_text = $$props.drop_text);
		if ('or_text' in $$props) $$invalidate(6, or_text = $$props.or_text);
		if ('upload_text' in $$props) $$invalidate(7, upload_text = $$props.upload_text);
		if ('type' in $$props) $$invalidate(19, type = $$props.type);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
	};

	$$self.$capture_state = () => ({
		onDestroy,
		createEventDispatcher,
		Upload,
		ModifyUpload,
		BlockLabel,
		Music,
		Range: RangeSlider,
		value,
		label,
		show_label,
		name,
		source,
		drop_text,
		or_text,
		upload_text,
		type,
		recording,
		recorder,
		mode,
		audio_chunks,
		audio_blob,
		player,
		inited,
		crop_values,
		dispatch,
		blob_to_data_url,
		prepare_audio,
		record,
		stop,
		clear,
		loaded,
		handle_change,
		handle_load,
		dragging
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(3, show_label = $$props.show_label);
		if ('name' in $$props) $$invalidate(18, name = $$props.name);
		if ('source' in $$props) $$invalidate(4, source = $$props.source);
		if ('drop_text' in $$props) $$invalidate(5, drop_text = $$props.drop_text);
		if ('or_text' in $$props) $$invalidate(6, or_text = $$props.or_text);
		if ('upload_text' in $$props) $$invalidate(7, upload_text = $$props.upload_text);
		if ('type' in $$props) $$invalidate(19, type = $$props.type);
		if ('recording' in $$props) $$invalidate(8, recording = $$props.recording);
		if ('recorder' in $$props) recorder = $$props.recorder;
		if ('mode' in $$props) $$invalidate(9, mode = $$props.mode);
		if ('audio_chunks' in $$props) audio_chunks = $$props.audio_chunks;
		if ('audio_blob' in $$props) audio_blob = $$props.audio_blob;
		if ('player' in $$props) $$invalidate(10, player = $$props.player);
		if ('inited' in $$props) inited = $$props.inited;
		if ('crop_values' in $$props) $$invalidate(11, crop_values = $$props.crop_values);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*dragging*/ 1) {
			dispatch("drag", dragging);
		}
	};

	return [
		dragging,
		value,
		label,
		show_label,
		source,
		drop_text,
		or_text,
		upload_text,
		recording,
		mode,
		player,
		crop_values,
		record,
		stop,
		clear,
		loaded,
		handle_change,
		handle_load,
		name,
		type,
		play_handler,
		pause_handler,
		ended_handler,
		upload_dragging_binding,
		edit_handler,
		audio_binding,
		range_values_binding
	];
}

class Audio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				value: 1,
				label: 2,
				show_label: 3,
				name: 18,
				source: 4,
				drop_text: 5,
				or_text: 6,
				upload_text: 7,
				type: 19,
				dragging: 0
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Audio",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*label*/ ctx[2] === undefined && !('label' in props)) {
			console.warn("<Audio> was created without expected prop 'label'");
		}

		if (/*show_label*/ ctx[3] === undefined && !('show_label' in props)) {
			console.warn("<Audio> was created without expected prop 'show_label'");
		}

		if (/*name*/ ctx[18] === undefined && !('name' in props)) {
			console.warn("<Audio> was created without expected prop 'name'");
		}

		if (/*source*/ ctx[4] === undefined && !('source' in props)) {
			console.warn("<Audio> was created without expected prop 'source'");
		}
	}

	get value() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get source() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set source(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get drop_text() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set drop_text(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get or_text() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set or_text(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get upload_text() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set upload_text(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dragging() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dragging(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/pngwn/Projects/gradio/ui/packages/audio/src/StaticAudio.svelte generated by Svelte v3.47.0 */
const file = "Users/pngwn/Projects/gradio/ui/packages/audio/src/StaticAudio.svelte";

// (24:0) {:else}
function create_else_block$1(ctx) {
	let audio;
	let audio_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			audio = element("audio");
			attr_dev(audio, "class", "w-full h-14 p-2 mt-7");
			audio.controls = true;
			attr_dev(audio, "preload", "metadata");
			if (!src_url_equal(audio.src, audio_src_value = /*value*/ ctx[0].data)) attr_dev(audio, "src", audio_src_value);
			add_location(audio, file, 24, 1, 715);
		},
		m: function mount(target, anchor) {
			insert_dev(target, audio, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(audio, "play", /*play_handler*/ ctx[4], false, false, false),
					listen_dev(audio, "pause", /*pause_handler*/ ctx[5], false, false, false),
					listen_dev(audio, "ended", /*ended_handler*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 1 && !src_url_equal(audio.src, audio_src_value = /*value*/ ctx[0].data)) {
				attr_dev(audio, "src", audio_src_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(audio);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(24:0) {:else}",
		ctx
	});

	return block;
}

// (19:0) {#if value === null}
function create_if_block$1(ctx) {
	let div1;
	let div0;
	let music;
	let current;
	music = new Music({ $$inline: true });

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(music.$$.fragment);
			attr_dev(div0, "class", "h-5 dark:text-white opacity-50");
			add_location(div0, file, 21, 2, 638);
			attr_dev(div1, "class", "min-h-[8rem] flex justify-center items-center");
			add_location(div1, file, 19, 1, 510);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(music, div0, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(music.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(music.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(music);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(19:0) {#if value === null}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let blocklabel;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[2],
				Icon: Music,
				label: /*label*/ ctx[1] || "Audio"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[0] === null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(blocklabel.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(blocklabel, target, anchor);
			insert_dev(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const blocklabel_changes = {};
			if (dirty & /*show_label*/ 4) blocklabel_changes.show_label = /*show_label*/ ctx[2];
			if (dirty & /*label*/ 2) blocklabel_changes.label = /*label*/ ctx[1] || "Audio";
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocklabel.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(blocklabel, detaching);
			if (detaching) detach_dev(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('StaticAudio', slots, []);
	let { value = null } = $$props;
	let { label } = $$props;
	let { name } = $$props;
	let { show_label } = $$props;
	const dispatch = createEventDispatcher();
	const writable_props = ['value', 'label', 'name', 'show_label'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StaticAudio> was created with unknown prop '${key}'`);
	});

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('name' in $$props) $$invalidate(3, name = $$props.name);
		if ('show_label' in $$props) $$invalidate(2, show_label = $$props.show_label);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		BlockLabel,
		Music,
		value,
		label,
		name,
		show_label,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('name' in $$props) $$invalidate(3, name = $$props.name);
		if ('show_label' in $$props) $$invalidate(2, show_label = $$props.show_label);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value, name*/ 9) {
			value && dispatch("change", { name, data: value?.data });
		}
	};

	return [value, label, show_label, name, play_handler, pause_handler, ended_handler];
}

class StaticAudio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			value: 0,
			label: 1,
			name: 3,
			show_label: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StaticAudio",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*label*/ ctx[1] === undefined && !('label' in props)) {
			console.warn("<StaticAudio> was created without expected prop 'label'");
		}

		if (/*name*/ ctx[3] === undefined && !('name' in props)) {
			console.warn("<StaticAudio> was created without expected prop 'name'");
		}

		if (/*show_label*/ ctx[2] === undefined && !('show_label' in props)) {
			console.warn("<StaticAudio> was created without expected prop 'show_label'");
		}
	}

	get value() {
		throw new Error("<StaticAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<StaticAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<StaticAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<StaticAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<StaticAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<StaticAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<StaticAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<StaticAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Audio/Audio.svelte generated by Svelte v3.47.0 */

// (49:1) {:else}
function create_else_block(ctx) {
	let staticaudio;
	let current;

	staticaudio = new StaticAudio({
			props: {
				show_label: /*show_label*/ ctx[7],
				value: /*_value*/ ctx[9],
				name: /*_value*/ ctx[9]?.name || "audio_file",
				label: /*label*/ ctx[6]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(staticaudio.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(staticaudio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const staticaudio_changes = {};
			if (dirty & /*show_label*/ 128) staticaudio_changes.show_label = /*show_label*/ ctx[7];
			if (dirty & /*_value*/ 512) staticaudio_changes.value = /*_value*/ ctx[9];
			if (dirty & /*_value*/ 512) staticaudio_changes.name = /*_value*/ ctx[9]?.name || "audio_file";
			if (dirty & /*label*/ 64) staticaudio_changes.label = /*label*/ ctx[6];
			staticaudio.$set(staticaudio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(staticaudio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(staticaudio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(staticaudio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(49:1) {:else}",
		ctx
	});

	return block;
}

// (31:1) {#if mode === "dynamic"}
function create_if_block(ctx) {
	let audio;
	let current;

	audio = new Audio({
			props: {
				label: /*label*/ ctx[6],
				show_label: /*show_label*/ ctx[7],
				value: /*_value*/ ctx[9],
				name: /*name*/ ctx[3],
				source: /*source*/ ctx[4],
				type: /*type*/ ctx[5],
				drop_text: /*$_*/ ctx[11]("interface.drop_audio"),
				or_text: /*$_*/ ctx[11]("or"),
				upload_text: /*$_*/ ctx[11]("interface.click_to_upload")
			},
			$$inline: true
		});

	audio.$on("change", /*change_handler*/ ctx[13]);
	audio.$on("drag", /*drag_handler*/ ctx[14]);
	audio.$on("edit", /*edit_handler*/ ctx[15]);
	audio.$on("play", /*play_handler*/ ctx[16]);
	audio.$on("pause", /*pause_handler*/ ctx[17]);
	audio.$on("ended", /*ended_handler*/ ctx[18]);

	const block = {
		c: function create() {
			create_component(audio.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(audio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const audio_changes = {};
			if (dirty & /*label*/ 64) audio_changes.label = /*label*/ ctx[6];
			if (dirty & /*show_label*/ 128) audio_changes.show_label = /*show_label*/ ctx[7];
			if (dirty & /*_value*/ 512) audio_changes.value = /*_value*/ ctx[9];
			if (dirty & /*name*/ 8) audio_changes.name = /*name*/ ctx[3];
			if (dirty & /*source*/ 16) audio_changes.source = /*source*/ ctx[4];
			if (dirty & /*type*/ 32) audio_changes.type = /*type*/ ctx[5];
			if (dirty & /*$_*/ 2048) audio_changes.drop_text = /*$_*/ ctx[11]("interface.drop_audio");
			if (dirty & /*$_*/ 2048) audio_changes.or_text = /*$_*/ ctx[11]("or");
			if (dirty & /*$_*/ 2048) audio_changes.upload_text = /*$_*/ ctx[11]("interface.click_to_upload");
			audio.$set(audio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(audio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(audio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(audio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(31:1) {#if mode === \\\"dynamic\\\"}",
		ctx
	});

	return block;
}

// (21:0) <Block  variant={mode === "dynamic" && value === null && source === "upload"   ? "dashed"   : "solid"}  color={dragging ? "green" : "grey"}  padding={false}  {elem_id} >
function create_default_slot(ctx) {
	let statustracker;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const statustracker_spread_levels = [/*loading_status*/ ctx[8]];
	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new StatusTracker({
			props: statustracker_props,
			$$inline: true
		});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[2] === "dynamic") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(statustracker.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert_dev(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const statustracker_changes = (dirty & /*loading_status*/ 256)
			? get_spread_update(statustracker_spread_levels, [get_spread_object(/*loading_status*/ ctx[8])])
			: {};

			statustracker.$set(statustracker_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(statustracker, detaching);
			if (detaching) detach_dev(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(21:0) <Block  variant={mode === \\\"dynamic\\\" && value === null && source === \\\"upload\\\"   ? \\\"dashed\\\"   : \\\"solid\\\"}  color={dragging ? \\\"green\\\" : \\\"grey\\\"}  padding={false}  {elem_id} >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				variant: /*mode*/ ctx[2] === "dynamic" && /*value*/ ctx[0] === null && /*source*/ ctx[4] === "upload"
				? "dashed"
				: "solid",
				color: /*dragging*/ ctx[10] ? "green" : "grey",
				padding: false,
				elem_id: /*elem_id*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block_1 = {
		c: function create() {
			create_component(block.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const block_changes = {};

			if (dirty & /*mode, value, source*/ 21) block_changes.variant = /*mode*/ ctx[2] === "dynamic" && /*value*/ ctx[0] === null && /*source*/ ctx[4] === "upload"
			? "dashed"
			: "solid";

			if (dirty & /*dragging*/ 1024) block_changes.color = /*dragging*/ ctx[10] ? "green" : "grey";
			if (dirty & /*elem_id*/ 2) block_changes.elem_id = /*elem_id*/ ctx[1];

			if (dirty & /*$$scope, label, show_label, _value, name, source, type, $_, value, dragging, mode, loading_status*/ 528381) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(block, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block_1;
}

function instance($$self, $$props, $$invalidate) {
	let $_;
	validate_store(X, '_');
	component_subscribe($$self, X, $$value => $$invalidate(11, $_ = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Audio', slots, []);
	let { elem_id = "" } = $$props;
	let { mode } = $$props;
	let { value = null } = $$props;
	let { name } = $$props;
	let { source } = $$props;
	let { type = "normal" } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { show_label } = $$props;
	let { loading_status } = $$props;
	let _value;
	let dragging;

	const writable_props = [
		'elem_id',
		'mode',
		'value',
		'name',
		'source',
		'type',
		'label',
		'root',
		'show_label',
		'loading_status'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Audio> was created with unknown prop '${key}'`);
	});

	const change_handler = ({ detail }) => $$invalidate(0, value = detail);
	const drag_handler = ({ detail }) => $$invalidate(10, dragging = detail);

	function edit_handler(event) {
		bubble.call(this, $$self, event);
	}

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('elem_id' in $$props) $$invalidate(1, elem_id = $$props.elem_id);
		if ('mode' in $$props) $$invalidate(2, mode = $$props.mode);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('name' in $$props) $$invalidate(3, name = $$props.name);
		if ('source' in $$props) $$invalidate(4, source = $$props.source);
		if ('type' in $$props) $$invalidate(5, type = $$props.type);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('root' in $$props) $$invalidate(12, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(7, show_label = $$props.show_label);
		if ('loading_status' in $$props) $$invalidate(8, loading_status = $$props.loading_status);
	};

	$$self.$capture_state = () => ({
		Audio,
		StaticAudio,
		normalise_file,
		Block,
		StatusTracker,
		_: X,
		elem_id,
		mode,
		value,
		name,
		source,
		type,
		label,
		root,
		show_label,
		loading_status,
		_value,
		dragging,
		$_
	});

	$$self.$inject_state = $$props => {
		if ('elem_id' in $$props) $$invalidate(1, elem_id = $$props.elem_id);
		if ('mode' in $$props) $$invalidate(2, mode = $$props.mode);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('name' in $$props) $$invalidate(3, name = $$props.name);
		if ('source' in $$props) $$invalidate(4, source = $$props.source);
		if ('type' in $$props) $$invalidate(5, type = $$props.type);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('root' in $$props) $$invalidate(12, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(7, show_label = $$props.show_label);
		if ('loading_status' in $$props) $$invalidate(8, loading_status = $$props.loading_status);
		if ('_value' in $$props) $$invalidate(9, _value = $$props._value);
		if ('dragging' in $$props) $$invalidate(10, dragging = $$props.dragging);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value, root*/ 4097) {
			$$invalidate(9, _value = normalise_file(value, root));
		}
	};

	return [
		value,
		elem_id,
		mode,
		name,
		source,
		type,
		label,
		show_label,
		loading_status,
		_value,
		dragging,
		$_,
		root,
		change_handler,
		drag_handler,
		edit_handler,
		play_handler,
		pause_handler,
		ended_handler
	];
}

class Audio_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			elem_id: 1,
			mode: 2,
			value: 0,
			name: 3,
			source: 4,
			type: 5,
			label: 6,
			root: 12,
			show_label: 7,
			loading_status: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Audio_1",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[2] === undefined && !('mode' in props)) {
			console.warn("<Audio> was created without expected prop 'mode'");
		}

		if (/*name*/ ctx[3] === undefined && !('name' in props)) {
			console.warn("<Audio> was created without expected prop 'name'");
		}

		if (/*source*/ ctx[4] === undefined && !('source' in props)) {
			console.warn("<Audio> was created without expected prop 'source'");
		}

		if (/*label*/ ctx[6] === undefined && !('label' in props)) {
			console.warn("<Audio> was created without expected prop 'label'");
		}

		if (/*root*/ ctx[12] === undefined && !('root' in props)) {
			console.warn("<Audio> was created without expected prop 'root'");
		}

		if (/*show_label*/ ctx[7] === undefined && !('show_label' in props)) {
			console.warn("<Audio> was created without expected prop 'show_label'");
		}

		if (/*loading_status*/ ctx[8] === undefined && !('loading_status' in props)) {
			console.warn("<Audio> was created without expected prop 'loading_status'");
		}
	}

	get elem_id() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set elem_id(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get source() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set source(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get root() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set root(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loading_status() {
		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loading_status(value) {
		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Audio_1$1 = Audio_1;

const modes = ["static", "dynamic"];

export { Audio_1$1 as Component, modes };
