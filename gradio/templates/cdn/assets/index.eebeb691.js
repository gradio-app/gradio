import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, h as element, b as attr_dev, t as toggle_class, c as add_location, e as insert_dev, aa as set_input_value, l as listen_dev, g as detach_dev, r as run_all, w as space, k as text, f as append_dev, m as set_data_dev, n as noop, K as bubble, I as binding_callbacks, L as bind, y as createEventDispatcher, ab as tick, a as svg_element, B as create_component, q as empty, C as mount_component, M as add_flush_callback, D as transition_in, E as transition_out, F as destroy_component, o as validate_each_argument, ac as validate_each_keys, G as group_outros, ad as update_keyed_each, ae as outro_and_destroy_block, H as check_outros, T as assign, R as StatusTracker, U as get_spread_update, V as get_spread_object } from './index.a172f41e.js';
import { U as Upload } from './Upload.56241c10.js';
import { d as dsvFormat } from './dsv.7fe76a93.js';

var has = Object.prototype.hasOwnProperty;

function dequal(foo, bar) {
	var ctor, len;
	if (foo === bar) return true;

	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
		if (ctor === Date) return foo.getTime() === bar.getTime();
		if (ctor === RegExp) return foo.toString() === bar.toString();

		if (ctor === Array) {
			if ((len=foo.length) === bar.length) {
				while (len-- && dequal(foo[len], bar[len]));
			}
			return len === -1;
		}

		if (!ctor || typeof foo === 'object') {
			len = 0;
			for (ctor in foo) {
				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
			}
			return Object.keys(bar).length === len;
		}
	}

	return foo !== foo && bar !== bar;
}

/* Users/pngwn/Projects/gradio/ui/packages/table/src/EditableCell.svelte generated by Svelte v3.47.0 */

const file$2 = "Users/pngwn/Projects/gradio/ui/packages/table/src/EditableCell.svelte";

// (7:0) {#if edit}
function create_if_block$1(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "class", "absolute outline-none inset-2 bg-transparent border-0 translate-x-px flex-1 ");
			attr_dev(input, "tabindex", "-1");
			toggle_class(input, "translate-x-px", !/*header*/ ctx[3]);
			toggle_class(input, "font-bold", /*header*/ ctx[3]);
			add_location(input, file$2, 7, 1, 123);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			/*input_binding*/ ctx[7](input);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
					listen_dev(input, "keydown", /*keydown_handler*/ ctx[5], false, false, false),
					listen_dev(input, "blur", blur_handler, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*header*/ 8) {
				toggle_class(input, "translate-x-px", !/*header*/ ctx[3]);
			}

			if (dirty & /*header*/ 8) {
				toggle_class(input, "font-bold", /*header*/ ctx[3]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*input_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(7:0) {#if edit}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let t0;
	let span;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*edit*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t0 = space();
			span = element("span");
			t1 = text(/*value*/ ctx[0]);
			attr_dev(span, "tabindex", "-1");
			attr_dev(span, "role", "button");
			attr_dev(span, "class", "p-2 outline-none border-0 flex-1");
			toggle_class(span, "opacity-0", /*edit*/ ctx[2]);
			toggle_class(span, "pointer-events-none", /*edit*/ ctx[2]);
			add_location(span, file$2, 19, 0, 429);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span, anchor);
			append_dev(span, t1);

			if (!mounted) {
				dispose = listen_dev(span, "dblclick", /*dblclick_handler*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*edit*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*value*/ 1) set_data_dev(t1, /*value*/ ctx[0]);

			if (dirty & /*edit*/ 4) {
				toggle_class(span, "opacity-0", /*edit*/ ctx[2]);
			}

			if (dirty & /*edit*/ 4) {
				toggle_class(span, "pointer-events-none", /*edit*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const blur_handler = ({ currentTarget }) => currentTarget.setAttribute("tabindex", "-1");

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditableCell', slots, []);
	let { edit } = $$props;
	let { value = "" } = $$props;
	let { el } = $$props;
	let { header = false } = $$props;
	const writable_props = ['edit', 'value', 'el', 'header'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditableCell> was created with unknown prop '${key}'`);
	});

	function dblclick_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$props => {
		if ('edit' in $$props) $$invalidate(2, edit = $$props.edit);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('el' in $$props) $$invalidate(1, el = $$props.el);
		if ('header' in $$props) $$invalidate(3, header = $$props.header);
	};

	$$self.$capture_state = () => ({ edit, value, el, header });

	$$self.$inject_state = $$props => {
		if ('edit' in $$props) $$invalidate(2, edit = $$props.edit);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('el' in $$props) $$invalidate(1, el = $$props.el);
		if ('header' in $$props) $$invalidate(3, header = $$props.header);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		value,
		el,
		edit,
		header,
		dblclick_handler,
		keydown_handler,
		input_input_handler,
		input_binding
	];
}

class EditableCell extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { edit: 2, value: 0, el: 1, header: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditableCell",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*edit*/ ctx[2] === undefined && !('edit' in props)) {
			console.warn("<EditableCell> was created without expected prop 'edit'");
		}

		if (/*el*/ ctx[1] === undefined && !('el' in props)) {
			console.warn("<EditableCell> was created without expected prop 'el'");
		}
	}

	get edit() {
		throw new Error("<EditableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set edit(value) {
		throw new Error("<EditableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<EditableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<EditableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get el() {
		throw new Error("<EditableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set el(value) {
		throw new Error("<EditableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get header() {
		throw new Error("<EditableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set header(value) {
		throw new Error("<EditableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/pngwn/Projects/gradio/ui/packages/table/src/Table.svelte generated by Svelte v3.47.0 */
const file$1 = "Users/pngwn/Projects/gradio/ui/packages/table/src/Table.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[47] = list[i];
	child_ctx[49] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[50] = list[i].value;
	child_ctx[51] = list[i].id;
	child_ctx[52] = list;
	child_ctx[53] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[50] = list[i].value;
	child_ctx[51] = list[i].id;
	child_ctx[54] = list;
	child_ctx[49] = i;
	return child_ctx;
}

// (391:5) {#each _headers as { value, id }
function create_each_block_2(key_1, ctx) {
	let th;
	let div1;
	let editablecell;
	let updating_el;
	let t0;
	let div0;
	let svg;
	let path;
	let div0_class_value;
	let t1;
	let th_aria_sort_value;
	let id = /*id*/ ctx[51];
	let current;
	let mounted;
	let dispose;

	function editablecell_el_binding(value) {
		/*editablecell_el_binding*/ ctx[27](value, /*id*/ ctx[51]);
	}

	function dblclick_handler() {
		return /*dblclick_handler*/ ctx[28](/*id*/ ctx[51]);
	}

	let editablecell_props = {
		value: /*value*/ ctx[50],
		edit: /*header_edit*/ ctx[10] === /*id*/ ctx[51],
		header: true
	};

	if (/*els*/ ctx[7][/*id*/ ctx[51]].input !== void 0) {
		editablecell_props.el = /*els*/ ctx[7][/*id*/ ctx[51]].input;
	}

	editablecell = new EditableCell({
			props: editablecell_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(editablecell, 'el', editablecell_el_binding));
	editablecell.$on("keydown", /*end_header_edit*/ ctx[18]);
	editablecell.$on("dblclick", dblclick_handler);

	function click_handler() {
		return /*click_handler*/ ctx[29](/*i*/ ctx[49]);
	}

	const assign_th = () => /*th_binding*/ ctx[30](th, id);
	const unassign_th = () => /*th_binding*/ ctx[30](null, id);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			th = element("th");
			div1 = element("div");
			create_component(editablecell.$$.fragment);
			t0 = space();
			div0 = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			t1 = space();
			attr_dev(path, "d", "M4.49999 0L8.3971 6.75H0.602875L4.49999 0Z");
			add_location(path, file$1, 429, 10, 13059);
			attr_dev(svg, "width", "1em");
			attr_dev(svg, "height", "1em");
			attr_dev(svg, "class", "fill-current text-[10px]");
			attr_dev(svg, "viewBox", "0 0 9 7");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			add_location(svg, file$1, 421, 9, 12850);

			attr_dev(div0, "class", div0_class_value = "flex flex-none items-center justify-center p-2 cursor-pointer leading-snug transform transition-all " + (/*sort_by*/ ctx[9] !== /*i*/ ctx[49]
			? 'text-gray-200 hover:text-gray-500'
			: 'text-orange-500') + " " + (/*sort_by*/ ctx[9] === /*i*/ ctx[49] && /*sort_direction*/ ctx[8] === 'des'
			? '-scale-y-[1]'
			: ''));

			toggle_class(div0, "text-gray-200", /*sort_by*/ ctx[9] !== /*i*/ ctx[49]);
			add_location(div0, file$1, 410, 8, 12424);
			attr_dev(div1, "class", "min-h-[2.3rem] flex outline-none");
			add_location(div1, file$1, 400, 7, 12151);
			attr_dev(th, "class", "p-0 relative focus-within:ring-1 ring-orange-500 ring-inset outline-none ");
			attr_dev(th, "aria-sort", th_aria_sort_value = /*get_sort_status*/ ctx[12](/*value*/ ctx[50], /*sort_by*/ ctx[9], /*sort_direction*/ ctx[8]));
			toggle_class(th, "bg-orange-50", /*header_edit*/ ctx[10] === /*id*/ ctx[51]);
			toggle_class(th, "dark:bg-transparent", /*header_edit*/ ctx[10] === /*id*/ ctx[51]);
			toggle_class(th, "rounded-tl-lg", /*i*/ ctx[49] === 0);
			toggle_class(th, "rounded-tr-lg", /*i*/ ctx[49] === /*_headers*/ ctx[5].length - 1);
			add_location(th, file$1, 391, 6, 11751);
			this.first = th;
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, div1);
			mount_component(editablecell, div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, svg);
			append_dev(svg, path);
			append_dev(th, t1);
			assign_th();
			current = true;

			if (!mounted) {
				dispose = listen_dev(div0, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const editablecell_changes = {};
			if (dirty[0] & /*_headers*/ 32) editablecell_changes.value = /*value*/ ctx[50];
			if (dirty[0] & /*header_edit, _headers*/ 1056) editablecell_changes.edit = /*header_edit*/ ctx[10] === /*id*/ ctx[51];

			if (!updating_el && dirty[0] & /*els, _headers*/ 160) {
				updating_el = true;
				editablecell_changes.el = /*els*/ ctx[7][/*id*/ ctx[51]].input;
				add_flush_callback(() => updating_el = false);
			}

			editablecell.$set(editablecell_changes);

			if (!current || dirty[0] & /*sort_by, _headers, sort_direction*/ 800 && div0_class_value !== (div0_class_value = "flex flex-none items-center justify-center p-2 cursor-pointer leading-snug transform transition-all " + (/*sort_by*/ ctx[9] !== /*i*/ ctx[49]
			? 'text-gray-200 hover:text-gray-500'
			: 'text-orange-500') + " " + (/*sort_by*/ ctx[9] === /*i*/ ctx[49] && /*sort_direction*/ ctx[8] === 'des'
			? '-scale-y-[1]'
			: ''))) {
				attr_dev(div0, "class", div0_class_value);
			}

			if (dirty[0] & /*sort_by, _headers, sort_direction, sort_by, _headers*/ 800) {
				toggle_class(div0, "text-gray-200", /*sort_by*/ ctx[9] !== /*i*/ ctx[49]);
			}

			if (!current || dirty[0] & /*_headers, sort_by, sort_direction*/ 800 && th_aria_sort_value !== (th_aria_sort_value = /*get_sort_status*/ ctx[12](/*value*/ ctx[50], /*sort_by*/ ctx[9], /*sort_direction*/ ctx[8]))) {
				attr_dev(th, "aria-sort", th_aria_sort_value);
			}

			if (id !== /*id*/ ctx[51]) {
				unassign_th();
				id = /*id*/ ctx[51];
				assign_th();
			}

			if (dirty[0] & /*header_edit, _headers*/ 1056) {
				toggle_class(th, "bg-orange-50", /*header_edit*/ ctx[10] === /*id*/ ctx[51]);
			}

			if (dirty[0] & /*header_edit, _headers*/ 1056) {
				toggle_class(th, "dark:bg-transparent", /*header_edit*/ ctx[10] === /*id*/ ctx[51]);
			}

			if (dirty[0] & /*_headers*/ 32) {
				toggle_class(th, "rounded-tl-lg", /*i*/ ctx[49] === 0);
			}

			if (dirty[0] & /*_headers*/ 32) {
				toggle_class(th, "rounded-tr-lg", /*i*/ ctx[49] === /*_headers*/ ctx[5].length - 1);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editablecell.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editablecell.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			destroy_component(editablecell);
			unassign_th();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(391:5) {#each _headers as { value, id }",
		ctx
	});

	return block;
}

// (444:6) {#each row as { value, id }
function create_each_block_1(key_1, ctx) {
	let td;
	let div;
	let editablecell;
	let updating_value;
	let updating_el;
	let id = /*id*/ ctx[51];
	let current;
	let mounted;
	let dispose;

	function editablecell_value_binding(value) {
		/*editablecell_value_binding*/ ctx[31](value, /*value*/ ctx[50], /*each_value_1*/ ctx[52], /*j*/ ctx[53]);
	}

	function editablecell_el_binding_1(value) {
		/*editablecell_el_binding_1*/ ctx[32](value, /*id*/ ctx[51]);
	}

	let editablecell_props = {
		edit: /*editing*/ ctx[3] === /*id*/ ctx[51]
	};

	if (/*value*/ ctx[50] !== void 0) {
		editablecell_props.value = /*value*/ ctx[50];
	}

	if (/*els*/ ctx[7][/*id*/ ctx[51]].input !== void 0) {
		editablecell_props.el = /*els*/ ctx[7][/*id*/ ctx[51]].input;
	}

	editablecell = new EditableCell({
			props: editablecell_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(editablecell, 'value', editablecell_value_binding));
	binding_callbacks.push(() => bind(editablecell, 'el', editablecell_el_binding_1));
	const assign_td = () => /*td_binding*/ ctx[33](td, id);
	const unassign_td = () => /*td_binding*/ ctx[33](null, id);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[34](/*id*/ ctx[51]);
	}

	function dblclick_handler_1() {
		return /*dblclick_handler_1*/ ctx[35](/*id*/ ctx[51]);
	}

	function keydown_handler(...args) {
		return /*keydown_handler*/ ctx[36](/*i*/ ctx[49], /*j*/ ctx[53], /*id*/ ctx[51], ...args);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			td = element("td");
			div = element("div");
			create_component(editablecell.$$.fragment);
			attr_dev(div, "class", "min-h-[2.3rem] h-full outline-none flex items-center");
			toggle_class(div, "border-transparent", /*selected*/ ctx[4] !== /*id*/ ctx[51]);
			add_location(div, file$1, 452, 8, 14044);
			attr_dev(td, "tabindex", "0");
			attr_dev(td, "class", "outline-none focus-within:ring-1 ring-orange-500 ring-inset focus-within:bg-orange-50 dark:focus-within:bg-gray-800 group-last:first:rounded-bl-lg group-last:last:rounded-br-lg relative");
			add_location(td, file$1, 444, 7, 13620);
			this.first = td;
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, div);
			mount_component(editablecell, div, null);
			assign_td();
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(td, "click", click_handler_1, false, false, false),
					listen_dev(td, "dblclick", dblclick_handler_1, false, false, false),
					listen_dev(td, "keydown", keydown_handler, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const editablecell_changes = {};
			if (dirty[0] & /*editing, data*/ 72) editablecell_changes.edit = /*editing*/ ctx[3] === /*id*/ ctx[51];

			if (!updating_value && dirty[0] & /*data*/ 64) {
				updating_value = true;
				editablecell_changes.value = /*value*/ ctx[50];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_el && dirty[0] & /*els, data*/ 192) {
				updating_el = true;
				editablecell_changes.el = /*els*/ ctx[7][/*id*/ ctx[51]].input;
				add_flush_callback(() => updating_el = false);
			}

			editablecell.$set(editablecell_changes);

			if (dirty[0] & /*selected, data*/ 80) {
				toggle_class(div, "border-transparent", /*selected*/ ctx[4] !== /*id*/ ctx[51]);
			}

			if (id !== /*id*/ ctx[51]) {
				unassign_td();
				id = /*id*/ ctx[51];
				assign_td();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editablecell.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editablecell.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(editablecell);
			unassign_td();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(444:6) {#each row as { value, id }",
		ctx
	});

	return block;
}

// (440:4) {#each data as row, i (row)}
function create_each_block(key_1, ctx) {
	let tr;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let current;
	let each_value_1 = /*row*/ ctx[47];
	validate_each_argument(each_value_1);
	const get_key = ctx => /*id*/ ctx[51];
	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "class", "group border-b dark:border-gray-700 last:border-none divide-x dark:divide-gray-700 space-x-4 odd:bg-gray-50 dark:odd:bg-gray-900 group focus:bg-gradient-to-b focus:from-blue-100 dark:focus:from-blue-900 focus:to-blue-50 dark:focus:to-gray-900 focus:odd:bg-white");
			add_location(tr, file$1, 440, 5, 13283);
			this.first = tr;
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*els, data, handle_cell_click, start_edit, handle_keydown, selected, editing*/ 57560) {
				each_value_1 = /*row*/ ctx[47];
				validate_each_argument(each_value_1);
				group_outros();
				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, tr, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(440:4) {#each data as row, i (row)}",
		ctx
	});

	return block;
}

// (375:1) <Upload   flex={false}   center={false}   boundedheight={false}   click={false}   on:load={(e) => blob_to_string(data_uri_to_blob(e.detail.data))}   bind:dragging  >
function create_default_slot(ctx) {
	let table;
	let thead;
	let tr;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let t;
	let tbody;
	let each_blocks = [];
	let each1_lookup = new Map();
	let current;
	let each_value_2 = /*_headers*/ ctx[5];
	validate_each_argument(each_value_2);
	const get_key = ctx => /*id*/ ctx[51];
	validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_2(key, child_ctx));
	}

	let each_value = /*data*/ ctx[6];
	validate_each_argument(each_value);
	const get_key_1 = ctx => /*row*/ ctx[47];
	validate_each_keys(ctx, each_value, get_each_context, get_key_1);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			table = element("table");
			thead = element("thead");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(tr, "class", "border-b dark:border-gray-700 divide-x dark:divide-gray-700 text-left");
			add_location(tr, file$1, 387, 4, 11604);
			attr_dev(thead, "class", "sticky top-0 left-0 right-0 bg-white shadow-sm z-10");
			add_location(thead, file$1, 386, 3, 11532);
			attr_dev(tbody, "class", "overflow-y-scroll");
			add_location(tbody, file$1, 438, 3, 13211);
			attr_dev(table, "class", "table-auto font-mono w-full text-gray-900 text-sm transition-opacity overflow-hidden ");
			toggle_class(table, "opacity-40", /*dragging*/ ctx[11]);
			add_location(table, file$1, 382, 2, 11390);
		},
		m: function mount(target, anchor) {
			insert_dev(target, table, anchor);
			append_dev(table, thead);
			append_dev(thead, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(table, t);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*get_sort_status, _headers, sort_by, sort_direction, els, header_edit, handle_sort, end_header_edit, edit_header*/ 464800) {
				each_value_2 = /*_headers*/ ctx[5];
				validate_each_argument(each_value_2);
				group_outros();
				validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_2, each0_lookup, tr, outro_and_destroy_block, create_each_block_2, null, get_each_context_2);
				check_outros();
			}

			if (dirty[0] & /*data, els, handle_cell_click, start_edit, handle_keydown, selected, editing*/ 57560) {
				each_value = /*data*/ ctx[6];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key_1);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, tbody, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}

			if (dirty[0] & /*dragging*/ 2048) {
				toggle_class(table, "opacity-40", /*dragging*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(table);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(375:1) <Upload   flex={false}   center={false}   boundedheight={false}   click={false}   on:load={(e) => blob_to_string(data_uri_to_blob(e.detail.data))}   bind:dragging  >",
		ctx
	});

	return block;
}

// (471:0) {#if editable}
function create_if_block(ctx) {
	let div;
	let t;
	let if_block0 = /*row_count*/ ctx[1][1] === "dynamic" && create_if_block_2(ctx);
	let if_block1 = /*col_count*/ ctx[0][1] === "dynamic" && create_if_block_1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "flex justify-end space-x-1 pt-2 text-gray-800");
			add_location(div, file$1, 471, 1, 14426);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t);
			if (if_block1) if_block1.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (/*row_count*/ ctx[1][1] === "dynamic") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*col_count*/ ctx[0][1] === "dynamic") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(471:0) {#if editable}",
		ctx
	});

	return block;
}

// (473:2) {#if row_count[1] === "dynamic"}
function create_if_block_2(ctx) {
	let button;
	let svg;
	let path;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			svg = svg_element("svg");
			path = svg_element("path");
			t = text("New row");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M24.59 16.59L17 24.17V4h-2v20.17l-7.59-7.58L6 18l10 10l10-10l-1.41-1.41z");
			add_location(path, file$1, 484, 6, 14885);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "class", "mr-1 group-hover:text-orange-500");
			attr_dev(svg, "width", "1em");
			attr_dev(svg, "height", "1em");
			attr_dev(svg, "preserveAspectRatio", "xMidYMid meet");
			attr_dev(svg, "viewBox", "0 0 32 32");
			add_location(svg, file$1, 474, 5, 14599);
			attr_dev(button, "class", "!flex-none gr-button group");
			add_location(button, file$1, 473, 3, 14524);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, svg);
			append_dev(svg, path);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[39], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(473:2) {#if row_count[1] === \\\"dynamic\\\"}",
		ctx
	});

	return block;
}

// (492:2) {#if col_count[1] === "dynamic"}
function create_if_block_1(ctx) {
	let button;
	let svg;
	let path;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			svg = svg_element("svg");
			path = svg_element("path");
			t = text("\n\t\t\t\tNew column");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "m18 6l-1.43 1.393L24.15 15H4v2h20.15l-7.58 7.573L18 26l10-10L18 6z");
			add_location(path, file$1, 503, 6, 15438);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "class", "mr-1 group-hover:text-orange-500");
			attr_dev(svg, "width", "1em");
			attr_dev(svg, "height", "1em");
			attr_dev(svg, "preserveAspectRatio", "xMidYMid meet");
			attr_dev(svg, "viewBox", "0 0 32 32");
			add_location(svg, file$1, 493, 4, 15152);
			attr_dev(button, "class", "!flex-none gr-button group");
			add_location(button, file$1, 492, 3, 15085);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, svg);
			append_dev(svg, path);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*add_col*/ ctx[20], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(492:2) {#if col_count[1] === \\\"dynamic\\\"}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let upload;
	let updating_dragging;
	let t;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	function upload_dragging_binding(value) {
		/*upload_dragging_binding*/ ctx[37](value);
	}

	let upload_props = {
		flex: false,
		center: false,
		boundedheight: false,
		click: false,
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*dragging*/ ctx[11] !== void 0) {
		upload_props.dragging = /*dragging*/ ctx[11];
	}

	upload = new Upload({ props: upload_props, $$inline: true });
	binding_callbacks.push(() => bind(upload, 'dragging', upload_dragging_binding));
	upload.$on("load", /*load_handler*/ ctx[38]);
	let if_block = /*editable*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(upload.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(div, "class", "scroll-hide whitespace-nowrap overflow-hidden rounded-lg relative border transition-colors overflow-x-scroll");
			toggle_class(div, "border-green-400", /*dragging*/ ctx[11]);
			add_location(div, file$1, 370, 0, 11061);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(upload, div, null);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window, "click", /*handle_click_outside*/ ctx[21], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const upload_changes = {};

			if (dirty[0] & /*dragging, data, els, selected, editing, _headers, sort_by, sort_direction, header_edit*/ 4088 | dirty[1] & /*$$scope*/ 16777216) {
				upload_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 2048) {
				updating_dragging = true;
				upload_changes.dragging = /*dragging*/ ctx[11];
				add_flush_callback(() => updating_dragging = false);
			}

			upload.$set(upload_changes);

			if (dirty[0] & /*dragging*/ 2048) {
				toggle_class(div, "border-green-400", /*dragging*/ ctx[11]);
			}

			if (/*editable*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(upload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(upload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(upload);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function guess_delimitaor(text, possibleDelimiters) {
	return possibleDelimiters.filter(weedOut);

	function weedOut(delimiter) {
		var cache = -1;
		return text.split("\n").every(checkLength);

		function checkLength(line) {
			if (!line) {
				return true;
			}

			var length = line.split(delimiter).length;

			if (cache < 0) {
				cache = length;
			}

			return cache === length && length > 1;
		}
	}
}

function data_uri_to_blob(data_uri) {
	const byte_str = atob(data_uri.split(",")[1]);
	const mime_str = data_uri.split(",")[0].split(":")[1].split(";")[0];
	const ab = new ArrayBuffer(byte_str.length);
	const ia = new Uint8Array(ab);

	for (let i = 0; i < byte_str.length; i++) {
		ia[i] = byte_str.charCodeAt(i);
	}

	return new Blob([ab], { type: mime_str });
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Table', slots, []);
	let { headers = [] } = $$props;
	let { values = [[]] } = $$props;
	let { col_count } = $$props;
	let { row_count } = $$props;
	let { editable = true } = $$props;
	const dispatch = createEventDispatcher();
	let editing = false;
	let selected = false;
	let els = {};

	function make_headers(_head) {
		let _h = _head || [];

		if (col_count[1] === "fixed" && _h.length < col_count[0]) {
			const fill = Array(col_count[0] - _h.length).fill("").map((v, i) => `${i + _h.length}`);
			_h = _h.concat(fill);
		}

		if (!_h || _h.length === 0) {
			return Array(col_count[0]).fill(0).map((_, i) => {
				const _id = `h-${i}`;
				$$invalidate(7, els[_id] = { cell: null, input: null }, els);
				return { id: _id, value: JSON.stringify(i + 1) };
			});
		} else {
			return _h.map((h, i) => {
				const _id = `h-${i}`;
				$$invalidate(7, els[_id] = { cell: null, input: null }, els);
				return { id: _id, value: h || "" };
			});
		}
	}

	function process_data(_values) {
		const data_row_length = _values.length > 0 ? _values.length : row_count[0];

		return Array(row_count[1] === "fixed"
		? row_count[0]
		: data_row_length < row_count[0]
			? row_count[0]
			: data_row_length).fill(0).map((x, i) => Array(col_count[1] === "fixed"
		? col_count[0]
		: _values[0].length).fill(0).map((n, j) => {
			const id = `${i}-${j}`;
			$$invalidate(7, els[id] = { input: null, cell: null }, els);
			return { value: _values?.[i]?.[j] || "", id };
		}));
	}

	let _headers = make_headers(headers);
	let old_headers;

	async function refresh_focus() {
		if (typeof editing === "string") {
			await tick();
			els[editing]?.input?.focus();
		} else if (typeof selected === "string") {
			await tick();
			els[selected]?.input?.focus();
		}
	}

	let data = [[]];
	let old_val = undefined;

	function get_sort_status(name, sort, direction) {
		if (!sort) return "none";

		if (headers[sort] === name) {
			if (direction === "asc") return "ascending";
			if (direction === "des") return "descending";
		}
	}

	function get_current_indices(id) {
		return data.reduce(
			(acc, arr, i) => {
				const j = arr.reduce((acc, data, j) => id === data.id ? j : acc, -1);
				return j === -1 ? acc : [i, j];
			},
			[-1, -1]
		);
	}

	async function start_edit(id, clear) {
		if (!editable || editing === id) return;

		if (clear) {
			const [i, j] = get_current_indices(id);
			$$invalidate(6, data[i][j].value = "", data);
		}

		$$invalidate(3, editing = id);
		await tick();
		const { input } = els[id];
		input?.focus();
	}

	async function handle_keydown(event, i, j, id) {
		let is_data;

		switch (event.key) {
			case "ArrowRight":
				if (editing) break;
				event.preventDefault();
				is_data = data[i][j + 1];
				$$invalidate(4, selected = is_data ? is_data.id : selected);
				break;
			case "ArrowLeft":
				if (editing) break;
				event.preventDefault();
				is_data = data[i][j - 1];
				$$invalidate(4, selected = is_data ? is_data.id : selected);
				break;
			case "ArrowDown":
				if (editing) break;
				event.preventDefault();
				is_data = data[i + 1];
				$$invalidate(4, selected = is_data ? is_data[j].id : selected);
				break;
			case "ArrowUp":
				if (editing) break;
				event.preventDefault();
				is_data = data[i - 1];
				$$invalidate(4, selected = is_data ? is_data[j].id : selected);
				break;
			case "Escape":
				if (!editable) break;
				event.preventDefault();
				$$invalidate(4, selected = editing);
				$$invalidate(3, editing = false);
				break;
			case "Enter":
				if (!editable) break;
				event.preventDefault();
				if (event.shiftKey) {
					add_row(i);
					await tick();
					const [pos] = get_current_indices(id);
					$$invalidate(4, selected = data[pos + 1][j].id);
				} else {
					if (editing === id) {
						$$invalidate(3, editing = false);
					} else {
						start_edit(id);
					}
				}
				break;
			case "Backspace":
				if (!editable) break;
				if (!editing) {
					event.preventDefault();
					$$invalidate(6, data[i][j].value = "", data);
				}
				break;
			case "Delete":
				if (!editable) break;
				if (!editing) {
					event.preventDefault();
					$$invalidate(6, data[i][j].value = "", data);
				}
				break;
			case "Tab":
				let direction = event.shiftKey ? -1 : 1;
				let is_data_x = data[i][j + direction];
				let is_data_y = data?.[i + direction]?.[direction > 0 ? 0 : _headers.length - 1];
				let _selected = is_data_x || is_data_y;
				if (_selected) {
					event.preventDefault();
					$$invalidate(4, selected = _selected ? _selected.id : selected);
				}
				$$invalidate(3, editing = false);
				break;
			default:
				if ((!editing || editing && editing !== id) && event.key.length === 1) {
					start_edit(id, true);
				}
				break;
		}
	}

	async function handle_cell_click(id) {
		if (editing === id) return;
		if (selected === id) return;
		$$invalidate(3, editing = false);
		$$invalidate(4, selected = id);
	}

	async function set_focus(id, type) {
		if (type === "edit" && typeof id == "string") {
			await tick();
			els[id].input?.focus();
		}

		if (type === "edit" && typeof id == "boolean" && typeof selected === "string") {
			let cell = els[selected]?.cell;
			await tick();
			cell?.focus();
		}

		if (type === "select" && typeof id == "string") {
			const { cell } = els[id];

			// cell?.setAttribute("tabindex", "0");
			await tick();

			cell?.focus();
		}
	}

	let sort_direction;
	let sort_by;

	function sort(col, dir) {
		if (dir === "asc") {
			$$invalidate(6, data = data.sort((a, b) => a[col].value < b[col].value ? -1 : 1));
		} else if (dir === "des") {
			$$invalidate(6, data = data.sort((a, b) => a[col].value > b[col].value ? -1 : 1));
		}
	}

	function handle_sort(col) {
		if (typeof sort_by !== "number" || sort_by !== col) {
			$$invalidate(8, sort_direction = "asc");
			$$invalidate(9, sort_by = col);
		} else {
			if (sort_direction === "asc") {
				$$invalidate(8, sort_direction = "des");
			} else if (sort_direction === "des") {
				$$invalidate(8, sort_direction = "asc");
			}
		}

		sort(col, sort_direction);
	}

	let header_edit;

	async function edit_header(_id, select) {
		if (!editable || col_count[1] !== "dynamic" || editing === _id) return;
		$$invalidate(10, header_edit = _id);
		await tick();
		els[_id].input?.focus();
		if (select) els[_id].input?.select();
	}

	function end_header_edit(event) {
		if (!editable) return;

		switch (event.key) {
			case "Escape":
				event.preventDefault();
				$$invalidate(4, selected = header_edit);
				$$invalidate(10, header_edit = false);
				break;
			case "Enter":
				event.preventDefault();
				$$invalidate(4, selected = header_edit);
				$$invalidate(10, header_edit = false);
		}
	}

	function add_row(index) {
		if (row_count[1] !== "dynamic") return;

		data.splice(index ? index + 1 : data.length, 0, Array(col_count[0]).fill(0).map((_, i) => {
			const _id = `${data.length}-${i}`;
			$$invalidate(7, els[_id] = { cell: null, input: null }, els);
			return { id: _id, value: "" };
		}));

		(($$invalidate(6, data), $$invalidate(23, values)), $$invalidate(26, old_val));
	}

	async function add_col() {
		if (col_count[1] !== "dynamic") return;

		for (let i = 0; i < data.length; i++) {
			const _id = `${i}-${data[i].length}`;
			$$invalidate(7, els[_id] = { cell: null, input: null }, els);
			data[i].push({ id: _id, value: "" });
		}

		const _id = `h-${_headers.length}`;
		$$invalidate(7, els[_id] = { cell: null, input: null }, els);

		_headers.push({
			id: _id,
			value: `Header ${_headers.length + 1}`
		});

		(($$invalidate(6, data), $$invalidate(23, values)), $$invalidate(26, old_val));
		(($$invalidate(5, _headers), $$invalidate(24, headers)), $$invalidate(25, old_headers));
		await tick();
		edit_header(_id, true);
	}

	function handle_click_outside(event) {
		if (typeof editing === "string" && els[editing]) {
			if (els[editing].cell !== event.target && !els[editing].cell?.contains(event?.target)) {
				$$invalidate(10, header_edit = false);
			}
		}

		if (typeof header_edit === "string" && els[header_edit]) {
			if (els[header_edit].cell !== event.target && !els[header_edit].cell?.contains(event.target)) {
				$$invalidate(10, header_edit = false);
			}
		}
	}

	function blob_to_string(blob) {
		const reader = new FileReader();

		function handle_read(e) {
			if (!e?.target?.result || typeof e.target.result !== "string") return;
			const [delimiter] = guess_delimitaor(e.target.result, [",", "\t"]);
			const [head, ...rest] = dsvFormat(delimiter).parseRows(e.target.result);

			$$invalidate(5, _headers = make_headers(col_count[1] === "fixed"
			? head.slice(0, col_count[0])
			: head));

			$$invalidate(23, values = rest);
			reader.removeEventListener("loadend", handle_read);
		}

		reader.addEventListener("loadend", handle_read);
		reader.readAsText(blob);
	}

	let dragging = false;
	const writable_props = ['headers', 'values', 'col_count', 'row_count', 'editable'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table> was created with unknown prop '${key}'`);
	});

	function editablecell_el_binding(value, id) {
		if ($$self.$$.not_equal(els[id].input, value)) {
			els[id].input = value;
			$$invalidate(7, els);
		}
	}

	const dblclick_handler = id => edit_header(id);
	const click_handler = i => handle_sort(i);

	function th_binding($$value, id) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			els[id].cell = $$value;
			$$invalidate(7, els);
		});
	}

	function editablecell_value_binding(value$1, value, each_value_1, j) {
		each_value_1[j].value = value$1;
		(($$invalidate(6, data), $$invalidate(23, values)), $$invalidate(26, old_val));
	}

	function editablecell_el_binding_1(value, id) {
		if ($$self.$$.not_equal(els[id].input, value)) {
			els[id].input = value;
			$$invalidate(7, els);
		}
	}

	function td_binding($$value, id) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			els[id].cell = $$value;
			$$invalidate(7, els);
		});
	}

	const click_handler_1 = id => handle_cell_click(id);
	const dblclick_handler_1 = id => start_edit(id);
	const keydown_handler = (i, j, id, e) => handle_keydown(e, i, j, id);

	function upload_dragging_binding(value) {
		dragging = value;
		$$invalidate(11, dragging);
	}

	const load_handler = e => blob_to_string(data_uri_to_blob(e.detail.data));
	const click_handler_2 = () => add_row();

	$$self.$$set = $$props => {
		if ('headers' in $$props) $$invalidate(24, headers = $$props.headers);
		if ('values' in $$props) $$invalidate(23, values = $$props.values);
		if ('col_count' in $$props) $$invalidate(0, col_count = $$props.col_count);
		if ('row_count' in $$props) $$invalidate(1, row_count = $$props.row_count);
		if ('editable' in $$props) $$invalidate(2, editable = $$props.editable);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		tick,
		dsvFormat,
		dequal,
		Upload,
		EditableCell,
		headers,
		values,
		col_count,
		row_count,
		editable,
		dispatch,
		editing,
		selected,
		els,
		make_headers,
		process_data,
		_headers,
		old_headers,
		refresh_focus,
		data,
		old_val,
		get_sort_status,
		get_current_indices,
		start_edit,
		handle_keydown,
		handle_cell_click,
		set_focus,
		sort_direction,
		sort_by,
		sort,
		handle_sort,
		header_edit,
		edit_header,
		end_header_edit,
		add_row,
		add_col,
		handle_click_outside,
		guess_delimitaor,
		data_uri_to_blob,
		blob_to_string,
		dragging
	});

	$$self.$inject_state = $$props => {
		if ('headers' in $$props) $$invalidate(24, headers = $$props.headers);
		if ('values' in $$props) $$invalidate(23, values = $$props.values);
		if ('col_count' in $$props) $$invalidate(0, col_count = $$props.col_count);
		if ('row_count' in $$props) $$invalidate(1, row_count = $$props.row_count);
		if ('editable' in $$props) $$invalidate(2, editable = $$props.editable);
		if ('editing' in $$props) $$invalidate(3, editing = $$props.editing);
		if ('selected' in $$props) $$invalidate(4, selected = $$props.selected);
		if ('els' in $$props) $$invalidate(7, els = $$props.els);
		if ('_headers' in $$props) $$invalidate(5, _headers = $$props._headers);
		if ('old_headers' in $$props) $$invalidate(25, old_headers = $$props.old_headers);
		if ('data' in $$props) $$invalidate(6, data = $$props.data);
		if ('old_val' in $$props) $$invalidate(26, old_val = $$props.old_val);
		if ('sort_direction' in $$props) $$invalidate(8, sort_direction = $$props.sort_direction);
		if ('sort_by' in $$props) $$invalidate(9, sort_by = $$props.sort_by);
		if ('header_edit' in $$props) $$invalidate(10, header_edit = $$props.header_edit);
		if ('dragging' in $$props) $$invalidate(11, dragging = $$props.dragging);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*headers, old_headers*/ 50331648) {
			{
				if (!dequal(headers, old_headers)) {
					$$invalidate(5, _headers = make_headers(headers));
					$$invalidate(25, old_headers = headers);
					refresh_focus();
				}
			}
		}

		if ($$self.$$.dirty[0] & /*values, old_val*/ 75497472) {
			if (!dequal(values, old_val)) {
				$$invalidate(6, data = process_data(values));
				$$invalidate(26, old_val = values);
				refresh_focus();
			}
		}

		if ($$self.$$.dirty[0] & /*_headers, data*/ 96) {
			_headers && dispatch("change", data.map(r => r.map(({ value }) => value)));
		}

		if ($$self.$$.dirty[0] & /*editing*/ 8) {
			set_focus(editing, "edit");
		}

		if ($$self.$$.dirty[0] & /*selected*/ 16) {
			set_focus(selected, "select");
		}
	};

	return [
		col_count,
		row_count,
		editable,
		editing,
		selected,
		_headers,
		data,
		els,
		sort_direction,
		sort_by,
		header_edit,
		dragging,
		get_sort_status,
		start_edit,
		handle_keydown,
		handle_cell_click,
		handle_sort,
		edit_header,
		end_header_edit,
		add_row,
		add_col,
		handle_click_outside,
		blob_to_string,
		values,
		headers,
		old_headers,
		old_val,
		editablecell_el_binding,
		dblclick_handler,
		click_handler,
		th_binding,
		editablecell_value_binding,
		editablecell_el_binding_1,
		td_binding,
		click_handler_1,
		dblclick_handler_1,
		keydown_handler,
		upload_dragging_binding,
		load_handler,
		click_handler_2
	];
}

class Table extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				headers: 24,
				values: 23,
				col_count: 0,
				row_count: 1,
				editable: 2
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Table",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*col_count*/ ctx[0] === undefined && !('col_count' in props)) {
			console.warn("<Table> was created without expected prop 'col_count'");
		}

		if (/*row_count*/ ctx[1] === undefined && !('row_count' in props)) {
			console.warn("<Table> was created without expected prop 'row_count'");
		}
	}

	get headers() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set headers(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get values() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set values(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get col_count() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set col_count(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get row_count() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set row_count(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editable() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editable(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/DataFrame/DataFrame.svelte generated by Svelte v3.47.0 */
const file = "src/components/DataFrame/DataFrame.svelte";

function create_fragment(ctx) {
	let div;
	let statustracker;
	let t;
	let table;
	let current;
	const statustracker_spread_levels = [/*loading_status*/ ctx[7]];
	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new StatusTracker({
			props: statustracker_props,
			$$inline: true
		});

	table = new Table({
			props: {
				row_count: /*row_count*/ ctx[5],
				col_count: /*col_count*/ ctx[4],
				values: /*value*/ ctx[1],
				headers: /*headers*/ ctx[0],
				editable: /*mode*/ ctx[3] === "dynamic"
			},
			$$inline: true
		});

	table.$on("change", /*handle_change*/ ctx[8]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(statustracker.$$.fragment);
			t = space();
			create_component(table.$$.fragment);
			attr_dev(div, "id", /*elem_id*/ ctx[2]);
			attr_dev(div, "class", "relative overflow-hidden");
			toggle_class(div, "flex-1", /*parent*/ ctx[6] === "row" || !/*parent*/ ctx[6]);
			add_location(div, file, 30, 0, 811);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(statustracker, div, null);
			append_dev(div, t);
			mount_component(table, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const statustracker_changes = (dirty & /*loading_status*/ 128)
			? get_spread_update(statustracker_spread_levels, [get_spread_object(/*loading_status*/ ctx[7])])
			: {};

			statustracker.$set(statustracker_changes);
			const table_changes = {};
			if (dirty & /*row_count*/ 32) table_changes.row_count = /*row_count*/ ctx[5];
			if (dirty & /*col_count*/ 16) table_changes.col_count = /*col_count*/ ctx[4];
			if (dirty & /*value*/ 2) table_changes.values = /*value*/ ctx[1];
			if (dirty & /*headers*/ 1) table_changes.headers = /*headers*/ ctx[0];
			if (dirty & /*mode*/ 8) table_changes.editable = /*mode*/ ctx[3] === "dynamic";
			table.$set(table_changes);

			if (!current || dirty & /*elem_id*/ 4) {
				attr_dev(div, "id", /*elem_id*/ ctx[2]);
			}

			if (dirty & /*parent*/ 64) {
				toggle_class(div, "flex-1", /*parent*/ ctx[6] === "row" || !/*parent*/ ctx[6]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(table.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(table.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(statustracker);
			destroy_component(table);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DataFrame', slots, []);
	let { headers = [] } = $$props;
	let { elem_id = "" } = $$props;
	let { value = [["", "", ""]] } = $$props;
	let { mode } = $$props;
	let { col_count } = $$props;
	let { row_count } = $$props;
	let { parent = null } = $$props;
	const dispatch = createEventDispatcher();
	let { loading_status } = $$props;

	async function handle_change({ detail }) {
		$$invalidate(1, value = detail);
		await tick();
		dispatch("change", detail);
	}

	const writable_props = [
		'headers',
		'elem_id',
		'value',
		'mode',
		'col_count',
		'row_count',
		'parent',
		'loading_status'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DataFrame> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('headers' in $$props) $$invalidate(0, headers = $$props.headers);
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
		if ('col_count' in $$props) $$invalidate(4, col_count = $$props.col_count);
		if ('row_count' in $$props) $$invalidate(5, row_count = $$props.row_count);
		if ('parent' in $$props) $$invalidate(6, parent = $$props.parent);
		if ('loading_status' in $$props) $$invalidate(7, loading_status = $$props.loading_status);
	};

	$$self.$capture_state = () => ({
		Table,
		StatusTracker,
		createEventDispatcher,
		tick,
		headers,
		elem_id,
		value,
		mode,
		col_count,
		row_count,
		parent,
		dispatch,
		loading_status,
		handle_change
	});

	$$self.$inject_state = $$props => {
		if ('headers' in $$props) $$invalidate(0, headers = $$props.headers);
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
		if ('col_count' in $$props) $$invalidate(4, col_count = $$props.col_count);
		if ('row_count' in $$props) $$invalidate(5, row_count = $$props.row_count);
		if ('parent' in $$props) $$invalidate(6, parent = $$props.parent);
		if ('loading_status' in $$props) $$invalidate(7, loading_status = $$props.loading_status);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value, headers*/ 3) {
			{
				if (!Array.isArray(value)) {
					if (Array.isArray(value.headers)) $$invalidate(0, headers = value.headers);

					$$invalidate(1, value = value.data.length === 0
					? [Array(headers.length).fill("")]
					: value.data);
				} else {
					($$invalidate(1, value), $$invalidate(0, headers));
				}
			}
		}
	};

	return [
		headers,
		value,
		elem_id,
		mode,
		col_count,
		row_count,
		parent,
		loading_status,
		handle_change
	];
}

class DataFrame extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			headers: 0,
			elem_id: 2,
			value: 1,
			mode: 3,
			col_count: 4,
			row_count: 5,
			parent: 6,
			loading_status: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DataFrame",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[3] === undefined && !('mode' in props)) {
			console.warn("<DataFrame> was created without expected prop 'mode'");
		}

		if (/*col_count*/ ctx[4] === undefined && !('col_count' in props)) {
			console.warn("<DataFrame> was created without expected prop 'col_count'");
		}

		if (/*row_count*/ ctx[5] === undefined && !('row_count' in props)) {
			console.warn("<DataFrame> was created without expected prop 'row_count'");
		}

		if (/*loading_status*/ ctx[7] === undefined && !('loading_status' in props)) {
			console.warn("<DataFrame> was created without expected prop 'loading_status'");
		}
	}

	get headers() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set headers(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get elem_id() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set elem_id(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get col_count() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set col_count(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get row_count() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set row_count(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get parent() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set parent(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loading_status() {
		throw new Error("<DataFrame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loading_status(value) {
		throw new Error("<DataFrame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var DataFrame$1 = DataFrame;

const modes = ["static", "dynamic"];

export { DataFrame$1 as Component, modes };
